<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>beman::execution: beman::execution Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
 <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
 <script type="text/javascript">
     DoxygenAwesomeDarkModeToggle.init()
 </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="beman-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">beman::execution
   </div>
   <div id="projectbrief">Building Block For Asynchronous Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacebeman_1_1execution.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">beman::execution Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for asynchronous operations and their vocabulary.  
<a href="namespacebeman_1_1execution.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1as__awaitable__t.html">as_awaitable_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an entity, e.g., a sender, into an awaitable.  <a href="structbeman_1_1execution_1_1as__awaitable__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1completion__signatures.html">completion_signatures</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template used to a specify a list of completion signatures.  <a href="structbeman_1_1execution_1_1completion__signatures.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1counting__scope.html">counting_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1default__domain.html">default_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain type used when no domain is specified explicitly.  <a href="structbeman_1_1execution_1_1default__domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1env.html">env</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__allocator__t.html">get_allocator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__completion__scheduler__t.html">get_completion_scheduler_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__completion__signatures__t.html">get_completion_signatures_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__delegation__scheduler__t.html">get_delegation_scheduler_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__domain__t.html">get_domain_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__env__t.html">get_env_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__scheduler__t.html">get_scheduler_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1get__stop__token__t.html">get_stop_token_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1inplace__stop__callback.html">inplace_stop_callback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1inplace__stop__source.html">inplace_stop_source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1inplace__stop__token.html">inplace_stop_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1never__stop__token.html">never_stop_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1nostopstate__t.html">nostopstate_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1operation__state__t.html">operation_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1prop.html">prop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1receiver__t.html">receiver_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1run__loop.html">run_loop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1schedule__t.html">schedule_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1scheduler__t.html">scheduler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type to indicate a class is a scheduler.  <a href="structbeman_1_1execution_1_1scheduler__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1sender__adaptor__closure.html">sender_adaptor_closure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1sender__t.html">sender_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1set__error__t.html">set_error_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the customization point object for error completions.  <a href="structbeman_1_1execution_1_1set__error__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1set__stopped__t.html">set_stopped_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the customization point object for cancellation completions.  <a href="structbeman_1_1execution_1_1set__stopped__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1set__value__t.html">set_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the customization point object for successful completions.  <a href="structbeman_1_1execution_1_1set__value__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1simple__counting__scope.html">simple_counting_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1start__t.html">start_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1stop__callback.html">stop_callback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1stop__source.html">stop_source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbeman_1_1execution_1_1stop__token.html">stop_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbeman_1_1execution_1_1with__awaitable__senders.html">with_awaitable_senders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1operation__state.html">operation_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1receiver.html">receiver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1receiver__of.html">receiver_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1scheduler.html">scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1scope__token.html">scope_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1sender.html">sender</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1sender__in.html">sender_in</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1stoppable__token.html">stoppable_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptbeman_1_1execution_1_1unstoppable__token.html">unstoppable_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1f94aa0e5e5a137c6565d439e868320b"><td class="memItemLeft" align="right" valign="top"><a id="a1f94aa0e5e5a137c6565d439e868320b" name="a1f94aa0e5e5a137c6565d439e868320b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>affine_on_t</b> = beman::execution::detail::affine_on_t</td></tr>
<tr class="memdesc:a1f94aa0e5e5a137c6565d439e868320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">affine_on is a CPO, used to adapt a sender to complete on the scheduler it got started on which is derived from get_scheduler on the receiver's environment. <br /></td></tr>
<tr class="separator:a1f94aa0e5e5a137c6565d439e868320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895bd0a9db25eeec7ff44a98312056de"><td class="memItemLeft" align="right" valign="top"><a id="a895bd0a9db25eeec7ff44a98312056de" name="a895bd0a9db25eeec7ff44a98312056de"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>associate_t</b> = ::beman::execution::detail::associate_t</td></tr>
<tr class="separator:a895bd0a9db25eeec7ff44a98312056de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046e1ca02363578c729a48444e60251"><td class="memItemLeft" align="right" valign="top"><a id="a8046e1ca02363578c729a48444e60251" name="a8046e1ca02363578c729a48444e60251"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>bulk_t</b> = ::beman::execution::detail::bulk_t</td></tr>
<tr class="separator:a8046e1ca02363578c729a48444e60251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a6f9a91e53c4387f1f0d6990726c3"><td class="memTemplParams" colspan="2"><a id="a9f4a6f9a91e53c4387f1f0d6990726c3" name="a9f4a6f9a91e53c4387f1f0d6990726c3"></a>
template&lt;typename Sender , typename Env  = ::beman::execution::env&lt;&gt;&gt; </td></tr>
<tr class="memitem:a9f4a6f9a91e53c4387f1f0d6990726c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>completion_signatures_of_t</b> = ::beman::execution::detail::call_result_t&lt;<a class="el" href="structbeman_1_1execution_1_1get__completion__signatures__t.html">::beman::execution::get_completion_signatures_t</a>, Sender, Env &gt;</td></tr>
<tr class="memdesc:a9f4a6f9a91e53c4387f1f0d6990726c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to access the completion signatures of a sender. <br /></td></tr>
<tr class="separator:a9f4a6f9a91e53c4387f1f0d6990726c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806dab6de1ac6ae4ec22419cd4ea1e11"><td class="memItemLeft" align="right" valign="top"><a id="a806dab6de1ac6ae4ec22419cd4ea1e11" name="a806dab6de1ac6ae4ec22419cd4ea1e11"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>connect_t</b> = beman::execution::detail::connect_t</td></tr>
<tr class="memdesc:a806dab6de1ac6ae4ec22419cd4ea1e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the connect customization point object. <br /></td></tr>
<tr class="separator:a806dab6de1ac6ae4ec22419cd4ea1e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04076b97aa86da382501e357c0b88cf1"><td class="memTemplParams" colspan="2"><a id="a04076b97aa86da382501e357c0b88cf1" name="a04076b97aa86da382501e357c0b88cf1"></a>
template&lt;typename Sender , typename Receiver &gt; </td></tr>
<tr class="memitem:a04076b97aa86da382501e357c0b88cf1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>connect_result_t</b> = decltype(<a class="el" href="namespacebeman_1_1execution.html#af3ca0aa23afbd3f71811787934127535">::beman::execution::connect</a>(::std::declval&lt; Sender &gt;(), ::std::declval&lt; Receiver &gt;()))</td></tr>
<tr class="memdesc:a04076b97aa86da382501e357c0b88cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to determine the operation state type returned from <code><a class="el" href="namespacebeman_1_1execution.html#af3ca0aa23afbd3f71811787934127535" title="Customization point object used to connect a sender and a receiver.">connect()</a></code>. <br /></td></tr>
<tr class="separator:a04076b97aa86da382501e357c0b88cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec91a89ee087ddb9f41ad03771ed3b36"><td class="memItemLeft" align="right" valign="top"><a id="aec91a89ee087ddb9f41ad03771ed3b36" name="aec91a89ee087ddb9f41ad03771ed3b36"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>continues_on_t</b> = ::beman::execution::detail::continues_on_t</td></tr>
<tr class="separator:aec91a89ee087ddb9f41ad03771ed3b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf95c8f3480ba2c1d78b8c612a9f2f7"><td class="memTemplParams" colspan="2"><a id="adbf95c8f3480ba2c1d78b8c612a9f2f7" name="adbf95c8f3480ba2c1d78b8c612a9f2f7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbf95c8f3480ba2c1d78b8c612a9f2f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>env_of_t</b> = decltype(::beman::execution::get_env(::std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:adbf95c8f3480ba2c1d78b8c612a9f2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the type of the environment associated with a type. <br /></td></tr>
<tr class="separator:adbf95c8f3480ba2c1d78b8c612a9f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1fa81c64e7dc8ba45c7744cddae76"><td class="memTemplParams" colspan="2"><a id="af6f1fa81c64e7dc8ba45c7744cddae76" name="af6f1fa81c64e7dc8ba45c7744cddae76"></a>
template&lt;typename Sender , typename Env  = ::beman::execution::env&lt;&gt;, template&lt; typename... &gt; class Variant = ::beman::execution::detail::variant_or_empty&gt; </td></tr>
<tr class="memitem:af6f1fa81c64e7dc8ba45c7744cddae76"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>error_types_of_t</b> = ::beman::execution::detail::gather_signatures&lt;<a class="el" href="structbeman_1_1execution_1_1set__error__t.html">::beman::execution::set_error_t</a>, <a class="el" href="namespacebeman_1_1execution.html#a9f4a6f9a91e53c4387f1f0d6990726c3">::beman::execution::completion_signatures_of_t</a>&lt; Sender, Env &gt;, ::std::type_identity_t, Variant &gt;</td></tr>
<tr class="memdesc:af6f1fa81c64e7dc8ba45c7744cddae76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to get error types for a sender. <br /></td></tr>
<tr class="separator:af6f1fa81c64e7dc8ba45c7744cddae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26102229c0893bcb416cb2acb6b9fed6"><td class="memItemLeft" align="right" valign="top"><a id="a26102229c0893bcb416cb2acb6b9fed6" name="a26102229c0893bcb416cb2acb6b9fed6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>forwarding_query_t</b> = beman::execution::detail::forwarding_query_t</td></tr>
<tr class="memdesc:a26102229c0893bcb416cb2acb6b9fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the forwarding_query customization point object. <br /></td></tr>
<tr class="separator:a26102229c0893bcb416cb2acb6b9fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ed0592d83af12954a976a5cef81d27"><td class="memItemLeft" align="right" valign="top"><a id="a18ed0592d83af12954a976a5cef81d27" name="a18ed0592d83af12954a976a5cef81d27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>into_variant_t</b> = ::beman::execution::detail::into_variant_t</td></tr>
<tr class="separator:a18ed0592d83af12954a976a5cef81d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42df6149be2a57902ed8c7f957ee635"><td class="memItemLeft" align="right" valign="top"><a id="ab42df6149be2a57902ed8c7f957ee635" name="ab42df6149be2a57902ed8c7f957ee635"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>just_t</b> = ::beman::execution::detail::just_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__value__t.html">::beman::execution::set_value_t</a> &gt;</td></tr>
<tr class="separator:ab42df6149be2a57902ed8c7f957ee635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae05a96708f8ec5b0756f9b824942a8"><td class="memItemLeft" align="right" valign="top"><a id="acae05a96708f8ec5b0756f9b824942a8" name="acae05a96708f8ec5b0756f9b824942a8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>just_error_t</b> = ::beman::execution::detail::just_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__error__t.html">::beman::execution::set_error_t</a> &gt;</td></tr>
<tr class="separator:acae05a96708f8ec5b0756f9b824942a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adcaf8732a3240da38fd7d1652d53ed"><td class="memItemLeft" align="right" valign="top"><a id="a4adcaf8732a3240da38fd7d1652d53ed" name="a4adcaf8732a3240da38fd7d1652d53ed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>just_stopped_t</b> = ::beman::execution::detail::just_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__stopped__t.html">::beman::execution::set_stopped_t</a> &gt;</td></tr>
<tr class="separator:a4adcaf8732a3240da38fd7d1652d53ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75785553f8fe14d3c09b03d4ae56d7c4"><td class="memItemLeft" align="right" valign="top"><a id="a75785553f8fe14d3c09b03d4ae56d7c4" name="a75785553f8fe14d3c09b03d4ae56d7c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>let_error_t</b> = ::beman::execution::detail::let_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__error__t.html">::beman::execution::set_error_t</a> &gt;</td></tr>
<tr class="separator:a75785553f8fe14d3c09b03d4ae56d7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b09b878ea06fa88398356a8fe9bd931"><td class="memItemLeft" align="right" valign="top"><a id="a6b09b878ea06fa88398356a8fe9bd931" name="a6b09b878ea06fa88398356a8fe9bd931"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>let_stopped_t</b> = ::beman::execution::detail::let_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__stopped__t.html">::beman::execution::set_stopped_t</a> &gt;</td></tr>
<tr class="separator:a6b09b878ea06fa88398356a8fe9bd931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551ee6bae74cff79012dedad54aa3a31"><td class="memItemLeft" align="right" valign="top"><a id="a551ee6bae74cff79012dedad54aa3a31" name="a551ee6bae74cff79012dedad54aa3a31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>let_value_t</b> = ::beman::execution::detail::let_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__value__t.html">::beman::execution::set_value_t</a> &gt;</td></tr>
<tr class="separator:a551ee6bae74cff79012dedad54aa3a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4d0a9aa8369f7770ba909226a37032"><td class="memItemLeft" align="right" valign="top"><a id="aaa4d0a9aa8369f7770ba909226a37032" name="aaa4d0a9aa8369f7770ba909226a37032"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>on_t</b> = ::beman::execution::detail::on_t</td></tr>
<tr class="separator:aaa4d0a9aa8369f7770ba909226a37032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b7c9d496e8f6070be16e7fd0fb6b3"><td class="memItemLeft" align="right" valign="top"><a id="aac2b7c9d496e8f6070be16e7fd0fb6b3" name="aac2b7c9d496e8f6070be16e7fd0fb6b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>read_env_t</b> = beman::execution::detail::read_env_t</td></tr>
<tr class="separator:aac2b7c9d496e8f6070be16e7fd0fb6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3fc269b81e5b144fb5e540f08cc968"><td class="memItemLeft" align="right" valign="top"><a id="aca3fc269b81e5b144fb5e540f08cc968" name="aca3fc269b81e5b144fb5e540f08cc968"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>schedule_from_t</b> = beman::execution::detail::schedule_from_t</td></tr>
<tr class="separator:aca3fc269b81e5b144fb5e540f08cc968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1725c7792650f8912632c997a7b7d8d6"><td class="memTemplParams" colspan="2"><a id="a1725c7792650f8912632c997a7b7d8d6" name="a1725c7792650f8912632c997a7b7d8d6"></a>
template&lt;::beman::execution::scheduler Scheduler&gt; </td></tr>
<tr class="memitem:a1725c7792650f8912632c997a7b7d8d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>schedule_result_t</b> = decltype(::beman::execution::schedule(::std::declval&lt; Scheduler &gt;()))</td></tr>
<tr class="separator:a1725c7792650f8912632c997a7b7d8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e3f7450698863bc16128a74177f7b4"><td class="memItemLeft" align="right" valign="top"><a id="ad2e3f7450698863bc16128a74177f7b4" name="ad2e3f7450698863bc16128a74177f7b4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>spawn_t</b> = ::beman::execution::detail::spawn_t</td></tr>
<tr class="separator:ad2e3f7450698863bc16128a74177f7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d723b3cb43a250ea12cd379a22de78a"><td class="memItemLeft" align="right" valign="top"><a id="a6d723b3cb43a250ea12cd379a22de78a" name="a6d723b3cb43a250ea12cd379a22de78a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>spawn_future_t</b> = ::beman::execution::detail::spawn_future_t</td></tr>
<tr class="separator:a6d723b3cb43a250ea12cd379a22de78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d564762658850291d70725c464e525"><td class="memItemLeft" align="right" valign="top"><a id="a69d564762658850291d70725c464e525" name="a69d564762658850291d70725c464e525"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>split_t</b> = ::beman::execution::detail::split_t</td></tr>
<tr class="separator:a69d564762658850291d70725c464e525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cdb3f6523297bbe5fe7039d9038353"><td class="memItemLeft" align="right" valign="top"><a id="aa9cdb3f6523297bbe5fe7039d9038353" name="aa9cdb3f6523297bbe5fe7039d9038353"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>starts_on_t</b> = ::beman::execution::detail::starts_on_t</td></tr>
<tr class="separator:aa9cdb3f6523297bbe5fe7039d9038353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8918e74a15e075db6bdc489061b115c"><td class="memTemplParams" colspan="2"><a id="af8918e74a15e075db6bdc489061b115c" name="af8918e74a15e075db6bdc489061b115c"></a>
template&lt;class Token , class CallbackFun &gt; </td></tr>
<tr class="memitem:af8918e74a15e075db6bdc489061b115c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stop_callback_for_t</b> = typename Token::template callback_type&lt; CallbackFun &gt;</td></tr>
<tr class="separator:af8918e74a15e075db6bdc489061b115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723e69a00079eaf4cef95dbc668890c"><td class="memTemplParams" colspan="2"><a id="a0723e69a00079eaf4cef95dbc668890c" name="a0723e69a00079eaf4cef95dbc668890c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0723e69a00079eaf4cef95dbc668890c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stop_token_of_t</b> = ::std::remove_cvref_t&lt; decltype(::beman::execution::get_stop_token(::std::declval&lt; T &gt;()))&gt;</td></tr>
<tr class="separator:a0723e69a00079eaf4cef95dbc668890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489dd5027adc6e6cb41ced184520df9"><td class="memItemLeft" align="right" valign="top"><a id="a8489dd5027adc6e6cb41ced184520df9" name="a8489dd5027adc6e6cb41ced184520df9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>sync_wait_t</b> = ::beman::execution::detail::sync_wait_t</td></tr>
<tr class="separator:a8489dd5027adc6e6cb41ced184520df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3e3ee867e5b5dc46f2ae600029b969"><td class="memTemplParams" colspan="2"><a id="adc3e3ee867e5b5dc46f2ae600029b969" name="adc3e3ee867e5b5dc46f2ae600029b969"></a>
template&lt;typename Sender &gt; </td></tr>
<tr class="memitem:adc3e3ee867e5b5dc46f2ae600029b969"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tag_of_t</b> = typename decltype(::beman::execution::detail::get_sender_meta(::std::declval&lt; Sender &amp;&amp; &gt;()))::tag_type</td></tr>
<tr class="separator:adc3e3ee867e5b5dc46f2ae600029b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d128b0eb18329ca6d9dff7068eaf865"><td class="memItemLeft" align="right" valign="top"><a id="a4d128b0eb18329ca6d9dff7068eaf865" name="a4d128b0eb18329ca6d9dff7068eaf865"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>then_t</b> = ::beman::execution::detail::then_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__value__t.html">::beman::execution::set_value_t</a> &gt;</td></tr>
<tr class="memdesc:a4d128b0eb18329ca6d9dff7068eaf865"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>then_t</code> is the type of <code>then</code>. <br /></td></tr>
<tr class="separator:a4d128b0eb18329ca6d9dff7068eaf865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edc31fa03580fefdec5ff9de774cd7b"><td class="memItemLeft" align="right" valign="top"><a id="a5edc31fa03580fefdec5ff9de774cd7b" name="a5edc31fa03580fefdec5ff9de774cd7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>upon_error_t</b> = ::beman::execution::detail::then_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__error__t.html">::beman::execution::set_error_t</a> &gt;</td></tr>
<tr class="memdesc:a5edc31fa03580fefdec5ff9de774cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>upon_error_t</code> is the type of <code>upon_error</code>. <br /></td></tr>
<tr class="separator:a5edc31fa03580fefdec5ff9de774cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b0f844f19033a9aff2385c0c2532d"><td class="memItemLeft" align="right" valign="top"><a id="a724b0f844f19033a9aff2385c0c2532d" name="a724b0f844f19033a9aff2385c0c2532d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>upon_stopped_t</b> = ::beman::execution::detail::then_t&lt;<a class="el" href="structbeman_1_1execution_1_1set__stopped__t.html">::beman::execution::set_stopped_t</a> &gt;</td></tr>
<tr class="memdesc:a724b0f844f19033a9aff2385c0c2532d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>upon_stopped_t</code> is the type of <code>upon_stopped</code>. <br /></td></tr>
<tr class="separator:a724b0f844f19033a9aff2385c0c2532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d065a1873eb0331785f8a5b82b998a9"><td class="memTemplParams" colspan="2"><a id="a0d065a1873eb0331785f8a5b82b998a9" name="a0d065a1873eb0331785f8a5b82b998a9"></a>
template&lt;typename Sender , typename Env  = ::beman::execution::env&lt;&gt;, template&lt; typename... &gt; class Tuple = ::beman::execution::detail::decayed_tuple, template&lt; typename... &gt; class Variant = ::beman::execution::detail::variant_or_empty&gt; </td></tr>
<tr class="memitem:a0d065a1873eb0331785f8a5b82b998a9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value_types_of_t</b> = ::beman::execution::detail::gather_signatures&lt;<a class="el" href="structbeman_1_1execution_1_1set__value__t.html">::beman::execution::set_value_t</a>, <a class="el" href="namespacebeman_1_1execution.html#a9f4a6f9a91e53c4387f1f0d6990726c3">::beman::execution::completion_signatures_of_t</a>&lt; Sender, Env &gt;, Tuple, Variant &gt;</td></tr>
<tr class="separator:a0d065a1873eb0331785f8a5b82b998a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e0057cc0fa2bc8a40215fdc5c2195"><td class="memItemLeft" align="right" valign="top"><a id="a349e0057cc0fa2bc8a40215fdc5c2195" name="a349e0057cc0fa2bc8a40215fdc5c2195"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>when_all_t</b> = ::beman::execution::detail::when_all_t</td></tr>
<tr class="separator:a349e0057cc0fa2bc8a40215fdc5c2195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ac724cb97c8dead21df1bc4be1ee2"><td class="memItemLeft" align="right" valign="top"><a id="a207ac724cb97c8dead21df1bc4be1ee2" name="a207ac724cb97c8dead21df1bc4be1ee2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>when_all_with_variant_t</b> = ::beman::execution::detail::when_all_with_variant_t</td></tr>
<tr class="separator:a207ac724cb97c8dead21df1bc4be1ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b2d0f0e8241817d5e513308337252"><td class="memItemLeft" align="right" valign="top"><a id="ae08b2d0f0e8241817d5e513308337252" name="ae08b2d0f0e8241817d5e513308337252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>write_env_t</b> = ::beman::execution::detail::write_env_t</td></tr>
<tr class="separator:ae08b2d0f0e8241817d5e513308337252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49785ab95a2c693944e1a84ab7ed2bec"><td class="memTemplParams" colspan="2"><a id="a49785ab95a2c693944e1a84ab7ed2bec" name="a49785ab95a2c693944e1a84ab7ed2bec"></a>
template&lt;typename Domain , typename Tag , ::beman::execution::sender Sender, typename... Args&gt; <br />
requires requires(Domain domain, Tag tag, Sender&amp;&amp; sender, Args&amp;&amp;... args) { domain.apply_sender(Tag(), ::std::forward&lt;Sender&gt;(sender), ::std::forward&lt;Args&gt;(args)...); }</td></tr>
<tr class="memitem:a49785ab95a2c693944e1a84ab7ed2bec"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_sender</b> (Domain domain, Tag, Sender &amp;&amp;sender, Args &amp;&amp;... args) noexcept(noexcept(domain.apply_sender(Tag(), ::std::forward&lt; Sender &gt;(sender), ::std::forward&lt; Args &gt;(args)...))) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a49785ab95a2c693944e1a84ab7ed2bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to transform a sender and its arguments for a domain. <br /></td></tr>
<tr class="separator:a49785ab95a2c693944e1a84ab7ed2bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2237cec640f636800ac30b98d7c8a527"><td class="memTemplParams" colspan="2"><a id="a2237cec640f636800ac30b98d7c8a527" name="a2237cec640f636800ac30b98d7c8a527"></a>
template&lt;typename Domain , typename Tag , ::beman::execution::sender Sender, typename... Args&gt; <br />
requires (not requires(Domain domain, Tag tag, Sender&amp;&amp; sender, Args&amp;&amp;... args) { domain.apply_sender(Tag(), ::std::forward&lt;Sender&gt;(sender), ::std::forward&lt;Args&gt;(args)...); }) &amp;&amp; requires(Tag tag, Sender&amp;&amp; sender, Args&amp;&amp;... args) { <a class="el" href="structbeman_1_1execution_1_1default__domain.html">beman::execution::default_domain</a>().apply_sender( Tag(), ::std::forward&lt;Sender&gt;(sender), ::std::forward&lt;Args&gt;(args)...); }</td></tr>
<tr class="memitem:a2237cec640f636800ac30b98d7c8a527"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_sender</b> (Domain, Tag, Sender &amp;&amp;sender, Args &amp;&amp;... args) noexcept(noexcept(<a class="el" href="structbeman_1_1execution_1_1default__domain.html">beman::execution::default_domain</a>().apply_sender(Tag(), ::std::forward&lt; Sender &gt;(sender), ::std::forward&lt; Args &gt;(args)...))) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a2237cec640f636800ac30b98d7c8a527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default function used to transform a second and its arguments. <br /></td></tr>
<tr class="separator:a2237cec640f636800ac30b98d7c8a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aa8b475d5da0dce5eceda67eeca375"><td class="memTemplParams" colspan="2"><a id="a84aa8b475d5da0dce5eceda67eeca375" name="a84aa8b475d5da0dce5eceda67eeca375"></a>
template&lt;::beman::execution::detail::queryable... Envs&gt; </td></tr>
<tr class="memitem:a84aa8b475d5da0dce5eceda67eeca375"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>env</b> (Envs...) -&gt; <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>&lt;::std::unwrap_reference_t&lt; Envs &gt;... &gt;</td></tr>
<tr class="separator:a84aa8b475d5da0dce5eceda67eeca375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce2b9a2a208e8dde1097b3daba40b8e"><td class="memTemplParams" colspan="2"><a id="adce2b9a2a208e8dde1097b3daba40b8e" name="adce2b9a2a208e8dde1097b3daba40b8e"></a>
template&lt;typename CallbackFun &gt; </td></tr>
<tr class="memitem:adce2b9a2a208e8dde1097b3daba40b8e"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inplace_stop_callback</b> (<a class="el" href="classbeman_1_1execution_1_1inplace__stop__token.html">::beman::execution::inplace_stop_token</a>, CallbackFun) -&gt; <a class="el" href="classbeman_1_1execution_1_1inplace__stop__callback.html">inplace_stop_callback</a>&lt; CallbackFun &gt;</td></tr>
<tr class="separator:adce2b9a2a208e8dde1097b3daba40b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebbf3d4466b511b144dab4e94fff815"><td class="memTemplParams" colspan="2"><a id="a4ebbf3d4466b511b144dab4e94fff815" name="a4ebbf3d4466b511b144dab4e94fff815"></a>
template&lt;typename Query , typename Value &gt; </td></tr>
<tr class="memitem:a4ebbf3d4466b511b144dab4e94fff815"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prop</b> (Query, Value, ::beman::execution::detail::non_assignable={}) -&gt; <a class="el" href="structbeman_1_1execution_1_1prop.html">prop</a>&lt; Query, ::std::unwrap_reference_t&lt; Value &gt; &gt;</td></tr>
<tr class="separator:a4ebbf3d4466b511b144dab4e94fff815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6580a8db07d4da61b60c68e6b1fbf9"><td class="memTemplParams" colspan="2"><a id="a3a6580a8db07d4da61b60c68e6b1fbf9" name="a3a6580a8db07d4da61b60c68e6b1fbf9"></a>
template&lt;typename CallbackFun &gt; </td></tr>
<tr class="memitem:a3a6580a8db07d4da61b60c68e6b1fbf9"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stop_callback</b> (<a class="el" href="classbeman_1_1execution_1_1stop__token.html">::beman::execution::stop_token</a>, CallbackFun) -&gt; <a class="el" href="classbeman_1_1execution_1_1stop__callback.html">stop_callback</a>&lt; CallbackFun &gt;</td></tr>
<tr class="separator:a3a6580a8db07d4da61b60c68e6b1fbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747bfb164fb1f39a778d9869ec7d254b"><td class="memTemplParams" colspan="2"><a id="a747bfb164fb1f39a778d9869ec7d254b" name="a747bfb164fb1f39a778d9869ec7d254b"></a>
template&lt;typename Domain , ::beman::execution::sender Sender, typename... Env&gt; <br />
requires (sizeof...(Env) &lt; 2) &amp;&amp; requires(Domain dom, Sender&amp;&amp; sender, const Env&amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) { dom.transform_sender(::std::forward&lt;Sender&gt;(sender), env...); } &amp;&amp; (::std::same_as&lt;::std::remove_cvref_t&lt;Sender&gt;, std::remove_cvref_t&lt;decltype(::std::declval&lt;Domain&gt;().transform_sender( ::std::declval&lt;Sender&gt;(), ::std::declval&lt;const Env&amp;&gt;()...))&gt;&gt;)</td></tr>
<tr class="memitem:a747bfb164fb1f39a778d9869ec7d254b"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_sender</b> (Domain, Sender &amp;&amp;sender, const Env &amp;...) noexcept -&gt; ::beman::execution::sender decltype(auto)</td></tr>
<tr class="separator:a747bfb164fb1f39a778d9869ec7d254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e10036a829191b1700e44ad2596583"><td class="memTemplParams" colspan="2"><a id="af8e10036a829191b1700e44ad2596583" name="af8e10036a829191b1700e44ad2596583"></a>
template&lt;typename Domain , ::beman::execution::sender Sender, typename... Env&gt; <br />
requires (sizeof...(Env) &lt; 2) &amp;&amp; requires(Domain dom, Sender&amp;&amp; sender, const Env&amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) { dom.transform_sender(::std::forward&lt;Sender&gt;(sender), env...); } &amp;&amp; (!::std::same_as&lt;::std::remove_cvref_t&lt;Sender&gt;, std::remove_cvref_t&lt;decltype(::std::declval&lt;Domain&gt;().transform_sender( ::std::declval&lt;Sender&gt;(), ::std::declval&lt;const Env&amp;&gt;()...))&gt;&gt;)</td></tr>
<tr class="memitem:af8e10036a829191b1700e44ad2596583"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_sender</b> (Domain dom, Sender &amp;&amp;sender, const Env &amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) noexcept -&gt; ::beman::execution::sender auto</td></tr>
<tr class="separator:af8e10036a829191b1700e44ad2596583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d8084846dec8cd639a437f3d58c171"><td class="memTemplParams" colspan="2"><a id="a36d8084846dec8cd639a437f3d58c171" name="a36d8084846dec8cd639a437f3d58c171"></a>
template&lt;typename Domain , ::beman::execution::sender Sender, typename... Env&gt; <br />
requires (sizeof...(Env) &lt; 2) &amp;&amp; (not requires(Domain dom, Sender&amp;&amp; sender, const Env&amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) { dom.transform_sender(::std::forward&lt;Sender&gt;(sender), env...); }) &amp;&amp; ::std::same_as&lt;::std::remove_cvref_t&lt;Sender&gt;, ::std::remove_cvref_t&lt;decltype(<a class="el" href="structbeman_1_1execution_1_1default__domain.html">::beman::execution::default_domain</a>{}.transform_sender( ::std::declval&lt;Sender&gt;(), ::std::declval&lt;Env&gt;()...))&gt;&gt;</td></tr>
<tr class="memitem:a36d8084846dec8cd639a437f3d58c171"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_sender</b> (Domain, Sender &amp;&amp;sender, const Env &amp;...) noexcept(noexcept(::std::forward&lt; Sender &gt;(sender))) -&gt; ::beman::execution::sender decltype(auto)</td></tr>
<tr class="separator:a36d8084846dec8cd639a437f3d58c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29906ce3293ff2b8e5c1448a34c47102"><td class="memTemplParams" colspan="2"><a id="a29906ce3293ff2b8e5c1448a34c47102" name="a29906ce3293ff2b8e5c1448a34c47102"></a>
template&lt;typename Domain , ::beman::execution::sender Sender, typename... Env&gt; <br />
requires (sizeof...(Env) &lt; 2) &amp;&amp; (not requires(Domain dom, Sender&amp;&amp; sender, const Env&amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) { dom.transform_sender(::std::forward&lt;Sender&gt;(sender), env...); }) &amp;&amp; (!::std::same_as&lt;::std::remove_cvref_t&lt;Sender&gt;, ::std::remove_cvref_t&lt;decltype(<a class="el" href="structbeman_1_1execution_1_1default__domain.html">::beman::execution::default_domain</a>{}.transform_sender( ::std::declval&lt;Sender&gt;(), ::std::declval&lt;Env&gt;()...))&gt;&gt;)</td></tr>
<tr class="memitem:a29906ce3293ff2b8e5c1448a34c47102"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_sender</b> (Domain dom, Sender &amp;&amp;sender, const Env &amp;... <a class="el" href="structbeman_1_1execution_1_1env.html">env</a>) noexcept(noexcept(::beman::execution::detail::transform_sender(dom, <a class="el" href="structbeman_1_1execution_1_1default__domain.html">::beman::execution::default_domain</a>{}.transform_sender(::std::declval&lt; Sender &gt;(), ::std::declval&lt; Env &gt;()...), env...))) -&gt; ::beman::execution::sender decltype(auto)</td></tr>
<tr class="separator:a29906ce3293ff2b8e5c1448a34c47102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a92547b10043bca20c540525b5f6176dd"><td class="memItemLeft" align="right" valign="top"><a id="a92547b10043bca20c540525b5f6176dd" name="a92547b10043bca20c540525b5f6176dd"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="namespacebeman_1_1execution.html#a1f94aa0e5e5a137c6565d439e868320b">affine_on_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>affine_on</b> {}</td></tr>
<tr class="separator:a92547b10043bca20c540525b5f6176dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f8f2865ea5e1dfa3fc0eb903f538d6"><td class="memItemLeft" align="right" valign="top"><a id="a51f8f2865ea5e1dfa3fc0eb903f538d6" name="a51f8f2865ea5e1dfa3fc0eb903f538d6"></a>
BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="structbeman_1_1execution_1_1as__awaitable__t.html">::beman::execution::as_awaitable_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>as_awaitable</b> {}</td></tr>
<tr class="separator:a51f8f2865ea5e1dfa3fc0eb903f538d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be360a29702fe08939dac511d0bf7c2"><td class="memItemLeft" align="right" valign="top"><a id="a7be360a29702fe08939dac511d0bf7c2" name="a7be360a29702fe08939dac511d0bf7c2"></a>
BEMAN_EXECUTION_EXPORT constexpr associate_t&#160;</td><td class="memItemRight" valign="bottom"><b>associate</b> {}</td></tr>
<tr class="separator:a7be360a29702fe08939dac511d0bf7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e64daaf1e76d3a08e76838c9f3aa2c"><td class="memItemLeft" align="right" valign="top"><a id="ac9e64daaf1e76d3a08e76838c9f3aa2c" name="ac9e64daaf1e76d3a08e76838c9f3aa2c"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::bulk_t&#160;</td><td class="memItemRight" valign="bottom"><b>bulk</b> {}</td></tr>
<tr class="separator:ac9e64daaf1e76d3a08e76838c9f3aa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca0aa23afbd3f71811787934127535"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="namespacebeman_1_1execution.html#a806dab6de1ac6ae4ec22419cd4ea1e11">connect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#af3ca0aa23afbd3f71811787934127535">connect</a> {}</td></tr>
<tr class="memdesc:af3ca0aa23afbd3f71811787934127535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object used to connect a sender and a receiver.  <br /></td></tr>
<tr class="separator:af3ca0aa23afbd3f71811787934127535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4966cdd647477ec6958ddafcb60835e7"><td class="memItemLeft" align="right" valign="top"><a id="a4966cdd647477ec6958ddafcb60835e7" name="a4966cdd647477ec6958ddafcb60835e7"></a>
BEMAN_EXECUTION_EXPORT constexpr continues_on_t&#160;</td><td class="memItemRight" valign="bottom"><b>continues_on</b> {}</td></tr>
<tr class="memdesc:a4966cdd647477ec6958ddafcb60835e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object to create a <code>continues_on</code> sender. <br /></td></tr>
<tr class="separator:a4966cdd647477ec6958ddafcb60835e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b67aef1ed702a42f470540aedbbfc4"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="namespacebeman_1_1execution.html#a26102229c0893bcb416cb2acb6b9fed6">forwarding_query_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#ad1b67aef1ed702a42f470540aedbbfc4">forwarding_query</a> {}</td></tr>
<tr class="memdesc:ad1b67aef1ed702a42f470540aedbbfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The customization point object to determine whether queries should be forwarded.  <br /></td></tr>
<tr class="separator:ad1b67aef1ed702a42f470540aedbbfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc885f903cbca2ebaddc0f2a49ff205f"><td class="memItemLeft" align="right" valign="top"><a id="acc885f903cbca2ebaddc0f2a49ff205f" name="acc885f903cbca2ebaddc0f2a49ff205f"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__allocator__t.html">get_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> {}</td></tr>
<tr class="separator:acc885f903cbca2ebaddc0f2a49ff205f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8ae50ee016a2ddf01047ee4843105"><td class="memTemplParams" colspan="2"><a id="a5cd8ae50ee016a2ddf01047ee4843105" name="a5cd8ae50ee016a2ddf01047ee4843105"></a>
template&lt;::beman::execution::detail::completion_tag Tag&gt; </td></tr>
<tr class="memitem:a5cd8ae50ee016a2ddf01047ee4843105"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__completion__scheduler__t.html">get_completion_scheduler_t</a>&lt; Tag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_completion_scheduler</b> {}</td></tr>
<tr class="separator:a5cd8ae50ee016a2ddf01047ee4843105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5e6746255178e7f9b0baf72d9dce93"><td class="memItemLeft" align="right" valign="top"><a id="a0c5e6746255178e7f9b0baf72d9dce93" name="a0c5e6746255178e7f9b0baf72d9dce93"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__completion__signatures__t.html">get_completion_signatures_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_completion_signatures</b> {}</td></tr>
<tr class="separator:a0c5e6746255178e7f9b0baf72d9dce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae733e5658fbe0878a039faef0e8a2f80"><td class="memItemLeft" align="right" valign="top"><a id="ae733e5658fbe0878a039faef0e8a2f80" name="ae733e5658fbe0878a039faef0e8a2f80"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__delegation__scheduler__t.html">get_delegation_scheduler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_delegation_scheduler</b> {}</td></tr>
<tr class="separator:ae733e5658fbe0878a039faef0e8a2f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af229b5edd598c99ab1663117854c4492"><td class="memItemLeft" align="right" valign="top"><a id="af229b5edd598c99ab1663117854c4492" name="af229b5edd598c99ab1663117854c4492"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__domain__t.html">get_domain_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_domain</b> {}</td></tr>
<tr class="separator:af229b5edd598c99ab1663117854c4492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab876d683f84d3400bc99d4360b17811f"><td class="memItemLeft" align="right" valign="top"><a id="ab876d683f84d3400bc99d4360b17811f" name="ab876d683f84d3400bc99d4360b17811f"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__env__t.html">get_env_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_env</b> {}</td></tr>
<tr class="separator:ab876d683f84d3400bc99d4360b17811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec3b0dd7cc25ceb437428727aeb608"><td class="memItemLeft" align="right" valign="top"><a id="a12ec3b0dd7cc25ceb437428727aeb608" name="a12ec3b0dd7cc25ceb437428727aeb608"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__scheduler__t.html">get_scheduler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_scheduler</b> {}</td></tr>
<tr class="separator:a12ec3b0dd7cc25ceb437428727aeb608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9a0346738eff0aedbe9c237be32866"><td class="memItemLeft" align="right" valign="top"><a id="a7c9a0346738eff0aedbe9c237be32866" name="a7c9a0346738eff0aedbe9c237be32866"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1get__stop__token__t.html">get_stop_token_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_stop_token</b> {}</td></tr>
<tr class="separator:a7c9a0346738eff0aedbe9c237be32866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a85b58f88fd2f2115fd982102d3f23"><td class="memItemLeft" align="right" valign="top"><a id="af2a85b58f88fd2f2115fd982102d3f23" name="af2a85b58f88fd2f2115fd982102d3f23"></a>
BEMAN_EXECUTION_EXPORT constexpr into_variant_t&#160;</td><td class="memItemRight" valign="bottom"><b>into_variant</b> {}</td></tr>
<tr class="separator:af2a85b58f88fd2f2115fd982102d3f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a95402660a39f0f4737aa2444e0993"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a86a95402660a39f0f4737aa2444e0993">just</a> {}</td></tr>
<tr class="memdesc:a86a95402660a39f0f4737aa2444e0993"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>just(<em>arg</em>...)</code> yields a sender completing with <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>Arg</em>...)</code>  <br /></td></tr>
<tr class="separator:a86a95402660a39f0f4737aa2444e0993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468f3a132f894094d260c2b1323d5697"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a468f3a132f894094d260c2b1323d5697">just_error</a> {}</td></tr>
<tr class="memdesc:a468f3a132f894094d260c2b1323d5697"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>just_error(<em>error</em>)</code> yields a sender completing with <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>Error</em>)</code>  <br /></td></tr>
<tr class="separator:a468f3a132f894094d260c2b1323d5697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10ebe3835c37046ca5df1a61f25e79a"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_stopped_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a">just_stopped</a> {}</td></tr>
<tr class="memdesc:ab10ebe3835c37046ca5df1a61f25e79a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">just_stopped()</a></code> yields a sender completing with <code>set_stopped_t()</code>  <br /></td></tr>
<tr class="separator:ab10ebe3835c37046ca5df1a61f25e79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888870d663c43d800d4d3a8f5f163a4e"><td class="memItemLeft" align="right" valign="top"><a id="a888870d663c43d800d4d3a8f5f163a4e" name="a888870d663c43d800d4d3a8f5f163a4e"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::let_error_t&#160;</td><td class="memItemRight" valign="bottom"><b>let_error</b> {}</td></tr>
<tr class="separator:a888870d663c43d800d4d3a8f5f163a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f664f72441e393f9d7d3fe2fdf068"><td class="memItemLeft" align="right" valign="top"><a id="a2d8f664f72441e393f9d7d3fe2fdf068" name="a2d8f664f72441e393f9d7d3fe2fdf068"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::let_stopped_t&#160;</td><td class="memItemRight" valign="bottom"><b>let_stopped</b> {}</td></tr>
<tr class="separator:a2d8f664f72441e393f9d7d3fe2fdf068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a45b772dde017499566bce4368fefdf"><td class="memItemLeft" align="right" valign="top"><a id="a7a45b772dde017499566bce4368fefdf" name="a7a45b772dde017499566bce4368fefdf"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::let_value_t&#160;</td><td class="memItemRight" valign="bottom"><b>let_value</b> {}</td></tr>
<tr class="separator:a7a45b772dde017499566bce4368fefdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38bb7a3cd72fe3f4540e64507944797"><td class="memItemLeft" align="right" valign="top"><a id="af38bb7a3cd72fe3f4540e64507944797" name="af38bb7a3cd72fe3f4540e64507944797"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1nostopstate__t.html">nostopstate_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nostopstate</b> {}</td></tr>
<tr class="separator:af38bb7a3cd72fe3f4540e64507944797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa427aa7ab4d2e7358f080a0c170dd321"><td class="memItemLeft" align="right" valign="top"><a id="aa427aa7ab4d2e7358f080a0c170dd321" name="aa427aa7ab4d2e7358f080a0c170dd321"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::on_t&#160;</td><td class="memItemRight" valign="bottom"><b>on</b> {}</td></tr>
<tr class="separator:aa427aa7ab4d2e7358f080a0c170dd321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ef5ecac374eddf5a694dc91ba4f43d"><td class="memItemLeft" align="right" valign="top"><a id="a70ef5ecac374eddf5a694dc91ba4f43d" name="a70ef5ecac374eddf5a694dc91ba4f43d"></a>
BEMAN_EXECUTION_EXPORT constexpr read_env_t&#160;</td><td class="memItemRight" valign="bottom"><b>read_env</b> {}</td></tr>
<tr class="separator:a70ef5ecac374eddf5a694dc91ba4f43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc950542fc6283cbae8bd0240688e89c"><td class="memItemLeft" align="right" valign="top"><a id="abc950542fc6283cbae8bd0240688e89c" name="abc950542fc6283cbae8bd0240688e89c"></a>
BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="structbeman_1_1execution_1_1schedule__t.html">::beman::execution::schedule_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>schedule</b> {}</td></tr>
<tr class="separator:abc950542fc6283cbae8bd0240688e89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8771072e39df58c69230c080db226a3b"><td class="memItemLeft" align="right" valign="top"><a id="a8771072e39df58c69230c080db226a3b" name="a8771072e39df58c69230c080db226a3b"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::schedule_from_t&#160;</td><td class="memItemRight" valign="bottom"><b>schedule_from</b> {}</td></tr>
<tr class="separator:a8771072e39df58c69230c080db226a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac772aa91cf0ba688732aefc4575ab59e"><td class="memTemplParams" colspan="2">template&lt;typename Sender , typename Env  = ::beman::execution::env&lt;&gt;&gt; </td></tr>
<tr class="memitem:ac772aa91cf0ba688732aefc4575ab59e"><td class="memTemplItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORT requires ::beman::execution::sender_in&lt; Sender, Env &gt; constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#ac772aa91cf0ba688732aefc4575ab59e">sends_stopped</a></td></tr>
<tr class="separator:ac772aa91cf0ba688732aefc4575ab59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e16f19c0b4ba21ee43d1c23e0f1cff3"><td class="memItemLeft" align="right" valign="top"><a id="a9e16f19c0b4ba21ee43d1c23e0f1cff3" name="a9e16f19c0b4ba21ee43d1c23e0f1cff3"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1set__error__t.html">set_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_error</b> {}</td></tr>
<tr class="memdesc:a9e16f19c0b4ba21ee43d1c23e0f1cff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for error completions. <br /></td></tr>
<tr class="separator:a9e16f19c0b4ba21ee43d1c23e0f1cff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8244f7fb2c9f716d9602e260a8d91c4c"><td class="memItemLeft" align="right" valign="top"><a id="a8244f7fb2c9f716d9602e260a8d91c4c" name="a8244f7fb2c9f716d9602e260a8d91c4c"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1set__stopped__t.html">set_stopped_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_stopped</b> {}</td></tr>
<tr class="memdesc:a8244f7fb2c9f716d9602e260a8d91c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for cancellation completions. <br /></td></tr>
<tr class="separator:a8244f7fb2c9f716d9602e260a8d91c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ba134b297e5c0b06590a57ae9d5dfe"><td class="memItemLeft" align="right" valign="top"><a id="a88ba134b297e5c0b06590a57ae9d5dfe" name="a88ba134b297e5c0b06590a57ae9d5dfe"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1set__value__t.html">set_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> {}</td></tr>
<tr class="memdesc:a88ba134b297e5c0b06590a57ae9d5dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customization point object for successful completions. <br /></td></tr>
<tr class="separator:a88ba134b297e5c0b06590a57ae9d5dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74725cbe37ab55f960ab59b192aaa642"><td class="memItemLeft" align="right" valign="top"><a id="a74725cbe37ab55f960ab59b192aaa642" name="a74725cbe37ab55f960ab59b192aaa642"></a>
BEMAN_EXECUTION_EXPORT constexpr spawn_t&#160;</td><td class="memItemRight" valign="bottom"><b>spawn</b> {}</td></tr>
<tr class="separator:a74725cbe37ab55f960ab59b192aaa642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b838ef7ac462b42c3392b9855dabd"><td class="memItemLeft" align="right" valign="top"><a id="a219b838ef7ac462b42c3392b9855dabd" name="a219b838ef7ac462b42c3392b9855dabd"></a>
BEMAN_EXECUTION_EXPORT constexpr spawn_future_t&#160;</td><td class="memItemRight" valign="bottom"><b>spawn_future</b> {}</td></tr>
<tr class="separator:a219b838ef7ac462b42c3392b9855dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae108e7a9cb18d0c2e00d6f20878f91e1"><td class="memItemLeft" align="right" valign="top"><a id="ae108e7a9cb18d0c2e00d6f20878f91e1" name="ae108e7a9cb18d0c2e00d6f20878f91e1"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::split_t&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> {}</td></tr>
<tr class="separator:ae108e7a9cb18d0c2e00d6f20878f91e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515310ec9c2384a48057ab0623ef5d8"><td class="memItemLeft" align="right" valign="top"><a id="a8515310ec9c2384a48057ab0623ef5d8" name="a8515310ec9c2384a48057ab0623ef5d8"></a>
BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="structbeman_1_1execution_1_1start__t.html">start_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>start</b> {}</td></tr>
<tr class="separator:a8515310ec9c2384a48057ab0623ef5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33bc8fbd5a7462967eab19fe8b408de"><td class="memItemLeft" align="right" valign="top"><a id="ad33bc8fbd5a7462967eab19fe8b408de" name="ad33bc8fbd5a7462967eab19fe8b408de"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::detail::starts_on_t&#160;</td><td class="memItemRight" valign="bottom"><b>starts_on</b> {}</td></tr>
<tr class="separator:ad33bc8fbd5a7462967eab19fe8b408de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7b4c1bdad6f6f4ea09c03de8e89a51"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::sync_wait_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51">sync_wait</a> {}</td></tr>
<tr class="memdesc:a4c7b4c1bdad6f6f4ea09c03de8e89a51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>sync_wait(<em>sender</em>)</code> starts <code><em>sender</em></code> and waits for its completion.  <br /></td></tr>
<tr class="separator:a4c7b4c1bdad6f6f4ea09c03de8e89a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42194e9663efb60f2ed04d4a16641247"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a4d128b0eb18329ca6d9dff7068eaf865">::beman::execution::then_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a42194e9663efb60f2ed04d4a16641247">then</a> {}</td></tr>
<tr class="memdesc:a42194e9663efb60f2ed04d4a16641247"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>then(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> completion  <br /></td></tr>
<tr class="separator:a42194e9663efb60f2ed04d4a16641247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b66c91515401c3c5a8ebc0157f819f1"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a5edc31fa03580fefdec5ff9de774cd7b">::beman::execution::upon_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a6b66c91515401c3c5a8ebc0157f819f1">upon_error</a> {}</td></tr>
<tr class="memdesc:a6b66c91515401c3c5a8ebc0157f819f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>upon_error(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>E</em>)</code> completion  <br /></td></tr>
<tr class="separator:a6b66c91515401c3c5a8ebc0157f819f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c28706c08a5f4ee9c2fb2996a4670"><td class="memItemLeft" align="right" valign="top">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a724b0f844f19033a9aff2385c0c2532d">::beman::execution::upon_stopped_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebeman_1_1execution.html#a103c28706c08a5f4ee9c2fb2996a4670">upon_stopped</a> {}</td></tr>
<tr class="memdesc:a103c28706c08a5f4ee9c2fb2996a4670"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>upon_stopped(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code>set_stopped_t()</code> completion  <br /></td></tr>
<tr class="separator:a103c28706c08a5f4ee9c2fb2996a4670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595be9a1d273c7edc3156506b87a1d86"><td class="memItemLeft" align="right" valign="top"><a id="a595be9a1d273c7edc3156506b87a1d86" name="a595be9a1d273c7edc3156506b87a1d86"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::when_all_t&#160;</td><td class="memItemRight" valign="bottom"><b>when_all</b> {}</td></tr>
<tr class="separator:a595be9a1d273c7edc3156506b87a1d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82abc302fefcaf57715c5e717bd4af21"><td class="memItemLeft" align="right" valign="top"><a id="a82abc302fefcaf57715c5e717bd4af21" name="a82abc302fefcaf57715c5e717bd4af21"></a>
BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::when_all_with_variant_t&#160;</td><td class="memItemRight" valign="bottom"><b>when_all_with_variant</b> {}</td></tr>
<tr class="separator:a82abc302fefcaf57715c5e717bd4af21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ed4202cf4050791dbc46bbbd33e5a0"><td class="memItemLeft" align="right" valign="top"><a id="ac2ed4202cf4050791dbc46bbbd33e5a0" name="ac2ed4202cf4050791dbc46bbbd33e5a0"></a>
BEMAN_EXECUTION_EXPORT constexpr write_env_t&#160;</td><td class="memItemRight" valign="bottom"><b>write_env</b> {}</td></tr>
<tr class="separator:ac2ed4202cf4050791dbc46bbbd33e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6606229cea8cab1a5097791d50cc9"><td class="memItemLeft" align="right" valign="top"><a id="a96e6606229cea8cab1a5097791d50cc9" name="a96e6606229cea8cab1a5097791d50cc9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>version</b> {000}</td></tr>
<tr class="separator:a96e6606229cea8cab1a5097791d50cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for asynchronous operations and their vocabulary. </p>
<p>The <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a> namespace contains various components for accessing asynchronous operations. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="af3ca0aa23afbd3f71811787934127535" name="af3ca0aa23afbd3f71811787934127535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca0aa23afbd3f71811787934127535">&#9670;&#160;</a></span>connect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="namespacebeman_1_1execution.html#a806dab6de1ac6ae4ec22419cd4ea1e11">connect_t</a> beman::execution::connect {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Customization point object used to connect a sender and a receiver. </p>
<p><code><a class="el" href="namespacebeman_1_1execution.html#af3ca0aa23afbd3f71811787934127535" title="Customization point object used to connect a sender and a receiver.">connect(sender, receiver)</a></code> returns the result of calling <code>sender.connect(receiver)</code>. The returned object <code>state</code> is an <code>operation_state</code> object. </p>

</div>
</div>
<a id="ad1b67aef1ed702a42f470540aedbbfc4" name="ad1b67aef1ed702a42f470540aedbbfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b67aef1ed702a42f470540aedbbfc4">&#9670;&#160;</a></span>forwarding_query</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORT constexpr <a class="el" href="namespacebeman_1_1execution.html#a26102229c0893bcb416cb2acb6b9fed6">forwarding_query_t</a> beman::execution::forwarding_query {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The customization point object to determine whether queries should be forwarded. </p>
<p>The <code>constexpr</code> call <code><a class="el" href="namespacebeman_1_1execution.html#ad1b67aef1ed702a42f470540aedbbfc4" title="The customization point object to determine whether queries should be forwarded.">forwarding_query(q)</a></code> determines whether the query <code>q</code> passed as argument should be forwarded. The result is determined as follows:</p>
<ul>
<li>If the <code>q.query(forwarding_query)</code> is a <code>noexcept</code> expression of type <code>bool</code> the result of this call.</li>
<li>If the type of <code>q</code> is derived from <code>forwarding_query_t</code>.</li>
<li><code>false</code> otherwise. </li>
</ul>

</div>
</div>
<a id="a86a95402660a39f0f4737aa2444e0993" name="a86a95402660a39f0f4737aa2444e0993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a95402660a39f0f4737aa2444e0993">&#9670;&#160;</a></span>just</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_t beman::execution::just {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>just(<em>arg</em>...)</code> yields a sender completing with <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>Arg</em>...)</code> </p>
<p><code>just</code> is a callable object of type <code>just_t</code>. Invoking <code>just(<em>arg</em>...)</code> yields a sender which stores its arguments and produces a value completion with these arguments when started. This sender completes synchronously when started.</p>
<h4>Usage</h4>
<pre>
just(<em>arg</em>...)
</pre><p>Above <code><em>Arg</em>...</code> is a pack of the types of <code><em>arg</em>...</code> after removing top-level <code>const</code> and reference qualifications (<code>std::remove_cvref_t&lt;decltype(<em>arg</em>)&gt;...</code>).</p>
<h4>Completions Signatures</h4>
<pre>
<a class="el" href="structbeman_1_1execution_1_1completion__signatures.html" title="Class template used to a specify a list of completion signatures.">completion_signatures</a>&lt;
    <a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>Arg</em>...)
&gt;;
</pre><h4>Example</h4>
<p>The normal use of <code>just(<em>args</em>...)</code> is as the starting point of a work graph. Various other examples will use <code>just</code> as their starting. The example below create a sender yielding three values and awaits the completion using <code>sync_wait(<em>sender</em>)</code>: for a value completion of <code><em>sender</em></code> it will yield an <code>std::optional&lt;std::tuple&lt;<em>Args</em>...&gt;&gt;</code> with the <code>tuple</code> containing the value copied/moved from the original arguments (an <code>optional</code> is returned to indicate cancellation).</p>
<pre example="doc-just.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
using namespace std::string_literals;

int main() {
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#a86a95402660a39f0f4737aa2444e0993" title="just(arg...) yields a sender completing with set_value_t(Arg...)">ex::just</a>(17, "hello"s, true));
    assert(result);
    assert(*result == std::tuple(17, "hello"s, true));
}
</pre> 
</div>
</div>
<a id="a468f3a132f894094d260c2b1323d5697" name="a468f3a132f894094d260c2b1323d5697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468f3a132f894094d260c2b1323d5697">&#9670;&#160;</a></span>just_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_error_t beman::execution::just_error {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>just_error(<em>error</em>)</code> yields a sender completing with <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>Error</em>)</code> </p>
<p><code>just_error</code> is a callable object of type <code>just_error_t</code>. Invoking <code>just_error(<em>error</em>)</code> yields a sender which stores its argument and produces an error completion with this error when started. This sender completes synchronously when started.</p>
<h4>Usage</h4>
<pre>
just_error(<em>error</em>)
</pre><p>The type <code><em>Error</em></code> used above is the type of <code><em>error</em></code> after removing top-level <code>const</code> and reference qualifications (<code>std::remove_cvref_t&lt;decltype(error)&gt;</code>).</p>
<h4>Completions Signatures</h4>
<pre>
<a class="el" href="structbeman_1_1execution_1_1completion__signatures.html" title="Class template used to a specify a list of completion signatures.">completion_signatures</a>&lt;
    <a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>Error</em>)
&gt;;
</pre><h4>Example</h4>
<p>The normal use of <code>just_error(<em>error</em>)</code> is to report an error as the result of some work in a work graph. It would, e.g., be used as the completion produced by <code>let_value</code>. The example below creates a sender yielding an <code>std::error_code</code> on the error channel and uses that as the input for <code>upon_error</code> consuming the error and producing a value completion: using <code>sync_wait(just_error(<em>error</em>))</code> directly doesn't work because <code>sync_wait</code> requires exactly one value completion from its argument and <code>set_error</code> only has an error completion. The function used with <code>upon_error</code> verifies that the expected code was produced and also sets the flag <code>had_error</code> indicating it was called at all. This flag is checked after waiting for the result in <code>sync_wait</code>.</p>
<pre example="doc-just_error.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;system_error&gt;
#include &lt;cassert&gt;
namespace ex = <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a>;

int main() {
    bool had_error{false};
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#a468f3a132f894094d260c2b1323d5697" title="just_error(error) yields a sender completing with set_error_t(Error)">ex::just_error</a>(std::error_code(17, std::system_category())) |
                                <a class="el" href="namespacebeman_1_1execution.html#a6b66c91515401c3c5a8ebc0157f819f1" title="upon_error(sender, fun) yields a sender transforming a set_error_t(E) completion">ex::upon_error</a>([&amp;](std::error_code ec) {
                                    assert(ec.value() == 17);
                                    had_error = true;
                                }));
    assert(had_error);
}
</pre> 
</div>
</div>
<a id="ab10ebe3835c37046ca5df1a61f25e79a" name="ab10ebe3835c37046ca5df1a61f25e79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10ebe3835c37046ca5df1a61f25e79a">&#9670;&#160;</a></span>just_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::just_stopped_t beman::execution::just_stopped {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code><a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">just_stopped()</a></code> yields a sender completing with <code>set_stopped_t()</code> </p>
<p><code>just_stopped</code> is a callable object of type <code>just_stopped_t</code>. Invoking <code><a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">just_stopped()</a></code> yields a sender which produces a cancellation completion when started. This sender completes synchronously when started.</p>
<h4>Usage</h4>
<pre>
<a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">just_stopped()</a>
</pre><h4>Completions Signatures</h4>
<pre>
<a class="el" href="structbeman_1_1execution_1_1completion__signatures.html" title="Class template used to a specify a list of completion signatures.">completion_signatures</a>&lt;
    set_stopped_t()
&gt;;
</pre><h4>Example</h4>
<p>The normal use of <code><a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">just_stopped()</a></code> is to report a cancellation as the result of some work in a work graph. It would, e.g., be used as the completion produced by <code>let_value</code>. The example below creates a sender yielding a completion on the cancellation channel and uses that as the input for <code>upon_stopped</code> consuming the cancellation and producing a value completion: using <code><a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">sync_wait(just_stopped())</a></code> directly doesn't work because <code>sync_wait</code> requires exactly one value completion from its argument and <code>set_stopped</code> only has a cancellation completion. The function used with <code>upon_stopped</code> sets the flag <code>had_stopped</code> indicating it was called at all. This flag is checked after waiting for the result in <code>sync_wait</code>.</p>
<pre example="doc-just_error.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;system_error&gt;
#include &lt;cassert&gt;
namespace ex = <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a>;

int main() {
    bool had_stopped{false};
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#a468f3a132f894094d260c2b1323d5697" title="just_error(error) yields a sender completing with set_error_t(Error)">ex::just_error</a>(std::error_code(17, std::system_category())) |
                                <a class="el" href="namespacebeman_1_1execution.html#a6b66c91515401c3c5a8ebc0157f819f1" title="upon_error(sender, fun) yields a sender transforming a set_error_t(E) completion">ex::upon_error</a>([&amp;](std::error_code ec) {
                                    assert(ec.value() == 17);
                                    had_stopped = true;
                                }));
    assert(had_stopped);
}
</pre> 
</div>
</div>
<a id="ac772aa91cf0ba688732aefc4575ab59e" name="ac772aa91cf0ba688732aefc4575ab59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac772aa91cf0ba688732aefc4575ab59e">&#9670;&#160;</a></span>sends_stopped</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sender , typename Env  = ::beman::execution::env&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORT requires ::beman::execution::sender_in&lt;Sender, Env&gt; constexpr bool beman::execution::sends_stopped</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{!::std::same_as&lt;</div>
<div class="line">    ::beman::execution::detail::type_list&lt;&gt;,</div>
<div class="line">    ::beman::execution::detail::gather_signatures&lt;<a class="code hl_struct" href="structbeman_1_1execution_1_1set__stopped__t.html">::beman::execution::set_stopped_t</a>,</div>
<div class="line">                                                  <a class="code hl_typedef" href="namespacebeman_1_1execution.html#a9f4a6f9a91e53c4387f1f0d6990726c3">::beman::execution::completion_signatures_of_t&lt;Sender, Env&gt;</a>,</div>
<div class="line">                                                  ::beman::execution::detail::type_list,</div>
<div class="line">                                                  ::beman::execution::detail::type_list&gt;&gt;}</div>
<div class="ttc" id="anamespacebeman_1_1execution_html_a9f4a6f9a91e53c4387f1f0d6990726c3"><div class="ttname"><a href="namespacebeman_1_1execution.html#a9f4a6f9a91e53c4387f1f0d6990726c3">beman::execution::completion_signatures_of_t</a></div><div class="ttdeci">::beman::execution::detail::call_result_t&lt;::beman::execution::get_completion_signatures_t, Sender, Env &gt; completion_signatures_of_t</div><div class="ttdoc">Alias to access the completion signatures of a sender.</div><div class="ttdef"><b>Definition:</b> completion_signatures_of_t.hpp:23</div></div>
<div class="ttc" id="astructbeman_1_1execution_1_1set__stopped__t_html"><div class="ttname"><a href="structbeman_1_1execution_1_1set__stopped__t.html">beman::execution::set_stopped_t</a></div><div class="ttdoc">Type of the customization point object for cancellation completions.</div><div class="ttdef"><b>Definition:</b> set_stopped.hpp:19</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c7b4c1bdad6f6f4ea09c03de8e89a51" name="a4c7b4c1bdad6f6f4ea09c03de8e89a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7b4c1bdad6f6f4ea09c03de8e89a51">&#9670;&#160;</a></span>sync_wait</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr ::beman::execution::sync_wait_t beman::execution::sync_wait {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>sync_wait(<em>sender</em>)</code> starts <code><em>sender</em></code> and waits for its completion. </p>
<p><code>sync_wait</code> is a callable object of type <code>sync_wait_t</code>. Invoking <code>sync_wait(<em>sender</em>)</code> starts <code><em>sender</em></code> and waits for its completion. This involves a few steps:</p><ol type="1">
<li>A <code><a class="el" href="classbeman_1_1execution_1_1run__loop.html">run_loop</a></code> is created to provide a scheduler.</li>
<li>The <code><em>sender</em></code> is <code>connect</code>ed to a receiver capturing the results and providing an environment with access to the <code><a class="el" href="classbeman_1_1execution_1_1run__loop.html">run_loop</a></code>'s scheduler.</li>
<li>The operation state returned from <code>connect</code> is <code>start</code>ed.</li>
<li>The <code><a class="el" href="classbeman_1_1execution_1_1run__loop.html">run_loop</a></code> is run to process any work scheduled.</li>
</ol>
<p>Once the <code><em>sender</em></code> completes, the result is provided by <code>sync_wait</code>:</p><ul>
<li>If the <code><em>sender</em></code> completes with <code>set_value(<em>arg</em>...)</code>, <code>sync_wait</code> returns an <code>std::optional&lt;std::tuple&lt;<em>Arg</em>...&gt;&gt;</code> containing the results <code><em>arg</em>...</code>.</li>
<li>If the <code><em>sender</em></code> completes with <code><a class="el" href="namespacebeman_1_1execution.html#a8244f7fb2c9f716d9602e260a8d91c4c" title="Customization point object for cancellation completions.">set_stopped()</a></code>, <code>sync_wait</code> returns a disengaged <code>std::optional&lt;std::tuple&lt;<em>Arg</em>...&gt;&gt;</code>.</li>
<li>If the <code><em>sender</em></code> completes with <code>set_error(<em>error</em>)</code>, <code>sync_wait</code> throw <code><em>error</em></code> or rethrows the exception if <code><em>error</em></code> is an <code>std::exception_ptr</code>.</li>
</ul>
<h4>Usage</h4>
<pre>
sync_wait(<em>sender</em>...)
</pre><h4>Example</h4>
<p>The use of <code>sync_wait(<em>sender</em>)</code> is in <code>main</code> to synchronously wait for the completion of the asynchronous work of the program represented by <code><em>sender</em></code>.</p>
<pre example="doc-sync_wait.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;cassert&gt;

int main() {
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait(ex::just(17))</a>;
    assert(result);
    assert(*result == std::tuple(17));
}
</pre> 
</div>
</div>
<a id="a42194e9663efb60f2ed04d4a16641247" name="a42194e9663efb60f2ed04d4a16641247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42194e9663efb60f2ed04d4a16641247">&#9670;&#160;</a></span>then</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a4d128b0eb18329ca6d9dff7068eaf865">::beman::execution::then_t</a> beman::execution::then {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>then(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> completion </p>
<p><code>then</code> is a callable object of type <code>then_t</code>. Invoking <code>then(<em>sender</em>, <em>fun</em>)</code> or <code><em>sender</em> | then(<em>fun</em>)</code> yields a sender which, when <code>start</code>ed starts <code><em>sender</em></code> and awaits its completion. When <code><em>sender</em></code> completes <code>then</code> proceeds according to this completion:</p><ul>
<li>If the completion is <code>set_value(<em>a</em>...)</code>, <code><em>fun</em>(<em>a</em>...)</code> is invoked:<ul>
<li>if that invocation throws, <code>then</code> completes with <code>set_error(<em>r</em>, std::current_exception())</code>; otherwise</li>
<li>if the invocation returns <code>void</code>, <code>then</code> completes with <code>set_value(<em>r</em>)</code>; otherwise</li>
<li>if the invocation returns <code><em>v</em></code>, <code>then</code> completes with <code>set_value(<em>r</em>, <em>v</em>)</code>.</li>
</ul>
</li>
<li>Otherwise, if the completion is <code>set_error(<em>e</em>)</code>, <code>then</code> completes with <code>set_error(<em>r</em>, <em>e</em>)</code></li>
<li>Otherwise, if the completion is <code><a class="el" href="namespacebeman_1_1execution.html#a8244f7fb2c9f716d9602e260a8d91c4c" title="Customization point object for cancellation completions.">set_stopped()</a></code>, <code>then</code> completes with <code>set_stopped(<em>r</em>)</code>.</li>
</ul>
<h4>Usage</h4>
<pre>
then(<em>sender</em>, <em>fun</em>)
<em>sender</em> | then(<em>fun</em>)
</pre><h4>Completions Signatures</h4>
<p>The completion signatures depends on the completion signatures <code><em>CS</em></code> of <code><em>sender</em></code> (the completion signatures will be deduplicated):</p><ul>
<li>For each <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> in <code><em>CS</em></code>, there is a completion signature <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(decltype(<em>fun</em>(std::declval&lt;<em>A</em>&gt;()...)))</code>.</li>
<li>If for any of the <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> in <code><em>CS</em></code> the expression <code>noexcept(<em>fun</em>(std::declval&lt;<em>A</em>&gt;()...))</code> is <code>false</code> there is a completion signature <code>set_error_t(std::exception_ptr)</code>.</li>
<li>Each <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>Error</em>)</code> in <code><em>CS</em></code> is copied.</li>
<li>If <code>set_stopped_t()</code> is in <code><em>CS</em></code> it is copied.</li>
</ul>
<h4>Example</h4>
<pre example="doc-then.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;cassert&gt;
namespace ex = <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a>;

int main() {
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#a86a95402660a39f0f4737aa2444e0993" title="just(arg...) yields a sender completing with set_value_t(Arg...)">ex::just(10)</a> | <a class="el" href="namespacebeman_1_1execution.html#a42194e9663efb60f2ed04d4a16641247" title="then(sender, fun) yields a sender transforming a set_value_t(A...) completion">ex::then</a>([](int v) { return v == 3; }));
    assert(result);
    assert(*result == std::tuple(false));
}
</pre> 
</div>
</div>
<a id="a6b66c91515401c3c5a8ebc0157f819f1" name="a6b66c91515401c3c5a8ebc0157f819f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b66c91515401c3c5a8ebc0157f819f1">&#9670;&#160;</a></span>upon_error</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a5edc31fa03580fefdec5ff9de774cd7b">::beman::execution::upon_error_t</a> beman::execution::upon_error {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>upon_error(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>E</em>)</code> completion </p>
<p><code>upon_error</code> is a callable object of type <code>upon_error_t</code>. Invoking <code>upon_error(<em>sender</em>, <em>fun</em>)</code> or <code><em>sender</em> | upon_error(<em>fun</em>)</code> yields a sender which, when <code>start</code>ed starts <code><em>sender</em></code> and awaits its completion. When <code><em>sender</em></code> completes <code>upon_error</code> proceeds according to this completion:</p><ul>
<li>If the completion is <code>set_error(<em>e</em>)</code>, <code><em>fun</em>(<em>e</em>)</code> is invoked:<ul>
<li>if that invocation throws, <code>upon_error</code> completes with <code>set_error(<em>r</em>, std::current_exception())</code>; otherwise</li>
<li>if the invocation returns <code>void</code>, <code>upon_error</code> completes with <code>set_value(<em>r</em>)</code>; otherwise</li>
<li>if the invocation returns <code><em>v</em></code>, <code>upon_error</code> completes with <code>set_value(<em>r</em>, <em>v</em>)</code>.</li>
</ul>
</li>
<li>Otherwise, if the completion is <code>set_value(<em>a</em>...)</code>, <code>upon_error</code> completes with <code>set_value(<em>r</em>, <em>a</em>...)</code></li>
<li>Otherwise, if the completion is <code><a class="el" href="namespacebeman_1_1execution.html#a8244f7fb2c9f716d9602e260a8d91c4c" title="Customization point object for cancellation completions.">set_stopped()</a></code>, <code>upon_error</code> completes with <code>set_stopped(<em>r</em>)</code>.</li>
</ul>
<h4>Usage</h4>
<pre>
upon_error(<em>sender</em>, <em>fun</em>)
<em>sender</em> | upon_error(<em>fun</em>)
</pre><h4>Completions Signatures</h4>
<p>The completion signatures depend on the completion signatures <code><em>CS</em></code> of <code><em>sender</em></code> (the completion signatures will be deduplicated):</p><ul>
<li>For each <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>E</em>)</code> in <code><em>CS</em></code>, there is a completion signature <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(decltype(<em>fun</em>(std::declval&lt;<em>E</em>&gt;())))</code>.</li>
<li>If for any of the <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>E</em>)</code> in <code><em>CS</em></code> the expression <code>noexcept(<em>fun</em>(<em>std::declval&lt;E&gt;()</em>))</code> is <code>false</code> there is a completion signature <code>set_error_t(std::exception_ptr)</code>.</li>
<li>Each <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> in <code><em>CS</em></code> is copied.</li>
<li>If <code>set_stopped_t()</code> is in <code><em>CS</em></code> it is copied.</li>
</ul>
<h4>Example</h4>
<pre example="doc-upon_error.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;cassert&gt;
namespace ex = <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a>;

int main() {
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#a468f3a132f894094d260c2b1323d5697" title="just_error(error) yields a sender completing with set_error_t(Error)">ex::just_error(10)</a> | <a class="el" href="namespacebeman_1_1execution.html#a6b66c91515401c3c5a8ebc0157f819f1" title="upon_error(sender, fun) yields a sender transforming a set_error_t(E) completion">ex::upon_error</a>([](int v) { return v == 3; }));
    assert(result);
    assert(*result == std::tuple(false));
}
</pre> 
</div>
</div>
<a id="a103c28706c08a5f4ee9c2fb2996a4670" name="a103c28706c08a5f4ee9c2fb2996a4670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103c28706c08a5f4ee9c2fb2996a4670">&#9670;&#160;</a></span>upon_stopped</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BEMAN_EXECUTION_EXPORTconstexpr <a class="el" href="namespacebeman_1_1execution.html#a724b0f844f19033a9aff2385c0c2532d">::beman::execution::upon_stopped_t</a> beman::execution::upon_stopped {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>upon_stopped(<em>sender</em>, <em>fun</em>)</code> yields a sender transforming a <code>set_stopped_t()</code> completion </p>
<p><code>upon_stopped</code> is a callable object of type <code>upon_stopped_t</code>. Invoking <code>upon_stopped(<em>sender</em>, <em>fun</em>)</code> or <code><em>sender</em> | upon_stopped(<em>fun</em>)</code> yields a sender which, when <code>start</code>ed starts <code><em>sender</em></code> and awaits its completion. When <code><em>sender</em></code> completes <code>upon_stopped</code> proceeds according to this completion:</p><ul>
<li>If the completion is <code>set_stopped(<em>e</em>)</code>, <code><em>fun</em>(<em>e</em>)</code> is invoked:<ul>
<li>if that invocation throws, <code>upon_stopped</code> completes with <code>set_error(<em>r</em>, std::current_exception())</code>; otherwise</li>
<li>if the invocation returns <code>void</code>, <code>upon_stopped</code> completes with <code>set_value(<em>r</em>)</code>; otherwise</li>
<li>if the invocation returns <code><em>v</em></code>, <code>upon_stopped</code> completes with <code>set_value(<em>r</em>, <em>v</em>)</code>.</li>
</ul>
</li>
<li>Otherwise, if the completion is <code>set_value(<em>a</em>...)</code>, <code>upon_stopped</code> completes with <code>set_value(<em>r</em>, <em>a</em>...)</code></li>
<li>Otherwise, if the completion is <code>set_error(<em>e</em>)</code>, <code>upon_stopped</code> completes with <code>set_error(<em>r</em>, <em>e</em>)</code>.</li>
</ul>
<h4>Usage</h4>
<pre>
upon_stopped(<em>sender</em>, <em>fun</em>)
<em>sender</em> | upon_stopped(<em>fun</em>)
</pre><h4>Completions Signatures</h4>
<p>The completion signatures depend on the completion signatures <code><em>CS</em></code> of <code><em>sender</em></code> (the completion signatures will be deduplicated):</p><ul>
<li>There is a completion signature <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(decltype(<em>fun</em>()))</code>.</li>
<li>If the expression <code>noexcept(<em>fun</em>())</code> is <code>false</code> there is a completion signature <code>set_error_t(std::exception_ptr)</code>.</li>
<li>Each <code><a class="el" href="structbeman_1_1execution_1_1set__value__t.html" title="Type of the customization point object for successful completions.">set_value_t</a>(<em>A</em>...)</code> in <code><em>CS</em></code> is copied.</li>
<li>Each <code><a class="el" href="structbeman_1_1execution_1_1set__error__t.html" title="Type of the customization point object for error completions.">set_error_t</a>(<em>A</em>...)</code> in <code><em>CS</em></code> is copied.</li>
</ul>
<h4>Example</h4>
<pre example="doc-upon_stopped.cpp">
#include &lt;<a class="el" href="execution_2execution_8hpp_source.html">beman/execution/execution.hpp</a>&gt;
#include &lt;cassert&gt;
namespace ex = <a class="el" href="namespacebeman_1_1execution.html" title="Namespace for asynchronous operations and their vocabulary.">beman::execution</a>;

int main() {
    auto result = <a class="el" href="namespacebeman_1_1execution.html#a4c7b4c1bdad6f6f4ea09c03de8e89a51" title="sync_wait(sender) starts sender and waits for its completion.">ex::sync_wait</a>(<a class="el" href="namespacebeman_1_1execution.html#ab10ebe3835c37046ca5df1a61f25e79a" title="just_stopped() yields a sender completing with set_stopped_t()">ex::just_stopped()</a> | <a class="el" href="namespacebeman_1_1execution.html#a103c28706c08a5f4ee9c2fb2996a4670" title="upon_stopped(sender, fun) yields a sender transforming a set_stopped_t() completion">ex::upon_stopped</a>([]() { return true; }));
    assert(result);
    assert(*result == std::tuple(true));
}
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebeman.html">beman</a></li><li class="navelem"><a class="el" href="namespacebeman_1_1execution.html">execution</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
