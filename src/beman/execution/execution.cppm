// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

// *****************************************************;
// *** WARNING: this file is generated: do not edit! ***;
// *****************************************************;
// generated by ./bin/mk-module.py src/beman/execution/execution.cppm

module;

#include <beman/execution/modules_export.hpp>

#include <cassert>

#ifdef BEMAN_HAS_IMPORT_STD
import std;
#else
#include <algorithm>
#include <atomic>
#include <cassert>
#include <concepts>
#include <condition_variable>
#include <coroutine>
#include <cstddef>
#include <cstdlib>
#include <exception>
#include <functional>
#include <memory>
#include <mutex>
#include <optional>
#include <system_error>
#include <thread>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>
#endif

export module beman.execution;

// ----------------------------------------------------------------------------

#ifndef BEMAN_EXECUTION_EXPORT
#define BEMAN_EXECUTION_EXPORT
#endif

#if defined(disabled__cpp_deleted_function)
#define BEMAN_EXECUTION_DELETE(msg) delete (msg)
#else
#define BEMAN_EXECUTION_DELETE(msg) delete
#endif

// ----------------------------------------------------------------------------
/*!
 * \mainpage Asynchronous Operation Support
 *
 * This project implements the C++ support for asynchronous operations,
 * knows as _sender/receiver_ or `std::execution`.
 *
 * There are a few ingredients to using `std::execution`:
 *
 * - Sender algorithms to composes work into an asynchronous workflow.
 * - Something holding and starting senders like `sync_wait()`
 *   or `counting_scope`.
 * - A coroutine binding like `task` to make sender composition
 *   easier for typical use cases.
 * - Some tools like a sender-aware `concurrent_queue`.
 * - Senders describing some asynchronous work. Sadly, there are
 *   currently no such senders are proposed.
 */

/*!
 * \namespace beman
 * \brief Namespace for Beman projects http://github.com/bemanproject/beman
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
namespace beman {
/*!
 * \namespace beman::execution
 * \brief Namespace for asynchronous operations and their vocabulary.
 *
 * \details
 * The beman::execution namespace contains various components for
 * accessing asynchronous operations.
 *
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
namespace execution {

/*!
 * \namespace beman::execution::detail
 * \brief Namespace for implementation details related to beman::execution
 * \internal
 */
namespace detail {}
} // namespace execution
} // namespace beman

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

#if defined(__GNUC__)
#define BEMAN_EXECUTION_DIAGNOSTIC_PUSHED
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-braces"
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif // #if defined(__GNUC__)

#if defined(__clang__)
#define BEMAN_EXECUTION_DIAGNOSTIC_PUSHED
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wmissing-braces"
#pragma clang diagnostic ignored "-Wc++26-extensions"
#endif // #if defined(__clang__)

// ----------------------------------------------------------------------------

#ifdef BEMAN_EXECUTION_DIAGNOSTIC_PUSHED
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif // #if defined(__GNUC__)
#if defined(__clang__)
#pragma clang diagnostic pop
#endif // #if defined(__clang__)
#undef BEMAN_EXECUTION_DIAGNOSTIC_PUSHED
#endif // #ifdef BEMAN_EXECUTION_DIAGNOSTIC_PUSHED

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T>
concept queryable = ::std::destructible<T>;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Actual implementation of the forwarding_query customization point object
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct forwarding_query_t {
    template <typename Object>
        requires requires(Object&& object, const forwarding_query_t& query) {
            { ::std::forward<Object>(object).query(query) } noexcept -> ::std::same_as<bool>;
        }
    constexpr auto operator()(Object&& object) const noexcept -> bool {
        return ::std::forward<Object>(object).query(*this);
    }
    template <typename Object>
    constexpr auto operator()(Object&&) const noexcept -> bool {
        return ::std::derived_from<::std::remove_cvref_t<Object>, ::beman::execution::detail::forwarding_query_t>;
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
/*!
 * \brief Type of the forwarding_query customization point object
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export using forwarding_query_t = beman::execution::detail::forwarding_query_t;
/*!
 * \brief The customization point object to determine whether queries should be forwarded
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * The `constexpr` call `forwarding_query(q)` determines whether the query `q` passed
 * as argument should be forwarded. The result is determined as follows:
 *
 * * If the `q.query(forwarding_query)` is a `noexcept` expression of type `bool` the result of this call.
 * * If the type of `q` is derived from `forwarding_query_t`.
 * * `false` otherwise.
 */
export inline constexpr forwarding_query_t forwarding_query{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T>
concept movable_value =
    ::std::move_constructible<::std::decay_t<T>> && ::std::constructible_from<::std::decay_t<T>, T> &&
    (!::std::is_array_v<::std::remove_reference_t<T>>);
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Fun>
struct matching_sig_transform {
    using type = Fun;
};
template <typename Return, typename... Args>
struct matching_sig_transform<Return(Args...)> {
    using type = Return(Args&&...);
};

template <typename Fun1, typename Fun2>
inline constexpr bool matching_sig =
    ::std::same_as<typename ::beman::execution::detail::matching_sig_transform<Fun1>::type,
                   typename ::beman::execution::detail::matching_sig_transform<Fun2>::type>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Turn an error into a suitable exception_ptr.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Error>
decltype(auto) as_except_ptr(Error&& error) {
    if constexpr (::std::same_as<::std::exception_ptr, ::std::decay_t<Error>>) {
        return ::std::forward<Error>(error);
    } else if constexpr (::std::same_as<::std::error_code, ::std::decay_t<Error>>) {
        return ::std::make_exception_ptr(::std::system_error(error));
    } else {
        return ::std::make_exception_ptr(::std::forward<Error>(error));
    }
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Type of the customization point object for successful completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export struct set_value_t {
    template <typename Receiver, typename... Args>
    auto operator()(Receiver&, Args&&...) const
        -> void = BEMAN_EXECUTION_DELETE("set_value requires the receiver to be passed as non-const rvalue");
    template <typename Receiver, typename... Args>
    auto operator()(const Receiver&&, Args&&...) const
        -> void = BEMAN_EXECUTION_DELETE("set_value requires the receiver to be passed as non-const rvalue");
    template <typename Receiver, typename... Args>
    auto operator()(Receiver&&, Args&&...) const -> void
        requires(not requires(Receiver&& receiver, Args&&... args) {
                    ::std::forward<Receiver>(receiver).set_value(::std::forward<Args>(args)...);
                })
    = BEMAN_EXECUTION_DELETE("set_value requires a suitable member overload on the receiver");
    template <typename Receiver, typename... Args>
        requires(not noexcept(::std::declval<Receiver>().set_value(::std::declval<Args>()...)))
    auto operator()(Receiver&&, Args&&...) const
        -> void = BEMAN_EXECUTION_DELETE("the call to receiver.set_value(args...) has to be noexcept");

    template <typename Receiver, typename... Args>
    auto operator()(Receiver&& receiver, Args&&... args) const noexcept -> void {
        ::std::forward<Receiver>(receiver).set_value(::std::forward<Args>(args)...);
    }
};
/*!
 * \var set_value
 * \brief Customization point object for successful completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export inline constexpr set_value_t set_value{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Type of the customization point object for error completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export struct set_error_t {
    template <typename Receiver, typename Error>
    auto operator()(Receiver&, Error&&) const
        -> void = BEMAN_EXECUTION_DELETE("set_error requires the receiver to be passed as non-const rvalue");
    template <typename Receiver, typename Error>
    auto operator()(const Receiver&&, Error&&) const
        -> void = BEMAN_EXECUTION_DELETE("set_error requires the receiver to be passed as non-const rvalue");
    template <typename Receiver, typename Error>
    auto operator()(Receiver&&, Error&&) const -> void
        requires(not requires(Receiver&& receiver, Error&& error) {
                    ::std::forward<Receiver>(receiver).set_error(::std::forward<Error>(error));
                })
    = BEMAN_EXECUTION_DELETE("set_error requires a suitable member overload on the receiver");
    template <typename Receiver, typename Error>
        requires(not noexcept(::std::declval<Receiver>().set_error(::std::declval<Error>())))
    auto operator()(Receiver&&, Error&&) const
        -> void = BEMAN_EXECUTION_DELETE("the call to receiver.set_error(error) has to be noexcept");

    // NOLINTBEGIN(misc-no-recursion)
    template <typename Receiver, typename Error>
    auto operator()(Receiver&& receiver, Error&& error) const noexcept -> void {
        ::std::forward<Receiver>(receiver).set_error(::std::forward<Error>(error));
    }
    // NOLINTEND(misc-no-recursion)
};

/*!
 * \brief Customization point object for error completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export inline constexpr set_error_t set_error{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Type of the customization point object for cancellation completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export struct set_stopped_t {
    template <typename Receiver>
    auto operator()(Receiver&) const
        -> void = BEMAN_EXECUTION_DELETE("set_stopped requires the receiver to be passed as non-const rvalue");
    template <typename Receiver>
    auto operator()(const Receiver&&) const
        -> void = BEMAN_EXECUTION_DELETE("set_stopped requires the receiver to be passed as non-const rvalue");
    template <typename Receiver>
    auto operator()(Receiver&&) const -> void
        requires(not requires(Receiver&& receiver) { ::std::forward<Receiver>(receiver).set_stopped(); })
    = BEMAN_EXECUTION_DELETE("set_stopped requires a suitable member overload on the receiver");
    template <typename Receiver>
        requires(not noexcept(::std::declval<Receiver>().set_stopped()))
    auto operator()(Receiver&&) const
        -> void = BEMAN_EXECUTION_DELETE("the call to receiver.set_stopped() has to be noexcept");

    template <typename Receiver>
    auto operator()(Receiver&& receiver) const noexcept -> void {
        ::std::forward<Receiver>(receiver).set_stopped();
    }
};

/*!
 * \brief Customization point object for cancellation completions.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export inline constexpr set_stopped_t set_stopped{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct start_t {
    template <typename State>
    auto operator()(State&&) const -> void = BEMAN_EXECUTION_DELETE("start(obj) requires an lvalue argument");
    template <typename State>
        requires(not requires(State& state) { state.start(); })
    auto operator()(State&) const -> void = BEMAN_EXECUTION_DELETE("state needs to have a start() member");
    template <typename State>
        requires(not requires(const State& state) { state.start(); })
    auto operator()(const State&) const -> void = BEMAN_EXECUTION_DELETE("state needs to have a start() member");

    template <typename State>
        requires(not requires(State& state) {
                    { state.start() } noexcept;
                })
    auto operator()(State&) const -> void = BEMAN_EXECUTION_DELETE("state start() member has to be noexcept");
    template <typename State>
        requires(not requires(const State& state) {
                    { state.start() } noexcept;
                })
    auto operator()(const State&) const -> void = BEMAN_EXECUTION_DELETE("state start() member has to be noexcept");

    template <typename State>
    auto operator()(const State& state) const noexcept -> void {
        state.start();
    }
    // NOLINTBEGIN(misc-no-recursion)
    template <typename State>
    auto operator()(State& state) const noexcept -> void {
        state.start();
    }
    // NOLINTEND(misc-no-recursion)
};

export inline constexpr start_t start{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct non_assignable;
}

// ----------------------------------------------------------------------------

struct beman::execution::detail::non_assignable {
    non_assignable()                                         = default;
    non_assignable(non_assignable&&)                         = default;
    non_assignable(const non_assignable&)                    = default;
    auto operator=(non_assignable&&) -> non_assignable&      = delete;
    auto operator=(const non_assignable&) -> non_assignable& = delete;
};

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Alloc>
concept simple_allocator =
    requires(::std::remove_cvref_t<Alloc> alloc, ::std::size_t n) {
        { *alloc.allocate(n) } -> ::std::same_as<typename ::std::remove_cvref_t<Alloc>::value_type&>;
        alloc.deallocate(alloc.allocate(n), n);
    } && ::std::copy_constructible<::std::remove_cvref_t<Alloc>> &&
    ::std::equality_comparable<::std::remove_cvref_t<Alloc>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export class never_stop_token;
}

// ----------------------------------------------------------------------------

class beman::execution::never_stop_token {
    struct private_callback_type {
        explicit private_callback_type(never_stop_token, auto&&) noexcept {}
    };

  public:
    template <typename>
    using callback_type = private_callback_type;

    static constexpr auto stop_requested() noexcept -> bool { return {}; }
    static constexpr auto stop_possible() noexcept -> bool { return {}; }
    auto                  operator==(const never_stop_token&) const -> bool = default;
};

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
//-dk:TODO thoroughly test the concept
/*!
 * \brief Helper concept to determine if the result of decaying two types results in the same type
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T0, typename T1>
concept decayed_same_as = ::std::same_as<::std::remove_cvref_t<T0>, ::std::remove_cvref_t<T1>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Concept used to detect callable objects.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \concept callable
 * \internal
 */
template <typename Fun, typename... Args>
concept callable = requires(Fun&& fun, Args&&... args) { ::std::forward<Fun>(fun)(::std::forward<Args>(args)...); };
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// std::forward_like() doesn't work on some compilers, yet. This header
// provides a work-around.

namespace beman::execution::detail {
template <typename>
struct forward_like_helper;

template <typename T>
struct forward_like_helper {
    template <typename U>
    static auto forward(U&& u) -> ::std::remove_reference_t<U>&& {
        return ::std::move(u); // NOLINT(bugprone-move-forwarding-reference)
    }
};
template <typename T>
struct forward_like_helper<T&&> {
    template <typename U>
    static auto forward(U&& u) -> ::std::remove_cvref_t<U>&& {
        return ::std::move(u); // NOLINT(bugprone-move-forwarding-reference)
    }
};
template <typename T>
struct forward_like_helper<T&> {
    template <typename U>
    static auto forward(U&& u) -> ::std::remove_cvref_t<U>& {
        return ::std::forward<U&&>(u);
    }
};
template <typename T>
struct forward_like_helper<const T&&> {
    template <typename U>
    static auto forward(U&& u) -> const ::std::remove_cvref_t<U>&& {
        return ::std::move(u); // NOLINT(bugprone-move-forwarding-reference)
    }
};
template <typename T>
struct forward_like_helper<const T&> {
    template <typename U>
    static auto forward(U&& u) -> const ::std::remove_cvref_t<U>& {
        return ::std::forward<U&&>(u);
    }
};

// The overload own_forward_like is used for testing on systems
// which actually do provide an implementation.
template <typename T, typename U>
auto own_forward_like(U&& u) noexcept -> decltype(auto) {
    return ::beman::execution::detail::forward_like_helper<T>::forward(::std::forward<U>(u));
}

/*!
 * \brief Helper function to forward a subobject (in case the standard library version is unavailable)
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T, typename U>
auto forward_like(U&& u) noexcept -> decltype(auto) {
#if 202207 <= disabled__cpp_lib_forward_like
    return ::std::forward_like<T>(::std::forward<U>(u));
#else
    return ::beman::execution::detail::forward_like_helper<T>::forward(::std::forward<U>(u));
#endif
}

} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Env1, typename Env2>
class join_env {
  private:
    Env1 env1;
    Env2 env2;

  public:
    template <typename E1, typename E2>
    join_env(E1&& e1, E2&& e2) : env1(::std::forward<E1>(e1)), env2(::std::forward<E2>(e2)) {}

    template <typename Query, typename... Args>
        requires(
            requires(Env1&, const Query& query, Args&&... args) {
                env1.query(query, ::std::forward<Args>(args)...);
            } ||
            requires(Env2& e2, const Query& query, Args&&... args) { e2.query(query, ::std::forward<Args>(args)...); })
    auto query(const Query& query, Args&&... args) noexcept -> decltype(auto) {
        if constexpr (requires { env1.query(query, ::std::forward<Args>(args)...); }) {
            return env1.query(query, ::std::forward<Args>(args)...);
        } else {
            return env2.query(query, ::std::forward<Args>(args)...);
        }
    }
    template <typename Query, typename... Args>
        requires(
            requires(const Env1&, const Query& query, Args&&... args) {
                env1.query(query, ::std::forward<Args>(args)...);
            } ||
            requires(const Env2& e2, const Query& query, Args&&... args) {
                e2.query(query, ::std::forward<Args>(args)...);
            })
    auto query(const Query& query, Args&&... args) const noexcept -> decltype(auto) {
        if constexpr (requires { env1.query(query, ::std::forward<Args>(args)...); }) {
            return env1.query(query, ::std::forward<Args>(args)...);
        } else {
            return env2.query(query, ::std::forward<Args>(args)...);
        }
    }
};

template <typename Env1, typename Env2>
join_env(Env1&&, Env2&&) -> join_env<::std::remove_cvref_t<Env1>, ::std::remove_cvref_t<Env2>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

template <::std::size_t I, typename T>
struct product_type_element {
    T    value;
    auto operator==(const product_type_element&) const -> bool = default;
};

template <typename, typename...>
struct product_type_base;

template <::std::size_t... I, typename... T>
struct product_type_base<::std::index_sequence<I...>, T...>
    : ::beman::execution::detail::product_type_element<I, T>... {
    static constexpr ::std::size_t size() { return sizeof...(T); }
    static constexpr bool          is_product_type{true};

    template <::std::size_t J, typename S>
    static auto element_get(::beman::execution::detail::product_type_element<J, S>& self) noexcept -> S& {
        return self.value;
    }
    template <::std::size_t J, typename S>
    static auto element_get(::beman::execution::detail::product_type_element<J, S>&& self) noexcept -> S&& {
        return ::std::move(self.value);
    }
    template <::std::size_t J, typename S>
    static auto element_get(const ::beman::execution::detail::product_type_element<J, S>& self) noexcept -> const S& {
        return self.value;
    }

    template <::std::size_t J>
    auto get() & -> decltype(auto) {
        return this->element_get<J>(*this);
    }
    template <::std::size_t J>
    auto get() && -> decltype(auto) {
        return this->element_get<J>(::std::move(*this));
    }
    template <::std::size_t J>
    auto get() const& -> decltype(auto) {
        return this->element_get<J>(*this);
    }

    template <::std::size_t J, typename Allocator, typename Self>
    static auto make_element(Allocator&& alloc, Self&& self) -> decltype(auto) {
        using type = ::std::remove_cvref_t<decltype(product_type_base::element_get<J>(std::forward<Self>(self)))>;
        if constexpr (::std::uses_allocator_v<type, Allocator>)
            return ::std::make_obj_using_allocator<type>(alloc,
                                                         product_type_base::element_get<J>(std::forward<Self>(self)));
        else
            return product_type_base::element_get<J>(std::forward<Self>(self));
    }

    auto operator==(const product_type_base&) const -> bool = default;
};

template <typename T>
concept is_product_type_c = requires(const T& t) { T::is_product_type; };

template <typename... T>
struct product_type : ::beman::execution::detail::product_type_base<::std::index_sequence_for<T...>, T...> {
    template <typename Allocator, typename Product, std::size_t... I>
    static auto make_from(Allocator&& allocator, Product&& product, std::index_sequence<I...>) -> product_type {
        return {product_type::template make_element<I>(allocator, ::std::forward<Product>(product))...};
    }

    template <typename Allocator, typename Product>
    static auto make_from(Allocator&& allocator, Product&& product) -> product_type {
        return product_type::make_from(
            ::std::forward<Allocator>(allocator), ::std::forward<Product>(product), ::std::index_sequence_for<T...>{});
    }

    template <typename Fun, ::std::size_t... I>
    constexpr auto apply_elements(::std::index_sequence<I...>, Fun&& fun) const -> decltype(auto) {
        return ::std::forward<Fun>(fun)(this->template get<I>()...);
    }
    template <typename Fun>
    constexpr auto apply(Fun&& fun) const -> decltype(auto) {
        return apply_elements(::std::index_sequence_for<T...>{}, ::std::forward<Fun>(fun));
    }
    template <typename Fun, ::std::size_t... I>
    constexpr auto apply_elements(::std::index_sequence<I...>, Fun&& fun) -> decltype(auto) {
        //-dk:TODO provide rvalue, lvalue, const lvalue overloads?
        return ::std::forward<Fun>(fun)(std::move(this->template get<I>())...);
    }
    template <typename Fun>
    constexpr auto apply(Fun&& fun) -> decltype(auto) {
        return apply_elements(::std::index_sequence_for<T...>{}, ::std::forward<Fun>(fun));
    }
};
template <typename... T>
product_type(T&&...) -> product_type<::std::decay_t<T>...>;

template <typename T>
constexpr auto is_product_type(const T&) -> ::std::false_type {
    return {};
}
template <typename... T>
constexpr auto is_product_type(const ::beman::execution::detail::product_type<T...>&) -> ::std::true_type {
    return {};
}

template <::std::size_t Start, typename Fun, typename Tuple, ::std::size_t... I>
constexpr auto sub_apply_helper(Fun&& fun, Tuple&& tuple, ::std::index_sequence<I...>) -> decltype(auto) {
    // NOLINTNEXTLINE(bugprone-use-after-move,hicpp-invalid-access-moved)
    return ::std::forward<Fun>(fun)(::std::forward<Tuple>(tuple).template get<I + Start>()...);
}

template <::std::size_t Start, typename Fun, typename Tuple>
constexpr auto sub_apply(Fun&& fun, Tuple&& tuple) -> decltype(auto) {
    constexpr ::std::size_t TSize{::std::tuple_size_v<::std::remove_cvref_t<Tuple>>};
    static_assert(Start <= TSize);
    return sub_apply_helper<Start>(
        ::std::forward<Fun>(fun), ::std::forward<Tuple>(tuple), ::std::make_index_sequence<TSize - Start>());
}

} // namespace beman::execution::detail

namespace std {
template <typename T>
    requires ::beman::execution::detail::is_product_type_c<T>
struct tuple_size<T> : ::std::integral_constant<std::size_t, T::size()> {};

template <::std::size_t I, typename T>
    requires ::beman::execution::detail::is_product_type_c<T>
struct tuple_element<I, T> {
    using type = ::std::decay_t<decltype(::std::declval<T>().template get<I>())>;
};
} // namespace std

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Tag, typename Env, typename Value>
    requires requires(const Tag& tag, const Env& env) { tag(env); }
constexpr auto query_with_default(Tag, const Env& env, Value&&) noexcept(noexcept(Tag()(env))) -> decltype(auto) {
    return Tag()(env);
}

template <typename Tag, typename Env, typename Value>
constexpr auto
query_with_default(Tag, const Env&, Value&& value) noexcept(noexcept(static_cast<Value>(std::forward<Value>(value))))
    -> decltype(auto) {
    return static_cast<Value>(std::forward<Value>(value));
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary type alias used to determine the type of a child sender.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, ::std::size_t I = 0u>
using child_type = decltype(::std::declval<Sender>().template get<I + 2>());
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper type alias to get type type of a tuple after decaying the argument types
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename... T>
using decayed_tuple = ::std::tuple<::std::decay_t<T>...>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Query, typename Value>
class make_env {
  private:
    Value value;

  public:
    template <typename V>
    make_env(const Query&, V&& v) : value(::std::forward<V>(v)) {}
    constexpr auto query(const Query&) const noexcept -> const Value& { return this->value; }
    constexpr auto query(const Query&) noexcept -> Value& { return this->value; }
};
template <typename Query, typename Value>
make_env(Query&&, Value&& value) -> make_env<::std::remove_cvref_t<Query>, ::std::remove_cvref_t<Value>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta::detail {
template <typename, typename>
struct prepend;

template <template <typename...> class List, typename H, typename... T>
struct prepend<H, List<T...>> {
    using type = List<H, T...>;
};
} // namespace beman::execution::detail::meta::detail

namespace beman::execution::detail::meta {
template <typename H, typename Tail>
using prepend = typename ::beman::execution::detail::meta::detail::prepend<H, Tail>::type;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta {
template <template <typename...> class To, typename>
struct to_type_list;
template <template <typename...> class To, template <typename...> class List, typename... T>
struct to_type_list<To, List<T...>> {
    using type = To<T...>;
};
template <template <typename...> class To, typename T>
using to = typename ::beman::execution::detail::meta::to_type_list<To, T>::type;
} // namespace beman::execution::detail::meta

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename...>
struct type_list {};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <class Token, class CallbackFun>
using stop_callback_for_t = typename Token::template callback_type<CallbackFun>;
}

namespace beman::execution::detail {
template <typename CallbackFun, typename Token, typename Initializer = CallbackFun>
concept stoppable_callback_for =
    ::std::invocable<CallbackFun> && ::std::constructible_from<CallbackFun, Initializer> &&
    requires { typename ::beman::execution::stop_callback_for_t<Token, CallbackFun>; } &&
    ::std::constructible_from<::beman::execution::stop_callback_for_t<Token, CallbackFun>, Token, Initializer> &&
    ::std::constructible_from<::beman::execution::stop_callback_for_t<Token, CallbackFun>, Token&, Initializer> &&
    ::std::constructible_from<::beman::execution::stop_callback_for_t<Token, CallbackFun>, const Token&, Initializer>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Fun, typename... Args>
/*!
 * \brief Type alias used determine the result of function [object] call.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
using call_result_t = decltype(::std::declval<Fun>()(std::declval<Args>()...));
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta {
template <typename>
struct size;
template <template <typename...> class L, typename... T>
struct size<L<T...>> {
    static constexpr ::std::size_t value{sizeof...(T)};
};
template <typename T>
inline constexpr ::std::size_t size_v{::beman::execution::detail::meta::size<T>::value};
} // namespace beman::execution::detail::meta

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename St>
struct on_stop_request {
    St&  st;
    auto operator()() const -> void { this->st.request_stop(); }
};
template <typename T>
on_stop_request(T&) -> on_stop_request<T>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary class template used to detect whether a type alias exist within a class.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <template <typename> class>
struct check_type_alias_exist;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Tag type to indicate a class is a scheduler.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export struct scheduler_t {};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Expr, typename Promise>
auto get_awaiter(Expr&& expr, Promise& promise) -> decltype(auto) {
    auto transform{[&]() -> decltype(auto) {
        if constexpr (requires { promise.await_transform(::std::forward<Expr>(expr)); })
            return promise.await_transform(::std::forward<Expr>(expr));
        else
            return ::std::forward<Expr>(expr);
    }};
    if constexpr (requires { operator co_await(transform()); }) {

        static_assert(not requires { transform().operator co_await(); }, "only one operator co_await is allowed");
        return operator co_await(transform());
    } else if constexpr (requires { transform().operator co_await(); })
        return transform().operator co_await();
    else
        return transform();
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct sender_convert_to_any_t {
    template <typename T>
    constexpr operator T() const; // NOLINT(hicpp-explicit-conversions)
};

template <typename Tag, typename Data, typename Children>
struct sender_meta {
    using tag_type      = ::std::remove_cvref_t<Tag>;
    using data_type     = ::std::remove_cvref_t<Data>;
    using children_type = ::std::remove_cvref_t<Children>;
};

template <typename Tag, typename Data, typename Children>
struct sender_data {
    using tag_type      = ::std::remove_cvref_t<Tag>;
    using data_type     = ::std::remove_cvref_t<Data>;
    using children_type = ::std::remove_cvref_t<Children>;

    tag_type tag;
    Data&    data;
    Children children;
};
template <typename Tag, typename Data, typename Children>
sender_data(Tag&&, Data&, Children&&) -> sender_data<Tag, Data, Children>;

template <typename Sender>
auto get_sender_data(Sender&& sender) {
#if 0
        //-dk:TODO should use a dynamic/language approach:
        auto&& [tag, data, ... children] = sender;
        return sender_meta<decltype(tag), decltype(data), ::std::tuple<decltype(children)...>>;
#else
    using sender_type = ::std::remove_cvref_t<Sender>;
    static constexpr ::beman::execution::detail::sender_convert_to_any_t at{};

    if constexpr (requires {
                      sender.template get<0>();
                      sender.size();
                  })
        return [&sender]<::std::size_t... I>(::std::index_sequence<I...>) {
            return ::beman::execution::detail::sender_data{
                sender.template get<0>(), sender.template get<1>(), ::std::tie(sender.template get<2 + I>()...)};
        }(::std::make_index_sequence<::std::decay_t<decltype(sender)>::size() - 2u>{});
    else if constexpr (requires { sender_type{at, at, at, at, at, at}; }) {
        auto&& [tag, data, c0, c1, c2, c3] = sender;
        return ::beman::execution::detail::sender_data{tag, data, ::std::tie(c0, c1, c2, c3)};
    } else if constexpr (requires { sender_type{at, at, at, at, at}; }) {
        auto&& [tag, data, c0, c1, c2] = sender;
        return ::beman::execution::detail::sender_data{tag, data, ::std::tie(c0, c1, c2)};
    } else if constexpr (requires { sender_type{at, at, at, at}; }) {
        auto&& [tag, data, c0, c1] = sender;
        return ::beman::execution::detail::sender_data{tag, data, ::std::tie(c0, c1)};
    } else if constexpr (requires { sender_type{at, at, at}; }) {
        auto&& [tag, data, c0] = sender;
        return ::beman::execution::detail::sender_data{tag, data, ::std::tie(c0)};
    } else if constexpr (requires { sender_type{at, at}; }) {
        auto&& [tag, data] = sender;
        return ::beman::execution::detail::sender_data{tag, data, ::std::tuple<>{}};
    } else {
        return ::beman::execution::detail::sender_meta<void, void, void>{};
    }
#endif
}

template <typename Sender>
auto get_sender_meta(Sender&& sender) {
    using type = decltype(get_sender_data(sender));
    return sender_meta<typename type::tag_type, typename type::data_type, typename type::children_type>{};
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Fun, typename... Args>
auto suspend_complete(Fun fun, Args&&... args) noexcept {
    auto f{[&, fun]() noexcept { fun(::std::forward<Args>(args)...); }};
    struct awaiter {
        decltype(f) fun;

        static constexpr auto await_ready() noexcept -> bool { return false; }
        auto                  await_suspend(::std::coroutine_handle<>) noexcept { this->fun(); }
#if __cpp_lib_unreachable < 202202L
        [[noreturn]] auto await_resume() noexcept -> void { ::std::terminate(); }
#else
        [[noreturn]] auto await_resume() noexcept -> void { ::std::unreachable(); }
#endif
    };
    return awaiter{f};
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta {
template <typename T, typename... S>
inline constexpr bool contains{(::std::same_as<T, S> || ...)};
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper concept to determine if the first argument decays to the second argument
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename From, typename To>
concept decays_to = ::std::same_as<::std::decay_t<From>, To>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

template <auto Next>
class atomic_intrusive_stack;

template <auto Next>
class intrusive_stack;

//! @brief  This data structure is an intrusive queue that is not thread-safe.
template <class Item, Item* Item::* Next>
class intrusive_stack<Next> {
  public:
    //! @brief  Pushes an item to the queue.
    auto push(Item* item) noexcept -> void { item->*Next = std::exchange(head_, item); }

    //! @brief  Pops one item from the queue.
    //!
    //! @return  The item that was popped from the queue, or nullptr if the queue is empty.
    auto pop() noexcept -> Item* {
        if (head_) {
            auto item = head_;
            head_     = std::exchange(item->*Next, nullptr);
            return item;
        }
        return nullptr;
    }

    //! @brief  Tests if the queue is empty.
    auto empty() const noexcept -> bool { return !head_; }

  private:
    friend class atomic_intrusive_stack<Next>;
    Item* head_{nullptr};
};

} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct immovable;
struct virtual_immovable;
} // namespace beman::execution::detail

struct beman::execution::detail::immovable {
    constexpr immovable()                          = default;
    immovable(immovable&&)                         = delete;
    immovable(const immovable&)                    = delete;
    ~immovable()                                   = default;
    auto operator=(immovable&&) -> immovable&      = delete;
    auto operator=(const immovable&) -> immovable& = delete;
};

struct beman::execution::detail::virtual_immovable {
    constexpr virtual_immovable()                                  = default;
    virtual_immovable(virtual_immovable&&)                         = delete;
    virtual_immovable(const virtual_immovable&)                    = delete;
    virtual ~virtual_immovable()                                   = default;
    auto operator=(virtual_immovable&&) -> virtual_immovable&      = delete;
    auto operator=(const virtual_immovable&) -> virtual_immovable& = delete;
};

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct unspecified_promise {
    auto get_return_object() noexcept -> unspecified_promise;
    auto initial_suspend() noexcept -> ::std::suspend_never;
    auto final_suspend() noexcept -> ::std::suspend_never;
    void unhandled_exception() noexcept;
    void return_void() noexcept;
    auto unhandled_stopped() noexcept -> ::std::coroutine_handle<>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary type trait used to detect specializations of `std::coroutine_handle`.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename>
struct is_coroutine_handle : ::std::false_type {};
/*!
 * \brief The actual partial specialization detecting `std::coroutine_handle`.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T>
struct is_coroutine_handle<::std::coroutine_handle<T>> : ::std::true_type {};

/*!
 * \brief A concept used to identify valid results for `await_suspend`.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T>
concept await_suspend_result =
    ::std::same_as<T, void> || ::std::same_as<T, bool> || ::beman::execution::detail::is_coroutine_handle<T>::value;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <template <typename...> class T, typename... Args>
concept valid_specialization = requires { typename T<Args...>; };
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <bool>
struct indirect_meta_apply {
    template <template <typename...> class T, class... A>
    using meta_apply = T<A...>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender>
using indices_for = typename ::std::remove_reference_t<Sender>::indices_for;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper type alias to get the type after decaying the argument
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <auto&& Tag>
using decayed_typeof = ::std::decay_t<decltype(Tag)>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct nostopstate_t {
    explicit nostopstate_t() = default;
};

export inline constexpr nostopstate_t nostopstate{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <::beman::execution::detail::queryable>
struct env_base;

template <typename E, typename Q>
concept has_query = requires(const E& e) { e.query(::std::declval<Q>()); };

template <typename Q, typename... E>
struct find_env;
template <typename Q, typename E0, typename... E>
    requires has_query<E0, Q>
struct find_env<Q, E0, E...> {
    using type = E0;
};
template <typename Q, typename E0, typename... E>
    requires(not has_query<E0, Q>)
struct find_env<Q, E0, E...> {
    using type = typename find_env<Q, E...>::type;
};
} // namespace beman::execution::detail

namespace beman::execution {
export template <::beman::execution::detail::queryable... Envs>
struct env;

template <::beman::execution::detail::queryable... Envs>
env(Envs...) -> env<::std::unwrap_reference_t<Envs>...>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

template <::beman::execution::detail::queryable Env>
struct beman::execution::detail::env_base {
    Env env_;
};

template <::beman::execution::detail::queryable... Envs>
struct beman::execution::env : ::beman::execution::detail::env_base<Envs>... {
    [[no_unique_address]] ::beman::execution::detail::non_assignable na_{};

    template <typename Q>
        requires(::beman::execution::detail::has_query<Envs, Q> || ...)
    constexpr auto query(Q q) const noexcept -> decltype(auto) {
        using E = typename ::beman::execution::detail::find_env<Q, Envs...>::type;
        return q(static_cast<const ::beman::execution::detail::env_base<E>&>(*this).env_);
    }
};

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_allocator_t {
    template <typename Object>
        requires(not requires(Object&& object, const get_allocator_t& tag) { ::std::as_const(object).query(tag); })
    auto
    operator()(Object&&) const = BEMAN_EXECUTION_DELETE("the object requires a const query(get_allocator_t) overload");
    template <typename Object>
        requires(
                    not requires(const Object& object, const get_allocator_t& tag) { object.query(tag); } &&
                    not requires(Object&& object, const get_allocator_t& tag) { ::std::as_const(object).query(tag); })
    auto operator()(Object&&) const = BEMAN_EXECUTION_DELETE("the object requires a query(get_allocator_t) overload");
    template <typename Object>
        requires(not requires(const Object& object, const get_allocator_t& tag) {
                    { object.query(tag) } noexcept;
                })
    auto
    operator()(Object&&) const = BEMAN_EXECUTION_DELETE("the query(get_allocator_t) overload needs to be noexcept");

    template <typename Object>
        requires(not requires(const Object& object, const get_allocator_t& tag) {
                    { object.query(tag) } noexcept -> ::beman::execution::detail::simple_allocator<>;
                })
    auto
    operator()(Object&&) const = BEMAN_EXECUTION_DELETE("the query(get_allocator_t) overload needs to be noexcept");

    template <typename Object>
        requires(requires(const Object& object, const get_allocator_t& tag) {
            { object.query(tag) } noexcept -> ::beman::execution::detail::simple_allocator<>;
        })
    auto operator()(Object&& object) const noexcept {
        return ::std::as_const(object).query(*this);
    }

    constexpr auto query(const ::beman::execution::forwarding_query_t&) const noexcept -> bool { return true; }
};

export inline constexpr get_allocator_t get_allocator{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_domain_t {
    template <typename Object>
        requires(not requires(Object&& object, const get_domain_t& tag) {
                    ::std::forward<Object>(object).query(tag);
                }) && (not requires(Object&& object, const get_domain_t& tag) { ::std::as_const(object).query(tag); })
    auto operator()(Object&&) const noexcept = BEMAN_EXECUTION_DELETE("object needs a query(get_domain_t) overload");
    template <typename Object>
        requires(not requires(Object&& object, const get_domain_t& tag) { ::std::as_const(object).query(tag); })
    auto
    operator()(Object&&) const noexcept = BEMAN_EXECUTION_DELETE("query(get_domain_t) overload needs to be const");
    template <typename Object>
        requires(not requires(Object&& object, const get_domain_t& tag) {
                    { ::std::as_const(object).query(tag) } noexcept;
                })
    auto
    operator()(Object&&) const noexcept = BEMAN_EXECUTION_DELETE("query(get_domain_t) overload needs to be noexcept");

    template <typename Object>
    constexpr auto operator()(Object&& object) const noexcept {
        return ::std::as_const(object).query(*this);
    }
    constexpr auto query(const ::beman::execution::forwarding_query_t&) const noexcept -> bool { return true; }
};

export inline constexpr get_domain_t get_domain{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_scheduler_t : ::beman::execution::forwarding_query_t {
    template <typename Env>
        requires requires(const get_scheduler_t& self, Env&& env) { ::std::as_const(env).query(self); }
    auto operator()(Env&& env) const noexcept {
        static_assert(noexcept(::std::as_const(env).query(*this)));
        //-dk:TODO mandate that the result is a scheduler
        // static_assert(::beman::execution::scheduler<
        //     decltype(::std::as_const(env).query(*this))
        // >)
        return ::std::as_const(env).query(*this);
    }
};

export inline constexpr get_scheduler_t get_scheduler{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct operation_state_t {};

export template <typename State>
concept operation_state =
    ::std::derived_from<typename State::operation_state_concept, ::beman::execution::operation_state_t> &&
    ::std::is_object_v<State> && requires(State& state) {
        { ::beman::execution::start(state) } noexcept;
    };
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename, typename>
struct valid_completion_for_aux;

template <typename Rcvr, typename Tag, typename... Args>
struct valid_completion_for_aux<Rcvr, Tag (*)(Args...)> {
    static auto test(Tag (*)(Args...)) -> void
        requires ::beman::execution::detail::callable<Tag, ::std::remove_cvref_t<Rcvr>, Args...>
    {}
};

template <typename Signature, typename Rcvr>
concept valid_completion_for = requires(Signature* signature) {
#if 1
    valid_completion_for_aux<Rcvr, Signature*>::test(signature);
#else
    // This definition crashes some versions of clang.
    []<typename Tag, typename... Args>(Tag (*)(Args...))
        requires ::beman::execution::detail::callable<Tag, ::std::remove_cvref_t<Rcvr>, Args...>
    {}(signature);
#endif
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename>
struct is_set_error : ::std::false_type {};
template <typename Error>
struct is_set_error<::beman::execution::set_error_t(Error)> : ::std::true_type {};

template <typename Fun>
using is_set_stopped = ::std::is_same<Fun, ::beman::execution::set_stopped_t()>;

template <typename>
struct is_set_value : ::std::false_type {};
template <typename... Args>
struct is_set_value<::beman::execution::set_value_t(Args...)> : ::std::true_type {};

/*!
 * \brief Detect if a type is a completion signature.
 *
 * \details
 * The three completion signatures are
 * - set_error_t(E) for completion with an error.
 * - set_stopped_t() to indicate that operation was cancelled.
 * - set_value_t(A...) for successful completion with a set of argument.
 *
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \concept copmletion_signature
 * \internal
 */
template <typename Fun>
concept completion_signature =
    ::beman::execution::detail::is_set_error<Fun>::value || ::beman::execution::detail::is_set_stopped<Fun>::value ||
    ::beman::execution::detail::is_set_value<Fun>::value;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename>
struct prop_like;
}

namespace beman::execution {
export template <typename Query, typename Value>
struct prop;

template <typename Query, typename Value>
prop(Query, Value, ::beman::execution::detail::non_assignable = {}) -> prop<Query, ::std::unwrap_reference_t<Value>>;
} // namespace beman::execution

template <typename V>
struct beman::execution::detail::prop_like {
    V    value;
    auto query(auto) const noexcept -> const V& { return this->value; }
};

template <typename Query, typename Value>
struct beman::execution::prop {
    static_assert(::beman::execution::detail::callable<Query, ::beman::execution::detail::prop_like<Value>>);

    [[no_unique_address]] Query                                      query_{};
    [[no_unique_address]] Value                                      value_{};
    [[no_unique_address]] ::beman::execution::detail::non_assignable non_assignable_{};

    // prop(prop&&)                = default;
    // prop(const prop&)           = default;
    // auto operator=(prop&&) -> prop&      = delete;
    // auto operator=(const prop&) -> prop& = delete;

    constexpr auto query(Query) const noexcept -> const Value& { return this->value_; }
};

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Token>
concept stoppable_token = requires(const Token& token) {
    typename ::beman::execution::detail::check_type_alias_exist<Token::template callback_type>;
    { token.stop_requested() } noexcept -> ::std::same_as<bool>;
    { token.stop_possible() } noexcept -> ::std::same_as<bool>;
    { Token(token) } noexcept;
} && ::std::copyable<Token> && ::std::equality_comparable<Token> && ::std::swappable<Token>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief A helper concept used to determine if a type is one of the completion tags.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Tag>
concept completion_tag =
    ::std::same_as<Tag, ::beman::execution::set_error_t> || ::std::same_as<Tag, ::beman::execution::set_stopped_t> ||
    ::std::same_as<Tag, ::beman::execution::set_value_t>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary type alias to get the result type of an awaiter.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T, typename Promise>
using await_result_type =
    decltype(::beman::execution::detail::get_awaiter(::std::declval<T>(), ::std::declval<Promise&>()).await_resume());
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief A helper class to create environments and taking forwarding_query into account
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Env>
class fwd_env {
  private:
    Env env;

  public:
    explicit fwd_env(Env&& e) : env(::std::forward<Env>(e)) {}

    template <typename Query, typename... Args>
        requires(!::beman::execution::forwarding_query(::std::remove_cvref_t<Query>()))
    constexpr auto query(Query&& q,
                         Args&&... args) const = BEMAN_EXECUTION_DELETE("the used query is not forwardable");

    template <typename Query, typename... Args>
        requires(::beman::execution::forwarding_query(::std::remove_cvref_t<Query>())) &&
                requires(const Env& e, Query&& q, Args&&... args) { e.query(q, ::std::forward<Args>(args)...); }
    constexpr auto query(Query&& q, Args&&... args) const
        noexcept(noexcept(env.query(q, ::std::forward<Args>(args)...))) {
        return env.query(q, ::std::forward<Args>(args)...);
    }
};
template <typename Env>
fwd_env(Env&&) -> fwd_env<Env>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Sender>
using tag_of_t = typename decltype(::beman::execution::detail::get_sender_meta(::std::declval<Sender&&>()))::tag_type;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta::detail {
template <typename...>
struct combine;

template <template <typename...> class L0, typename... T0>
struct combine<L0<T0...>> {
    using type = L0<T0...>;
};
template <template <typename...> class L0,
          typename... T0,
          template <typename...> class L1,
          typename... T1,
          typename... L>
struct combine<L0<T0...>, L1<T1...>, L...> {
    using type = typename combine<L0<T0..., T1...>, L...>::type;
};
} // namespace beman::execution::detail::meta::detail

namespace beman::execution::detail::meta {
template <typename... L>
using combine = typename ::beman::execution::detail::meta::detail::combine<L...>::type;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta::detail {
template <typename, typename>
struct make_unique;
template <typename>
struct unique;

template <template <typename...> class List, typename... R>
struct make_unique<List<R...>, List<>> {
    using type = List<R...>;
};

template <template <typename...> class List, typename... R, typename H, typename... T>
struct make_unique<List<R...>, List<H, T...>> {
    using type = typename ::beman::execution::detail::meta::detail::make_unique<
        ::std::conditional_t<::beman::execution::detail::meta::contains<H, R...>, List<R...>, List<R..., H>>,
        List<T...>>::type;
};

template <template <typename...> class List, typename... T>
struct unique<List<T...>> {
    using type = typename ::beman::execution::detail::meta::detail::make_unique<List<>, List<T...>>::type;
};
} // namespace beman::execution::detail::meta::detail

namespace beman::execution::detail::meta {
template <typename T>
using unique = typename ::beman::execution::detail::meta::detail::unique<T>::type;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta::detail {
template <template <typename> class, typename>
struct filter;

template <template <typename, typename> class, typename, typename>
struct filter_tag;

template <template <typename> class Predicate, template <typename...> class List>
struct filter<Predicate, List<>> {
    using type = List<>;
};

template <template <typename, typename> class Predicate, typename Tag, template <typename...> class List>
struct filter_tag<Predicate, Tag, List<>> {
    using type = List<>;
};

template <template <typename> class Predicate, template <typename...> class List, typename H, typename... T>
struct filter<Predicate, List<H, T...>> {
    using tail = typename beman::execution::detail::meta::detail::filter<Predicate, List<T...>>::type;
    using type = ::std::conditional_t<Predicate<H>::value, ::beman::execution::detail::meta::prepend<H, tail>, tail>;
};

template <template <typename, typename> class Predicate,
          typename Tag,
          template <typename...> class List,
          typename H,
          typename... T>
struct filter_tag<Predicate, Tag, List<H, T...>> {
    using tail = typename beman::execution::detail::meta::detail::filter_tag<Predicate, Tag, List<T...>>::type;
    using type =
        ::std::conditional_t<Predicate<Tag, H>::value, ::beman::execution::detail::meta::prepend<H, tail>, tail>;
};
} // namespace beman::execution::detail::meta::detail

namespace beman::execution::detail::meta {
template <template <typename> class Predicate, typename List>
using filter = typename ::beman::execution::detail::meta::detail::filter<Predicate, List>::type;

template <template <typename, typename> class Predicate, typename Tag, typename List>
using filter_tag = typename ::beman::execution::detail::meta::detail::filter_tag<Predicate, Tag, List>::type;
} // namespace beman::execution::detail::meta

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::meta::detail {
template <template <typename> class Transform, typename List>
struct transform;

template <template <typename> class Transform, template <typename... T> class List, typename... T>
struct transform<Transform, List<T...>> {
    using type = List<Transform<T>...>;
};
} // namespace beman::execution::detail::meta::detail

namespace beman::execution::detail::meta {
template <template <typename> class Transform, typename List>
using transform = typename ::beman::execution::detail::meta::detail::transform<Transform, List>::type;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Turn a completion signatures into a std::tuple type.
 * \internal
 */
template <typename T>
struct as_tuple;
/*!
 * \brief The actual operational partial specialization of as_tuple.
 * \internal
 */
template <typename Rc, typename... A>
struct as_tuple<Rc(A...)> {
    using type = ::beman::execution::detail::decayed_tuple<Rc, A...>;
};

template <typename T>
using as_tuple_t = typename ::beman::execution::detail::as_tuple<T>::type;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

template <auto Next>
class atomic_intrusive_stack;

//! @brief  This data structure is an intrusive stack that can be used in a lock-free manner.
//!
//! The stack is implemented as a singly linked list where the head is an atomic pointer to the first item in
//! the stack.
//! try_push() is a lock-free operation that tries to push an item to the stack. If the stack is empty, it
//! returns nullptr and the item is pushed to the stack.
//! This stack has a closed state, which is indicated by the head pointing to the stack itself. In this state,
//! try_push() returns std::nullopt and the stack is not modified.
//! pop_all_and_shutdown() is a lock-free operation that pops all items from the stack and returns them in a
//! queue. If the stack is empty, it returns an empty queue.
//!
//! We use this stack in the split implementation to store the listeners that are waiting for the operation to
//! complete.
//!
//! @tparam Item  The type of the item in the stack.
//! @tparam Next  The pointer to the next item in the stack.
template <class Item, Item* Item::* Next>
class atomic_intrusive_stack<Next> {
  public:
    atomic_intrusive_stack() = default;
    ~atomic_intrusive_stack() { assert(!head_ || head_ == this); }
    atomic_intrusive_stack(const atomic_intrusive_stack&)                        = delete;
    auto operator=(const atomic_intrusive_stack&) -> atomic_intrusive_stack&     = delete;
    atomic_intrusive_stack(atomic_intrusive_stack&&) noexcept                    = delete;
    auto operator=(atomic_intrusive_stack&&) noexcept -> atomic_intrusive_stack& = delete;

    //! @brief  Tries to push an item to the stack.
    //!
    //! @param item  The item to push to the stack.
    //!
    //! @return  If the stack is empty, returns nullptr and pushes the item to the stack.
    //!          If the stack is in the closed state, returns std::nullopt.
    auto try_push(Item* item) noexcept -> std::optional<Item*> {
        void* ptr = head_.load();
        if (ptr == this) {
            return std::nullopt;
        }
        item->*Next = static_cast<Item*>(ptr);
        while (!head_.compare_exchange_weak(ptr, item)) {
            if (ptr == this) {
                return std::nullopt;
            }
            item->*Next = static_cast<Item*>(ptr);
        }
        return static_cast<Item*>(ptr);
    }

    //! @brief  Tests if the stack is empty and not in the closed state.
    auto empty_and_not_shutdown() const noexcept -> bool { return head_.load() == nullptr; }

    //! @brief  Pops all items from the stack, returns them and puts this stack into the closed state.
    //!
    //! @return  If the stack is empty, returns an empty stack.
    auto pop_all_and_shutdown() noexcept -> ::beman::execution::detail::intrusive_stack<Next> {
        auto  stack = ::beman::execution::detail::intrusive_stack<Next>{};
        void* ptr   = head_.exchange(this);
        if (ptr == this) {
            return stack;
        }
        auto item   = static_cast<Item*>(ptr);
        stack.head_ = item;
        return stack;
    }

  private:
    ::std::atomic<void*> head_{nullptr};
};

} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution {
export class inplace_stop_token;
export class inplace_stop_source;
export template <typename CallbackFun>
class inplace_stop_callback;
export template <typename CallbackFun>
inplace_stop_callback(::beman::execution::inplace_stop_token, CallbackFun) -> inplace_stop_callback<CallbackFun>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

class beman::execution::inplace_stop_token {
  public:
    template <typename CallbackFun>
    using callback_type = ::beman::execution::inplace_stop_callback<CallbackFun>;

    inplace_stop_token() = default;

    constexpr auto stop_requested() const noexcept -> bool;
    constexpr auto stop_possible() const noexcept -> bool;
    auto           operator==(const inplace_stop_token&) const -> bool = default;

    auto swap(inplace_stop_token&) noexcept -> void;

  private:
    friend class ::beman::execution::inplace_stop_source;
    template <typename CallbackFun>
    friend class ::beman::execution::inplace_stop_callback;
    explicit inplace_stop_token(::beman::execution::inplace_stop_source* src) : source(src) {}

    ::beman::execution::inplace_stop_source* source{};
};

// ----------------------------------------------------------------------------

class beman::execution::inplace_stop_source {
    struct callback_base : public ::beman::execution::detail::virtual_immovable {
        callback_base* next{};
        virtual auto   call() -> void = 0;
    };

  public:
    auto                  stop_requested() const noexcept -> bool;
    static constexpr auto stop_possible() noexcept -> bool;
    auto                  get_token() const -> ::beman::execution::inplace_stop_token;

    auto request_stop() -> bool;

  private:
    template <typename CallbackFun>
    friend class ::beman::execution::inplace_stop_callback;
    ::std::atomic<bool>           stopped{};
    ::std::atomic<callback_base*> running{};
    ::std::thread::id             id{};
    ::std::mutex                  lock;
    callback_base*                callbacks{};

    auto add(callback_base* cb) -> void;
    auto deregister(callback_base* cb) -> void;
};

// ----------------------------------------------------------------------------

template <typename CallbackFun>
class beman::execution::inplace_stop_callback final : public ::beman::execution::inplace_stop_source::callback_base {
  public:
    using callback_type = CallbackFun;

    template <typename Init>
    inplace_stop_callback(::beman::execution::inplace_stop_token, Init&&);
    inplace_stop_callback(const inplace_stop_callback&) = delete;
    inplace_stop_callback(inplace_stop_callback&&)      = delete;
    ~inplace_stop_callback() override {
        if (this->source) {
            this->source->deregister(this);
        }
    }
    auto operator=(const inplace_stop_callback&) -> inplace_stop_callback& = delete;
    auto operator=(inplace_stop_callback&&) -> inplace_stop_callback&      = delete;

  private:
    auto call() -> void override;

    CallbackFun                              fun;
    ::beman::execution::inplace_stop_source* source;
};

// ----------------------------------------------------------------------------

inline constexpr auto beman::execution::inplace_stop_token::stop_requested() const noexcept -> bool {
    return this->source && this->source->stop_requested();
}

inline constexpr auto beman::execution::inplace_stop_token::stop_possible() const noexcept -> bool {
    return this->source;
}

inline auto beman::execution::inplace_stop_token::swap(inplace_stop_token& other) noexcept -> void {
    ::std::swap(this->source, other.source);
}

inline auto beman::execution::inplace_stop_source::stop_requested() const noexcept -> bool { return this->stopped; }

inline constexpr auto beman::execution::inplace_stop_source::stop_possible() noexcept -> bool { return true; }

inline auto beman::execution::inplace_stop_source::get_token() const -> ::beman::execution::inplace_stop_token {
    return ::beman::execution::inplace_stop_token(const_cast<::beman::execution::inplace_stop_source*>(this));
}

inline auto beman::execution::inplace_stop_source::request_stop() -> bool {
    using relock = ::std::unique_ptr<::std::unique_lock<::std::mutex>, decltype([](auto p) { p->lock(); })>;
    if (false == this->stopped.exchange(true)) {
        ::std::unique_lock guard(this->lock);
        for (auto it = this->callbacks; it != nullptr; it = this->callbacks) {
            this->running   = it;
            this->id        = ::std::this_thread::get_id();
            this->callbacks = it->next;
            {
                relock r(&guard);
                guard.unlock();
                it->call();
            }
            this->running = nullptr;
        }
        return true;
    }
    return false;
}

inline auto beman::execution::inplace_stop_source::add(callback_base* cb) -> void {
    if (this->stopped) {
        cb->call();
    } else {
        ::std::lock_guard guard(this->lock);
        cb->next = ::std::exchange(this->callbacks, cb);
    }
}

inline auto beman::execution::inplace_stop_source::deregister(callback_base* cb) -> void {
    ::std::unique_lock guard(this->lock);
    if (this->running == cb) {
        if (this->id == ::std::this_thread::get_id()) {
            return;
        }
        guard.unlock();
        while (this->running == cb) {
        }
        return;
    }

    for (callback_base** it{&this->callbacks}; *it; it = &(*it)->next) {
        if (*it == cb) {
            *it = cb->next;
            break;
        }
    }
}

template <typename CallbackFun>
template <typename Init>
inline beman::execution::inplace_stop_callback<CallbackFun>::inplace_stop_callback(
    ::beman::execution::inplace_stop_token token, Init&& init)
    : fun(::std::forward<Init>(init)), source(token.source) {
    if (this->source) {
        this->source->add(this);
    }
}

template <typename CallbackFun>
inline auto beman::execution::inplace_stop_callback<CallbackFun>::call() -> void {
    this->fun();
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <class... Args>
using decayed_type_list = ::beman::execution::detail::type_list<::std::decay_t<Args>...>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary concept used to detect class types. [execution.syn#concept:class-type]
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Tp>
concept class_type = ::beman::execution::detail::decays_to<Tp, Tp> && ::std::is_class_v<Tp>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Fun, typename... Args>
concept nothrow_callable = ::beman::execution::detail::callable<Fun, Args...> && requires(Fun&& fun, Args&&... args) {
    { ::std::forward<Fun>(fun)(::std::forward<Args>(args)...) } noexcept;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
class counting_scope_base;
}

// ----------------------------------------------------------------------------

class beman::execution::detail::counting_scope_base : ::beman::execution::detail::immovable {
  public:
    counting_scope_base()                      = default;
    counting_scope_base(counting_scope_base&&) = delete;
    ~counting_scope_base();

    static constexpr ::std::size_t max_associations{8194u};

    auto close() noexcept -> void;

    struct node {
        virtual auto complete() noexcept -> void        = 0;
        virtual auto complete_inline() noexcept -> void = 0;
        node*        next{};
    };
    auto start_node(node*) -> void;

  protected:
    class token {
      public:
        auto try_associate() const noexcept -> bool { return this->scope->try_associate(); }
        auto disassociate() const noexcept -> void { this->scope->disassociate(); }

      protected:
        explicit token(::beman::execution::detail::counting_scope_base* s) : scope(s) {}
        ::beman::execution::detail::counting_scope_base* scope;
    };

  private:
    enum class state_t : unsigned char {
        unused,
        open,
        open_and_joining,
        closed,
        closed_and_joining,
        unused_and_closed,
        joined
    };

    auto try_associate() noexcept -> bool;
    auto disassociate() noexcept -> void;
    auto complete() noexcept -> void;
    auto add_node(node* n, ::std::lock_guard<::std::mutex>&) noexcept -> void;

    ::std::mutex mutex;
    //-dk:TODO fuse state and count and use atomic accesses
    ::std::size_t count{};
    state_t       state{state_t::unused};
    node*         head{};
};

// ----------------------------------------------------------------------------

inline beman::execution::detail::counting_scope_base::~counting_scope_base() {
    ::std::lock_guard kerberos(this->mutex);
    switch (this->state) {
    default:
        ::std::terminate();
    case state_t::unused:
    case state_t::unused_and_closed:
    case state_t::joined:
        break;
    }
}

inline auto beman::execution::detail::counting_scope_base::close() noexcept -> void {
    switch (this->state) {
    default:
        break;
    case state_t::unused:
        this->state = state_t::unused_and_closed;
        break;
    case state_t::open:
        this->state = state_t::closed;
        break;
    case state_t::open_and_joining:
        this->state = state_t::closed_and_joining;
        break;
    }
}

inline auto beman::execution::detail::counting_scope_base::add_node(node* n, ::std::lock_guard<::std::mutex>&) noexcept
    -> void {
    n->next = std::exchange(this->head, n);
}

inline auto beman::execution::detail::counting_scope_base::try_associate() noexcept -> bool {
    ::std::lock_guard lock(this->mutex);
    switch (this->state) {
    default:
        return false;
    case state_t::unused:
        this->state = state_t::open; // fall-through!
        [[fallthrough]];
    case state_t::open:
    case state_t::open_and_joining:
        ++this->count;
        return true;
    }
}

inline auto beman::execution::detail::counting_scope_base::disassociate() noexcept -> void {
    {
        ::std::lock_guard lock(this->mutex);
        if (0u < --this->count)
            return;
        this->state = state_t::joined;
    }
    this->complete();
}

inline auto beman::execution::detail::counting_scope_base::complete() noexcept -> void {
    node* current{[this] {
        ::std::lock_guard lock(this->mutex);
        return ::std::exchange(this->head, nullptr);
    }()};
    while (current) {
        ::std::exchange(current, current->next)->complete();
    }
}

inline auto beman::execution::detail::counting_scope_base::start_node(node* n) -> void {
    ::std::lock_guard kerberos(this->mutex);
    switch (this->state) {
    case ::beman::execution::detail::counting_scope_base::state_t::unused:
    case ::beman::execution::detail::counting_scope_base::state_t::unused_and_closed:
    case ::beman::execution::detail::counting_scope_base::state_t::joined:
        this->state = ::beman::execution::detail::counting_scope_base::state_t::joined;
        n->complete_inline();
        return;
    case ::beman::execution::detail::counting_scope_base::state_t::open:
        this->state = ::beman::execution::detail::counting_scope_base::state_t::open_and_joining;
        break;
    case ::beman::execution::detail::counting_scope_base::state_t::open_and_joining:
        break;
    case ::beman::execution::detail::counting_scope_base::state_t::closed:
        this->state = ::beman::execution::detail::counting_scope_base::state_t::closed_and_joining;
        break;
    case ::beman::execution::detail::counting_scope_base::state_t::closed_and_joining:
        break;
    }
    this->add_node(n, kerberos);
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Awaiter, typename Promise>
concept is_awaiter = requires(Awaiter& awaiter, ::std::coroutine_handle<Promise> handle) {
    awaiter.await_ready() ? 1 : 0;
    { awaiter.await_suspend(handle) } -> ::beman::execution::detail::await_suspend_result;
    awaiter.await_resume();
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export class stop_token;
export class stop_source;
export template <typename CallbackFun>
class stop_callback;
export template <typename CallbackFun>
stop_callback(::beman::execution::stop_token, CallbackFun) -> stop_callback<CallbackFun>;
} // namespace beman::execution

namespace beman::execution::detail {
struct stop_state;
struct stop_callback_base;
} // namespace beman::execution::detail
// ----------------------------------------------------------------------------

struct beman::execution::detail::stop_state {
    ::std::atomic<bool>                           stop_requested{};
    ::std::atomic<::std::size_t>                  sources{};
    ::std::mutex                                  lock{};
    beman::execution::detail::stop_callback_base* callbacks{};
    ::std::atomic<bool>                           executing{};

    auto stop_possible() const -> bool { return this->sources != 0 || this->stop_requested; }
};

// ----------------------------------------------------------------------------

struct beman::execution::detail::stop_callback_base {
  private:
    using stop_state = ::beman::execution::detail::stop_state;
    ::std::shared_ptr<stop_state> state;

    virtual auto do_call() -> void = 0;

  protected:
    explicit stop_callback_base(const ::beman::execution::stop_token&);
    ~stop_callback_base();

  public:
    stop_callback_base(stop_callback_base&&)                         = delete;
    stop_callback_base(const stop_callback_base&)                    = delete;
    auto operator=(stop_callback_base&&) -> stop_callback_base&      = delete;
    auto operator=(const stop_callback_base&) -> stop_callback_base& = delete;
    auto call() -> void;
    auto setup() -> void;
    auto deregister() -> void;

    stop_callback_base* next{};
    ::std::thread::id   id{};
};

// ----------------------------------------------------------------------------

class beman::execution::stop_source {
  private:
    using stop_state = ::beman::execution::detail::stop_state;

    ::std::shared_ptr<stop_state> state{::std::make_shared<stop_state>()};

  public:
    using stop_token = ::beman::execution::stop_token;

    stop_source();
    explicit stop_source(::beman::execution::nostopstate_t) noexcept;
    stop_source(const stop_source&);
    stop_source(stop_source&&) = default;
    auto operator=(const stop_source&) -> stop_source&;
    auto operator=(stop_source&&) -> stop_source& = default;
    ~stop_source();

    auto swap(stop_source&) noexcept -> void;
    auto get_token() const -> stop_token;
    auto stop_requested() const noexcept -> bool;
    auto stop_possible() const noexcept -> bool;
    auto request_stop() noexcept -> bool;
};

// ----------------------------------------------------------------------------

class beman::execution::stop_token {
  private:
    friend ::beman::execution::stop_source;
    friend ::beman::execution::detail::stop_callback_base;
    ::std::shared_ptr<::beman::execution::detail::stop_state> state;

    explicit stop_token(::std::shared_ptr<::beman::execution::detail::stop_state>);

  public:
    template <typename Fun>
    using callback_type = ::beman::execution::stop_callback<Fun>;

    stop_token() = default;

    auto               swap(stop_token& other) noexcept -> void;
    [[nodiscard]] auto stop_requested() const noexcept -> bool;
    [[nodiscard]] auto stop_possible() const noexcept -> bool;

    [[nodiscard]] auto operator==(const stop_token&) const noexcept -> bool = default;
};

// ----------------------------------------------------------------------------

template <typename CallbackFun>
class beman::execution::stop_callback final : private CallbackFun, beman::execution::detail::stop_callback_base {
  private:
    static_assert(::std::invocable<CallbackFun>);
    static_assert(::std::destructible<CallbackFun>);

    using stop_token = ::beman::execution::stop_token;

    auto do_call() -> void override { (*this)(); }

  public:
    using callback_type = CallbackFun;

    template <typename Initializer>
    stop_callback(const stop_token& token,
                  Initializer&&     init) noexcept(::std::is_nothrow_constructible_v<CallbackFun, Initializer>)
        requires(::std::constructible_from<CallbackFun, Initializer>)
        : CallbackFun(::std::forward<Initializer>(init)), stop_callback_base(token) {
        this->setup();
    }
    template <typename Initializer>
    stop_callback(stop_token&&  token,
                  Initializer&& init) noexcept(::std::is_nothrow_constructible_v<CallbackFun, Initializer>)
        requires(::std::is_constructible_v<CallbackFun, Initializer>)
        : CallbackFun(::std::forward<Initializer>(init)), stop_callback_base(::std::move(token)) {
        this->setup();
    }
    stop_callback(const stop_callback&) = delete;
    stop_callback(stop_callback&&)      = delete;
    ~stop_callback() { this->deregister(); }
    auto operator=(stop_callback&&) -> stop_callback&      = delete;
    auto operator=(const stop_callback&) -> stop_callback& = delete;
};

// ----------------------------------------------------------------------------

inline beman::execution::detail::stop_callback_base::stop_callback_base(const ::beman::execution::stop_token& token)
    : state(token.state) {}

inline beman::execution::detail::stop_callback_base::~stop_callback_base() {}

inline auto beman::execution::detail::stop_callback_base::setup() -> void {
    if (this->state) {
        {
            ::std::lock_guard guard(this->state->lock);
            if (!this->state->stop_requested) {
                this->next = ::std::exchange(this->state->callbacks, this);
                return;
            }
        }
        this->call();
    }
}

inline auto beman::execution::detail::stop_callback_base::deregister() -> void {
    if (this->state) {
        ::std::unique_lock guard(this->state->lock);
        if (this->state->executing && this->id != ::std::this_thread::get_id()) {
            using lock_again = decltype([](auto p) { p->lock(); });
            ::std::unique_ptr<decltype(guard), lock_again> relock(&guard);
            relock->unlock();
            while (this->state->executing)
                ;
        }
        for (auto n = &this->state->callbacks; *n; n = &this->next) {
            if (*n == this) {
                *n = this->next;
                break;
            }
        }
    }
}

inline auto beman::execution::detail::stop_callback_base::call() -> void { this->do_call(); }

inline beman::execution::stop_token::stop_token(::std::shared_ptr<::beman::execution::detail::stop_state> st)
    : state(::std::move(st)) {}

inline auto beman::execution::stop_token::swap(stop_token& other) noexcept -> void { this->state.swap(other.state); }

inline auto beman::execution::stop_token::stop_requested() const noexcept -> bool {
    return this->state && this->state->stop_requested;
}

inline auto beman::execution::stop_token::stop_possible() const noexcept -> bool {
    return this->state && this->state->stop_possible();
}

// ----------------------------------------------------------------------------

inline beman::execution::stop_source::stop_source() { ++this->state->sources; }

inline beman::execution::stop_source::stop_source(::beman::execution::nostopstate_t) noexcept : state() {}

inline beman::execution::stop_source::stop_source(const stop_source& other) : state(other.state) {
    ++this->state->sources;
}

inline auto beman::execution::stop_source::operator=(const stop_source& other) -> stop_source& {
    stop_source(other).swap(*this);
    return *this;
}

inline beman::execution::stop_source::~stop_source() { this->state && --this->state->sources; }

inline auto beman::execution::stop_source::swap(::beman::execution::stop_source& other) noexcept -> void {
    this->state.swap(other.state);
}

inline auto beman::execution::stop_source::get_token() const -> stop_token { return stop_token{this->state}; }

inline auto beman::execution::stop_source::stop_requested() const noexcept -> bool {
    return this->state && this->state->stop_requested;
}

inline auto beman::execution::stop_source::stop_possible() const noexcept -> bool { return true && this->state; }

inline auto beman::execution::stop_source::request_stop() noexcept -> bool {
    using release    = decltype([](auto p) { *p = false; });
    using lock_again = decltype([](auto p) { p->lock(); });

    if (this->state && not this->state->stop_requested.exchange(true)) {
        ::std::unique_lock guard(this->state->lock);
        while (this->state->callbacks) {
            auto front = ::std::exchange(this->state->callbacks, this->state->callbacks->next);
            ::std::unique_ptr<::std::atomic<bool>, release> reset(&state->executing);
            *reset    = true;
            front->id = ::std::this_thread::get_id();
            ::std::unique_ptr<decltype(guard), lock_again> relock(&guard);
            relock->unlock();
            front->call();
        }
        return true;
    }
    return false;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Token>
concept decayed_stoppable_token = ::beman::execution::stoppable_token<::std::decay_t<Token>>;
}
namespace beman::execution {
export struct get_stop_token_t {
    template <typename Object>
        requires requires(Object&& object, const get_stop_token_t& tag) {
            { ::std::as_const(object).query(tag) } noexcept -> ::beman::execution::detail::decayed_stoppable_token;
        }
    auto operator()(Object&& object) const noexcept {
        return ::std::as_const(object).query(*this);
    }

    template <typename Object>
    auto operator()(Object&&) const noexcept -> ::beman::execution::never_stop_token {
        return {};
    }

    constexpr auto query(const ::beman::execution::forwarding_query_t&) const noexcept -> bool { return true; }
};

export inline constexpr get_stop_token_t get_stop_token{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_env_t {
    template <typename Object>
        requires(not requires(::std::add_const_t<::std::remove_cvref_t<Object>>& object) { object.get_env(); } ||
                 ::beman::execution::detail::queryable<
                     std::remove_cvref_t<decltype(::std::declval<const ::std::remove_cvref_t<Object>&>().get_env())>>)
    auto operator()(Object&& object) const noexcept -> decltype(auto) {
        ::std::add_const_t<::std::remove_cvref_t<Object>>& obj{object};
        if constexpr (requires { obj.get_env(); }) {
            static_assert(noexcept(obj.get_env()), "get_env requires the expression to be noexcept");
            static_assert(::beman::execution::detail::queryable<std::remove_cvref_t<decltype(obj.get_env())>>,
                          "get_env requires the result type to be destructible");
            return obj.get_env();
        } else {
            return ::beman::execution::env<>{};
        }
    }
};

export inline constexpr get_env_t get_env{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Class template used to a specify a list of completion signatures
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * This class template is primarily used for type computations and objects of
 * any specializaion are empty. Objects may be created to return them from
 * functions used for type computations like get_completion_signatures(sender, env).
 */
export template <::beman::execution::detail::completion_signature...>
struct completion_signatures {};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T, typename Promise>
concept is_awaitable = requires(Promise& promise) {
    {
        ::beman::execution::detail::get_awaiter(::std::declval<T>(), promise)
    } -> ::beman::execution::detail::is_awaiter<Promise>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper class to get the result of a function which may be only called once.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Fun>
struct emplace_from {
    using type = ::beman::execution::detail::call_result_t<Fun>;
    Fun fun;

    explicit constexpr operator type() && noexcept(::beman::execution::detail::nothrow_callable<Fun>) {
        return ::std::move(fun)();
    }
};
template <typename Fun>
emplace_from(Fun&&) -> emplace_from<::std::remove_cvref_t<Fun>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct empty_variant {
    empty_variant() = delete;
};

template <typename... T>
struct variant_or_empty_helper;

template <>
struct variant_or_empty_helper<> {
    using type = ::beman::execution::detail::empty_variant;
};

template <typename... T>
struct variant_or_empty_helper {
    using type = ::beman::execution::detail::meta::unique<::std::variant<::std::decay_t<T>...>>;
};

template <typename... T>
using variant_or_empty = typename ::beman::execution::detail::variant_or_empty_helper<T...>::type;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Source>
concept stoppable_source = requires(Source& source, const Source& csource) {
    { csource.get_token() } -> ::beman::execution::stoppable_token;
    { csource.stop_possible() } noexcept -> ::std::same_as<bool>;
    { csource.stop_requested() } noexcept -> ::std::same_as<bool>;
    { source.request_stop() } -> ::std::same_as<bool>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct receiver_t {};

export template <typename Rcvr>
concept receiver =
    ::std::derived_from<typename ::std::remove_cvref_t<Rcvr>::receiver_concept, ::beman::execution::receiver_t> &&
    requires(const ::std::remove_cvref_t<Rcvr>& rcvr) {
        { ::beman::execution::get_env(rcvr) } -> ::beman::execution::detail::queryable;
    } && ::std::move_constructible<::std::remove_cvref_t<Rcvr>> &&
    ::std::constructible_from<::std::remove_cvref_t<Rcvr>, Rcvr> && (!::std::is_final_v<::std::remove_cvref_t<Rcvr>>);
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename>
struct valid_completion_signatures_helper : ::std::false_type {};
template <typename... Sigs>
struct valid_completion_signatures_helper<::beman::execution::completion_signatures<Sigs...>> : ::std::true_type {};

template <typename Signatures>
concept valid_completion_signatures = valid_completion_signatures_helper<Signatures>::value;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Determine the type of the environment associated with a type
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export template <typename T>
using env_of_t = decltype(::beman::execution::get_env(::std::declval<T>()));
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T, typename Context>
/*!
 * \brief Utility function use to move a possibly allocator aware object with an allocator from an environment.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
auto allocator_aware_move(T&& obj, Context&& context) noexcept -> decltype(auto) {
    try {
        if constexpr (requires { ::beman::execution::get_allocator(::beman::execution::get_env(context)); }) {
            if constexpr (decltype(::beman::execution::detail::is_product_type(obj))()) {
                return obj.make_from(::beman::execution::get_allocator(::beman::execution::get_env(context)),
                                     ::std::forward<T>(obj));
            } else {
                return ::std::make_obj_using_allocator<T>(
                    ::beman::execution::get_allocator(::beman::execution::get_env(context)), ::std::forward<T>(obj));
            }
        } else {
            return ::std::forward<T>(obj);
        }
    } catch (...) {
        ::std::terminate(); //-dk:TODO investigate if that can be avoided
    }
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename T>
using stop_token_of_t = ::std::remove_cvref_t<decltype(::beman::execution::get_stop_token(::std::declval<T>()))>;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Token>
concept unstoppable_token = ::beman::execution::stoppable_token<Token> &&
                            requires() { requires ::std::bool_constant<not Token::stop_possible()>::value; };
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T, typename Promise>
concept has_as_awaitable = requires(T&& obj, Promise& promise) {
    { ::std::forward<T>(obj).as_awaitable(promise) } -> ::beman::execution::detail::is_awaitable<Promise&>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
#if not defined(__clang__)
// The version of clang current (2024-09-01) installed on my Mac crashes
// with this code - thus, there is a work-around.
template <typename Receiver, typename Completions>
concept has_completions = requires(Completions* completions) {
    []<::beman::execution::detail::valid_completion_for<Receiver>... Signatures>(
        ::beman::execution::completion_signatures<Signatures...>*) {}(completions);
};
#else
template <typename, typename>
struct has_completions_aux;
template <typename Receiver, typename... Signature>
struct has_completions_aux<Receiver, ::beman::execution::completion_signatures<Signature...>> {
    static constexpr bool value =
        (::beman::execution::detail::valid_completion_for<Signature, Receiver> && ... && true);
};

template <typename Receiver, typename Completions>
concept has_completions = has_completions_aux<Receiver, Completions>::value;
#endif
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper type providing default implementations for basic_sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct default_impls {
    static constexpr auto get_attrs = [](const auto&, const auto&... child) noexcept -> decltype(auto) {
        if constexpr (1 == sizeof...(child))
            return (::beman::execution::detail::fwd_env(::beman::execution::get_env(child)), ...);
        else
            return ::beman::execution::env<>{};
    };
    static constexpr auto get_env = [](auto, auto&, const auto& receiver) noexcept -> decltype(auto) {
        return ::beman::execution::detail::fwd_env(::beman::execution::get_env(receiver));
    };
    static constexpr auto get_state =
        []<typename Sender, typename Receiver>(Sender&& sender, Receiver& receiver) noexcept -> decltype(auto) {
        auto&& data{[&sender]() -> decltype(auto) {
            if constexpr (requires {
                              sender.size();
                              sender.template get<1>();
                          })
                return sender.template get<1>();
            else
                return ::beman::execution::detail::get_sender_data(::std::forward<Sender>(sender)).data;
        }()};

        return ::beman::execution::detail::allocator_aware_move(::beman::execution::detail::forward_like<Sender>(data),
                                                                receiver);
    };
    static constexpr auto start = [](auto&, auto&, auto&... ops) noexcept -> void {
        (::beman::execution::start(ops), ...);
    };
    static constexpr auto complete = []<typename Index, typename Receiver, typename Tag, typename... Args>(
                                         Index, auto&, Receiver& receiver, Tag, Args&&... args) noexcept -> void
        requires ::beman::execution::detail::callable<Tag, Receiver, Args...>
    {
        static_assert(Index::value == 0);
        Tag()(::std::move(receiver), ::std::forward<Args>(args)...);
    };
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
// NOLINTBEGIN(bugprone-crtp-constructor-accessibility)
template <typename Derived>
struct with_await_transform {
    template <typename T>
    auto await_transform(T&& obj) noexcept -> T&& {
        return ::std::forward<T>(obj);
    }

    template <::beman::execution::detail::has_as_awaitable<Derived> T>
    auto await_transform(T&& obj) noexcept(noexcept(::std::forward<T>(obj).as_awaitable(::std::declval<Derived&>())))
        -> decltype(auto) {
        return ::std::forward<T>(obj).as_awaitable(static_cast<Derived&>(*this));
    }
};
// NOLINTEND(bugprone-crtp-constructor-accessibility)
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Receiver, typename Completions>
concept receiver_of =
    beman::execution::receiver<Receiver> && beman::execution::detail::has_completions<Receiver, Completions>;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename...>
concept always_true = true;

template <typename, typename>
struct same_tag;
template <typename Tag, typename R, typename... A>
struct same_tag<Tag, R(A...)> {
    static constexpr bool value = ::std::same_as<Tag, R>;
};
template <typename Tag>
struct bound_tag {
    using type = Tag;
    template <typename T>
    using predicate = ::beman::execution::detail::same_tag<Tag, T>;
};

template <typename, template <typename...> class>
struct gather_signatures_apply;
template <typename R, typename... A, template <typename...> class Transform>
    requires requires {
        typename ::beman::execution::detail::indirect_meta_apply<
            ::beman::execution::detail::always_true<R>>::template meta_apply<Transform, A...>;
    }
struct gather_signatures_apply<R(A...), Transform> {
    using type = typename ::beman::execution::detail::indirect_meta_apply<
        ::beman::execution::detail::always_true<R>>::template meta_apply<Transform, A...>;
};

template <::beman::execution::detail::valid_completion_signatures,
          template <typename...> class,
          template <typename...> class>
struct gather_signatures_helper;

template <typename... Signatures, template <typename...> class Tuple, template <typename...> class Variant>
    requires requires {
        requires always_true<typename ::beman::execution::detail::gather_signatures_apply<Signatures, Tuple>::type...>;
    } && requires {
        typename ::beman::execution::detail::indirect_meta_apply<
            always_true<typename ::beman::execution::detail::gather_signatures_apply<Signatures, Tuple>::type...>>::
            template meta_apply<
                Variant,
                typename ::beman::execution::detail::gather_signatures_apply<Signatures, Tuple>::type...>;
    }
struct gather_signatures_helper<::beman::execution::completion_signatures<Signatures...>, Tuple, Variant> {
    using type = typename ::beman::execution::detail::indirect_meta_apply<
        always_true<typename ::beman::execution::detail::gather_signatures_apply<Signatures, Tuple>::type...>>::
        template meta_apply<Variant,
                            typename ::beman::execution::detail::gather_signatures_apply<Signatures, Tuple>::type...>;
};

template <typename Tag,
          ::beman::execution::detail::valid_completion_signatures signatures,
          template <typename...> class Tuple,
          template <typename...> class Variant>
    requires requires {
        typename ::beman::execution::detail::gather_signatures_helper<
            ::beman::execution::detail::meta::filter_tag<::beman::execution::detail::same_tag, Tag, signatures>,
            Tuple,
            Variant>::type;
    }
using gather_signatures = typename ::beman::execution::detail::gather_signatures_helper<
    ::beman::execution::detail::meta::filter_tag<::beman::execution::detail::same_tag, Tag, signatures>,
    Tuple,
    Variant>::type;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief A helper promise type with an associated environment
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Env>
struct env_promise : ::beman::execution::detail::with_await_transform<Env> {
    auto get_return_object() noexcept -> void;
    auto initial_suspend() noexcept -> ::std::suspend_always;
    auto final_suspend() noexcept -> ::std::suspend_always;
    auto unhandled_exception() noexcept -> void;
    auto return_void() noexcept -> void;
    auto unhandled_stopped() noexcept -> ::std::coroutine_handle<>;
    auto get_env() const noexcept -> const Env&;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Tag>
struct impls_for : ::beman::execution::detail::default_impls {};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Receiver>
struct operation_state_task;

template <typename Receiver>
struct connect_awaitable_promise;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

template <typename Receiver>
struct beman::execution::detail::connect_awaitable_promise
    : ::beman::execution::detail::with_await_transform<connect_awaitable_promise<Receiver>> {
    connect_awaitable_promise(auto&&, Receiver& rcvr) noexcept : receiver(rcvr) {}
    auto              initial_suspend() noexcept -> ::std::suspend_always { return {}; }
    [[noreturn]] auto final_suspend() noexcept -> ::std::suspend_always { ::std::terminate(); }
    [[noreturn]] auto unhandled_exception() noexcept -> void { ::std::terminate(); }
    [[noreturn]] auto return_void() noexcept -> void { ::std::terminate(); }

    auto unhandled_stopped() noexcept -> ::std::coroutine_handle<> {
        ::beman::execution::set_stopped(::std::move(this->receiver));
        return ::std::noop_coroutine();
    }

    auto get_env() const noexcept -> ::beman::execution::env_of_t<Receiver> {
        return ::beman::execution::get_env(this->receiver);
    }

    auto get_return_object() noexcept -> ::beman::execution::detail::operation_state_task<Receiver>;

  private:
    Receiver& receiver;
};

// ----------------------------------------------------------------------------

template <typename Receiver>
struct beman::execution::detail::operation_state_task {
    using operation_state_concept = ::beman::execution::operation_state_t;
    using promise_type            = ::beman::execution::detail::connect_awaitable_promise<Receiver>;

    explicit operation_state_task(::std::coroutine_handle<> hndl) noexcept : handle(hndl) {}
    operation_state_task(const operation_state_task&) = delete;
    operation_state_task(operation_state_task&& other) noexcept : handle(::std::exchange(other.handle, {})) {}
    ~operation_state_task() {
        if (this->handle)
            this->handle.destroy();
    }
    auto operator=(operation_state_task&&) -> operation_state_task&      = delete;
    auto operator=(const operation_state_task&) -> operation_state_task& = delete;

    auto start() & noexcept -> void { this->handle.resume(); }

    ::std::coroutine_handle<> handle;
};

// ----------------------------------------------------------------------------

template <typename Receiver>
auto beman::execution::detail::connect_awaitable_promise<Receiver>::get_return_object() noexcept
    -> ::beman::execution::detail::operation_state_task<Receiver> {
    return ::beman::execution::detail::operation_state_task<Receiver>(
        std::coroutine_handle<connect_awaitable_promise>::from_promise(*this));
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct sender_t {};
} // namespace beman::execution
namespace beman::execution::detail {
template <typename Sender>
concept is_sender = ::std::derived_from<typename Sender::sender_concept, ::beman::execution::sender_t>;

template <typename Sender>
concept enable_sender =
    ::beman::execution::detail::is_sender<Sender> ||
    ::beman::execution::detail::is_awaitable<Sender,
                                             ::beman::execution::detail::env_promise<::beman::execution::env<>>>;
} // namespace beman::execution::detail
namespace beman::execution {
export template <typename Sender>
concept sender = ::beman::execution::detail::enable_sender<::std::remove_cvref_t<Sender>> &&
                 requires(const ::std::remove_cvref_t<Sender>& sndr) {
                     { ::beman::execution::get_env(sndr) } -> ::beman::execution::detail::queryable;
                 } && ::std::move_constructible<::std::remove_cvref_t<Sender>> &&
                 ::std::constructible_from<::std::remove_cvref_t<Sender>, Sender>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief A helper template used determine the completion signature for type T which may be void
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename T>
struct awaiter_set_value {
    using type = ::beman::execution::set_value_t(T);
};
/*!
 * \brief Specialization for awaiter_set_value when the type is void
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <>
struct awaiter_set_value<void> {
    using type = ::beman::execution::set_value_t();
};

/*!
 * \brief A helper template used to determine the completion signature matching an awaiter
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Awaiter, typename Receiver>
using awaiter_completion_signatures = ::beman::execution::completion_signatures<
    typename ::beman::execution::detail::awaiter_set_value<::beman::execution::detail::await_result_type<
        Awaiter,
        ::beman::execution::detail::connect_awaitable_promise<Receiver>>>::type,
    ::beman::execution::set_error_t(::std::exception_ptr),
    ::beman::execution::set_stopped_t()>;

/*!
 * \brief A helper function used to connect an awaiter to a receiver
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Awaiter, ::beman::execution::receiver Receiver>
auto connect_awaitable(Awaiter awaiter, Receiver receiver)
    -> ::beman::execution::detail::operation_state_task<Receiver>
    requires ::beman::execution::
        receiver_of<Receiver, ::beman::execution::detail::awaiter_completion_signatures<Awaiter, Receiver>>
{
    // NOTE: suspened_complete(...) is co_await to make sure that the
    //    coroutine is suspended at the point when set_*(...) is called.
    using result_type =
        ::beman::execution::detail::await_result_type<Awaiter,
                                                      ::beman::execution::detail::connect_awaitable_promise<Receiver>>;

    ::std::exception_ptr ep;
    try {
        if constexpr (std::same_as<void, result_type>) {
            co_await ::std::move(awaiter);
            co_await ::beman::execution::detail::suspend_complete(::beman::execution::set_value,
                                                                  ::std::move(receiver));
        } else {
            co_await ::beman::execution::detail::suspend_complete(
                ::beman::execution::set_value, ::std::move(receiver), co_await ::std::move(awaiter));
        }
    } catch (...) {
        ep = ::std::current_exception();
    }
    co_await ::beman::execution::detail::suspend_complete(::beman::execution::set_error, ::std::move(receiver), ep);
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Receiver>
using state_type = ::std::decay_t<::beman::execution::detail::call_result_t<
    decltype(::beman::execution::detail::impls_for<::beman::execution::tag_of_t<Sender>>::get_state),
    Sender,
    Receiver&>>;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct schedule_t {
    template <typename Scheduler>
        requires(not requires(Scheduler&& sched) {
                    { ::std::forward<Scheduler>(sched).schedule() } -> ::beman::execution::sender;
                })
    auto operator()(Scheduler&& sched) const =
        BEMAN_EXECUTION_DELETE("the scheduler needs a schedule() member returning a sender");

    template <typename Scheduler>
        requires requires(Scheduler&& sched) {
            { ::std::forward<Scheduler>(sched).schedule() } -> ::beman::execution::sender;
        }
    auto operator()(Scheduler&& sched) const noexcept(noexcept(std::forward<Scheduler>(sched).schedule())) {
        return std::forward<Scheduler>(sched).schedule();
    }
};

export inline constexpr ::beman::execution::schedule_t schedule{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail::pipeable {
struct sender_adaptor_closure_base {};
} // namespace beman::execution::detail::pipeable

namespace beman::execution {
// NOLINTBEGIN(bugprone-crtp-constructor-accessibility)
export template <typename>
struct sender_adaptor_closure : ::beman::execution::detail::pipeable::sender_adaptor_closure_base {};
// NOLINTEND(bugprone-crtp-constructor-accessibility)

} // namespace beman::execution

namespace beman::execution::detail {
template <typename Closure>
concept is_sender_adaptor_closure =
    ::std::derived_from<::std::decay_t<Closure>, ::beman::execution::sender_adaptor_closure<::std::decay_t<Closure>>>;
}

namespace beman::execution::detail::pipeable {
export template <::beman::execution::sender Sender, typename Adaptor>
    requires(!::beman::execution::sender<Adaptor>) &&
            ::std::derived_from<::std::decay_t<Adaptor>,
                                ::beman::execution::sender_adaptor_closure<::std::decay_t<Adaptor>>> &&
            requires(Sender&& sender, Adaptor&& adaptor) {
                { adaptor(::std::forward<Sender>(sender)) } -> ::beman::execution::sender;
            }
auto operator|(Sender&& sender, Adaptor&& adaptor) {
    return adaptor(::std::forward<Sender>(sender));
}
} // namespace beman::execution::detail::pipeable

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Tag>
concept sender_for = ::beman::execution::sender<Sender> && ::std::same_as<::beman::execution::tag_of_t<Sender>, Tag>;
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Env>
concept sender_has_affine_on =
    beman::execution::sender<::std::remove_cvref_t<Sender>> && requires(Sender&& sndr, const Env& env) {
        sndr.template get<0>();
        { sndr.template get<0>().affine_on(std::forward<Sender>(sndr), env) } -> ::beman::execution::sender;
    };
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Domain type used when no domain is specified explicitly.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * The default_domain tries to delegate any of the transformations to a member
 * function of the
 * tag type of the passed sender. If there is no corresponding member function
 * no transformation is applied.
 */
export struct default_domain {
    template <::beman::execution::sender Sender, ::beman::execution::detail::queryable... Env>
        requires(sizeof...(Env) <= 1) && requires(Sender&& sender, Env&&... env) {
            ::beman::execution::tag_of_t<Sender>().transform_sender(::std::forward<Sender>(sender),
                                                                    ::std::forward<Env>(env)...);
        }
    static constexpr auto transform_sender(Sender&& sender, Env&&... env) noexcept(
        noexcept(::beman::execution::tag_of_t<Sender>().transform_sender(::std::forward<Sender>(sender),
                                                                         ::std::forward<Env>(env)...)))
        -> ::beman::execution::sender decltype(auto) {
        return ::beman::execution::tag_of_t<Sender>().transform_sender(::std::forward<Sender>(sender),
                                                                       ::std::forward<Env>(env)...);
    }

    template <::beman::execution::sender Sender, ::beman::execution::detail::queryable... Env>
        requires(sizeof...(Env) <= 1) && (not requires(Sender&& sender, Env&&... env) {
                    ::beman::execution::tag_of_t<Sender>().transform_sender(::std::forward<Sender>(sender),
                                                                            ::std::forward<Env>(env)...);
                })
    static constexpr auto transform_sender(Sender&& sender,
                                           Env&&...) noexcept(noexcept(::std::forward<Sender>(sender)))
        -> ::beman::execution::sender decltype(auto) {
        return ::std::forward<Sender>(sender);
    }

    template <::beman::execution::sender Sender, ::beman::execution::detail::queryable Env>
        requires requires(Sender&& sender, Env&& env) {
            ::beman::execution::tag_of_t<Sender>().transform_env(::std::forward<Sender>(sender),
                                                                 ::std::forward<Env>(env));
        }
    static constexpr auto transform_env(Sender&& sender, Env&& env) noexcept -> ::beman::execution::detail::queryable
        decltype(auto) {
        return ::beman::execution::tag_of_t<Sender>().transform_env(::std::forward<Sender>(sender),
                                                                    ::std::forward<Env>(env));
    }

    template <::beman::execution::sender Sender, ::beman::execution::detail::queryable Env>
        requires(not requires(Sender&& sender, Env&& env) {
            ::beman::execution::tag_of_t<Sender>().transform_env(::std::forward<Sender>(sender),
                                                                 ::std::forward<Env>(env));
        })
    static constexpr auto transform_env(Sender&&, Env&& env) noexcept -> ::beman::execution::detail::queryable
        decltype(auto) {
        return static_cast<Env>(::std::forward<Env>(env));
    }

    template <typename Tag, ::beman::execution::sender Sender, typename... Args>
        requires requires(Sender&& sender, Args&&... args) {
            Tag().apply_sender(::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
        }
    static constexpr auto apply_sender(Tag, Sender&& sender, Args&&... args) noexcept(noexcept(
        Tag().apply_sender(::std::forward<Sender>(sender), ::std::forward<Args>(args)...))) -> decltype(auto) {
        return Tag().apply_sender(::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
    }
};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <::beman::execution::sender Sndr, typename Ev>
auto spawn_get_allocator(const Sndr& sndr, const Ev& ev) {
    if constexpr (requires { ::beman::execution::get_allocator(ev); }) {
        return ::std::pair(::beman::execution::get_allocator(ev), ev);
    } else if constexpr (requires { ::beman::execution::get_allocator(::beman::execution::get_env(sndr)); }) {
        auto alloc{::beman::execution::get_allocator(::beman::execution::get_env(sndr))};
        return ::std::pair(alloc,
                           ::beman::execution::detail::join_env(
                               ::beman::execution::prop(::beman::execution::get_allocator, alloc), ev));
    } else {
        return ::std::pair(::std::allocator<void>{}, ev);
    }
}

} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Class template used to present the receiver and operation state for library senders.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Receiver>
struct basic_state {
    basic_state(Sender&& sender, Receiver&& rcvr) noexcept(true)
        : receiver(::std::move(rcvr)),
          state(::beman::execution::detail::impls_for<::beman::execution::tag_of_t<Sender>>::get_state(
              ::std::forward<Sender>(sender), this->receiver)) {}

    Receiver                                                 receiver;
    ::beman::execution::detail::state_type<Sender, Receiver> state;
};
template <typename Sender, typename Receiver>
basic_state(Sender&&, Receiver&&) -> basic_state<Sender&&, Receiver>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper alias to determine the environment type associated with sender in a basic_sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Index, typename Sender, typename Receiver>
using env_type = ::beman::execution::detail::call_result_t<
    decltype(::beman::execution::detail::impls_for<::beman::execution::tag_of_t<Sender>>::get_env),
    Index,
    ::beman::execution::detail::state_type<Sender, Receiver>&,
    const Receiver&>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Auxiliary concept used to break cycle for scheduler concept.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 * \concept almost_scheduler
 */
template <typename Scheduler>
concept almost_scheduler = ::std::derived_from<typename ::std::remove_cvref_t<Scheduler>::scheduler_concept,
                                               ::beman::execution::scheduler_t> &&
                           ::beman::execution::detail::queryable<Scheduler> &&
                           requires(Scheduler&& sched) {
                               {
                                   ::beman::execution::schedule(::std::forward<Scheduler>(sched))
                               } -> ::beman::execution::sender;
                           } && ::std::equality_comparable<::std::remove_cvref_t<Scheduler>> &&
                           ::std::copy_constructible<::std::remove_cvref_t<Scheduler>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) &&
            requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            } &&
            (::std::same_as<::std::remove_cvref_t<Sender>,
                            std::remove_cvref_t<decltype(::std::declval<Domain>().transform_sender(
                                ::std::declval<Sender>(), ::std::declval<const Env&>()...))>>)
constexpr auto transform_sender(Domain, Sender&& sender, const Env&...) noexcept -> ::beman::execution::sender auto {
    return ::std::forward<Sender>(sender);
}

template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) &&
            requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            } &&
            (!::std::same_as<::std::remove_cvref_t<Sender>,
                             std::remove_cvref_t<decltype(::std::declval<Domain>().transform_sender(
                                 ::std::declval<Sender>(), ::std::declval<const Env&>()...))>>)
constexpr auto transform_sender(Domain dom, Sender&& sender, const Env&... env) noexcept -> ::beman::execution::sender
    decltype(auto) {
    return ::beman::execution::detail::transform_sender(
        dom, dom.transform_sender(::std::forward<Sender>(sender), env...), env...);
}

template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(not requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            }) && ::std::same_as<::std::remove_cvref_t<Sender>,
                                 ::std::remove_cvref_t<decltype(::beman::execution::default_domain{}.transform_sender(
                                     ::std::declval<Sender>(), ::std::declval<Env>()...))>>
constexpr auto
    transform_sender(Domain, Sender&& sender, const Env&...) noexcept(noexcept(::std::forward<Sender>(sender)))
        -> ::beman::execution::sender auto {
    return sender;
}

template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(not requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            }) &&
            (!::std::same_as<::std::remove_cvref_t<Sender>,
                             ::std::remove_cvref_t<decltype(::beman::execution::default_domain{}.transform_sender(
                                 ::std::declval<Sender>(), ::std::declval<Env>()...))>>)
constexpr auto transform_sender(Domain dom, Sender&& sender, const Env&... env) noexcept(noexcept(
    ::beman::execution::default_domain{}.transform_sender(::std::declval<Sender>(), ::std::declval<Env>()...)))
    -> ::beman::execution::sender decltype(auto) {
    return ::beman::execution::detail::transform_sender(
        dom, ::beman::execution::default_domain{}.transform_sender(::std::forward<Sender>(sender), env...), env...);
}
} // namespace beman::execution::detail

namespace beman::execution {
export template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) &&
            requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            } &&
            (::std::same_as<::std::remove_cvref_t<Sender>,
                            std::remove_cvref_t<decltype(::std::declval<Domain>().transform_sender(
                                ::std::declval<Sender>(), ::std::declval<const Env&>()...))>>)
constexpr auto transform_sender(Domain, Sender&& sender, const Env&...) noexcept -> ::beman::execution::sender
    decltype(auto) {
    return ::std::forward<Sender>(sender);
}

export template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) &&
            requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            } &&
            (!::std::same_as<::std::remove_cvref_t<Sender>,
                             std::remove_cvref_t<decltype(::std::declval<Domain>().transform_sender(
                                 ::std::declval<Sender>(), ::std::declval<const Env&>()...))>>)
constexpr auto transform_sender(Domain dom, Sender&& sender, const Env&... env) noexcept -> ::beman::execution::sender
    auto {
    return ::beman::execution::detail::transform_sender(
        dom, dom.transform_sender(::std::forward<Sender>(sender), env...), env...);
}

export template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) && (not requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            }) &&
            ::std::same_as<::std::remove_cvref_t<Sender>,
                           ::std::remove_cvref_t<decltype(::beman::execution::default_domain{}.transform_sender(
                               ::std::declval<Sender>(), ::std::declval<Env>()...))>>
constexpr auto
    transform_sender(Domain, Sender&& sender, const Env&...) noexcept(noexcept(::std::forward<Sender>(sender)))
        -> ::beman::execution::sender decltype(auto) {
    return ::std::forward<Sender>(sender);
}

export template <typename Domain, ::beman::execution::sender Sender, typename... Env>
    requires(sizeof...(Env) < 2) && (not requires(Domain dom, Sender&& sender, const Env&... env) {
                dom.transform_sender(::std::forward<Sender>(sender), env...);
            }) &&
            (!::std::same_as<::std::remove_cvref_t<Sender>,
                             ::std::remove_cvref_t<decltype(::beman::execution::default_domain{}.transform_sender(
                                 ::std::declval<Sender>(), ::std::declval<Env>()...))>>)
constexpr auto transform_sender(Domain dom, Sender&& sender, const Env&... env) noexcept(
    noexcept(::beman::execution::detail::transform_sender(
        dom,
        ::beman::execution::default_domain{}.transform_sender(::std::declval<Sender>(), ::std::declval<Env>()...),
        env...))) -> ::beman::execution::sender decltype(auto) {
    return ::beman::execution::detail::transform_sender(
        dom, ::beman::execution::default_domain{}.transform_sender(::std::forward<Sender>(sender), env...), env...);
}
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Adaptor, typename... T>
struct sender_adaptor : ::beman::execution::detail::product_type<::std::decay_t<Adaptor>, ::std::decay_t<T>...>,
                        ::beman::execution::sender_adaptor_closure<sender_adaptor<Adaptor, T...>> {
    template <::beman::execution::sender Sender, typename Self>
    static auto apply(Sender&& sender, Self&& self) {
        return [&self, &sender]<::std::size_t... I>(::std::index_sequence<I...>) {
            auto&& fun(self.template get<0>());
            return fun(::std::forward<Sender>(sender),
                       ::beman::execution::detail::forward_like<Self>(self.template get<I + 1>())...);
        }(::std::make_index_sequence<sender_adaptor::size() - 1u>{});
    }
    template <::beman::execution::sender Sender>
    auto operator()(Sender&& sender) {
        return apply(::std::forward<Sender>(sender), ::std::move(*this));
    }
    template <::beman::execution::sender Sender>
    auto operator()(Sender&& sender) const {
        return apply(::std::forward<Sender>(sender), *this);
    }
};
template <typename... T>
sender_adaptor(T&&...) -> sender_adaptor<T...>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Scheduler>
class sched_env {
  private:
    Scheduler sched;

  public:
    template <typename S>
    explicit sched_env(S sch) : sched(::std::move(sch)) {}

    auto query(const ::beman::execution::get_scheduler_t&) const noexcept { return this->sched; }
    auto query(const ::beman::execution::get_domain_t& q) const noexcept {
        if constexpr (requires { this->sched.query(q); })
            return this->sched.query(q);
        else
            return ::beman::execution::default_domain{};
    }
};

template <typename Scheduler>
sched_env(Scheduler&&) -> sched_env<::std::remove_cvref_t<Scheduler>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Function used to transform a sender and its arguments for a domain.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export template <typename Domain, typename Tag, ::beman::execution::sender Sender, typename... Args>
    requires requires(Domain domain, Tag tag, Sender&& sender, Args&&... args) {
        domain.apply_sender(Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
    }
constexpr auto apply_sender(Domain domain, Tag, Sender&& sender, Args&&... args) noexcept(noexcept(
    domain.apply_sender(Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...))) -> decltype(auto) {
    return domain.apply_sender(Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
}

/*!
 * \brief Default function used to transform a second and its arguments.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
template <typename Domain, typename Tag, ::beman::execution::sender Sender, typename... Args>
    requires(not requires(Domain domain, Tag tag, Sender&& sender, Args&&... args) {
                domain.apply_sender(Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
            }) && requires(Tag tag, Sender&& sender, Args&&... args) {
        beman::execution::default_domain().apply_sender(
            Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
    }
constexpr auto apply_sender(Domain, Tag, Sender&& sender, Args&&... args) noexcept(
    noexcept(beman::execution::default_domain().apply_sender(Tag(),
                                                             ::std::forward<Sender>(sender),
                                                             ::std::forward<Args>(args)...))) -> decltype(auto) {
    return beman::execution::default_domain().apply_sender(
        Tag(), ::std::forward<Sender>(sender), ::std::forward<Args>(args)...);
}

} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Env>
concept nested_sender_has_affine_on = requires(Sender&& sndr, const Env& env) {
    { sndr.template get<2>() } -> ::beman::execution::detail::sender_has_affine_on<Env>;
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Class template used as receiver for child completions for library senders.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Receiver, typename Index>
    requires ::beman::execution::detail::
        valid_specialization<::beman::execution::detail::env_type, Index, Sender, Receiver>
    struct basic_receiver {
    friend struct ::beman::execution::get_env_t;
    friend struct ::beman::execution::set_error_t;
    friend struct ::beman::execution::set_stopped_t;
    friend struct ::beman::execution::set_value_t;

    using receiver_concept                = ::beman::execution::receiver_t;
    using tag_t                           = ::beman::execution::tag_of_t<Sender>;
    using state_t                         = ::beman::execution::detail::state_type<Sender, Receiver>;
    static constexpr const auto& complete = ::beman::execution::detail::impls_for<tag_t>::complete;
    ::beman::execution::detail::basic_state<Sender, Receiver>* op{};

  private:
    template <typename... Args>
    auto set_value(Args&&... args) && noexcept -> void
        requires ::beman::execution::detail::
            callable<decltype(complete), Index, state_t&, Receiver&, ::beman::execution::set_value_t, Args...>
    {
        this->complete(Index(),
                       this->op->state,
                       this->op->receiver,
                       ::beman::execution::set_value_t(),
                       ::std::forward<Args>(args)...);
    }

    template <typename Error>
    auto set_error(Error&& error) && noexcept -> void
        requires ::beman::execution::detail::
            callable<decltype(complete), Index, state_t&, Receiver&, ::beman::execution::set_error_t, Error>
    {
        this->complete(Index(),
                       this->op->state,
                       this->op->receiver,
                       ::beman::execution::set_error_t(),
                       ::std::forward<Error>(error));
    }

    auto set_stopped() && noexcept -> void
        requires ::beman::execution::detail::
            callable<decltype(complete), Index, state_t&, Receiver&, ::beman::execution::set_stopped_t>
    {
        this->complete(Index(), this->op->state, this->op->receiver, ::beman::execution::set_stopped_t());
    }

    auto get_env() const noexcept -> ::beman::execution::detail::env_type<Index, Sender, Receiver> {
        return ::beman::execution::detail::impls_for<tag_t>::get_env(Index(), this->op->state, this->op->receiver);
    }
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Tag>
struct get_completion_scheduler_t;

template <typename Tag>
struct get_completion_scheduler_t : ::beman::execution::forwarding_query_t {
    template <typename Env>
        requires(not requires(const get_completion_scheduler_t& self, const ::std::remove_cvref_t<Env>& env) {
                    env.query(self);
                })
    auto operator()(Env&&) const noexcept =
        BEMAN_EXECUTION_DELETE("The environment needs a query(get_completion_scheduler_t) member");

    template <typename Env>
        requires(requires(const get_completion_scheduler_t& self, const ::std::remove_cvref_t<Env>& env) {
                    env.query(self);
                } && (not requires(const get_completion_scheduler_t& self, const ::std::remove_cvref_t<Env>& env) {
                     { env.query(self) } noexcept;
                 }))
    auto operator()(Env&&) const noexcept =
        BEMAN_EXECUTION_DELETE("The environment's query(get_completion_scheduler_t) has to be noexcept");

    template <typename Env>
        requires(
                    requires(const get_completion_scheduler_t& self, const ::std::remove_cvref_t<Env>& env) {
                        env.query(self);
                    } &&
                    requires(const get_completion_scheduler_t& self, const ::std::remove_cvref_t<Env>& env) {
                        { env.query(self) } noexcept;
                    } &&
                    (not requires(const get_completion_scheduler_t&                                  self,
                                  const get_completion_scheduler_t<::beman::execution::set_value_t>& value_self,
                                  const ::std::remove_cvref_t<Env>&                                  env) {
                        { env.query(self) } noexcept -> ::beman::execution::detail::almost_scheduler;
                        {
                            ::beman::execution::get_env(::beman::execution::schedule(env.query(self)))
                                .query(value_self)
                        } -> ::beman::execution::detail::decayed_same_as<decltype(env.query(self))>;
                    }))
    auto operator()(Env&&) const noexcept =
        BEMAN_EXECUTION_DELETE("The environment's query(get_completion_scheduler_t) has to return a scheduler");

    template <typename Env>
        requires requires(const get_completion_scheduler_t&                                  self,
                          const get_completion_scheduler_t<::beman::execution::set_value_t>& value_self,
                          const ::std::remove_cvref_t<Env>&                                  env) {
            { env.query(self) } noexcept -> ::beman::execution::detail::almost_scheduler;
            {
                ::beman::execution::get_env(::beman::execution::schedule(env.query(self))).query(value_self)
            } -> ::beman::execution::detail::decayed_same_as<decltype(env.query(self))>;
        }
    auto operator()(Env&& env) const noexcept {
        return ::std::as_const(env).query(*this);
    }
};

export template <::beman::execution::detail::completion_tag Tag>
inline constexpr get_completion_scheduler_t<Tag> get_completion_scheduler{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Scheduler>
concept scheduler = ::beman::execution::detail::almost_scheduler<Scheduler> && requires(Scheduler&& sched) {
    {
        ::beman::execution::get_completion_scheduler<::beman::execution::set_value_t>(
            ::beman::execution::get_env(::beman::execution::schedule(::std::forward<Scheduler>(sched))))
    } -> ::beman::execution::detail::decayed_same_as<Scheduler>;
};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

template <typename Scheduler>
class sched_attrs {
  private:
    Scheduler sched;

  public:
    template <typename S>
        requires(!::std::same_as<sched_attrs, ::std::remove_cvref_t<S>>)
    explicit sched_attrs(S&& s) : sched(::std::forward<S>(s)) {}

    template <typename Tag>
    auto query(const ::beman::execution::get_completion_scheduler_t<Tag>&) const noexcept {
        return this->sched;
    }

    template <typename T = bool>
        requires requires(Scheduler&& s) { s.query(::beman::execution::get_domain); }
    auto query(const ::beman::execution::get_domain_t& q, T = true) const noexcept {
        return this->sched.query(q);
    }
};

template <typename Scheduler>
sched_attrs(Scheduler&&) -> sched_attrs<::std::remove_cvref_t<Scheduler>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct completion_domain_undefined {};
template <typename, typename>
struct completion_domain_merge {};
template <typename T>
struct completion_domain_merge<T, T> {
    using type = T;
};
template <typename T>
struct completion_domain_merge<completion_domain_undefined, T> {
    using type = T;
};
template <typename T>
struct completion_domain_merge<T, completion_domain_undefined> {
    using type = T;
};
template <>
struct completion_domain_merge<completion_domain_undefined, completion_domain_undefined> {
    using type = completion_domain_undefined;
};

/*!
 * \brief Get a sender's completion domain or the specified default.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Default = ::beman::execution::default_domain, typename Sender>
constexpr auto completion_domain(const Sender& sender) noexcept {

    static_assert(::beman::execution::sender<Sender>);
    constexpr auto get = []<typename Tag>(Tag, const Sender& sender) {
        if constexpr (requires {
                          ::beman::execution::get_domain(
                              ::beman::execution::get_completion_scheduler<Tag>(::beman::execution::get_env(sender)));
                      }) {
            return ::beman::execution::get_domain(
                ::beman::execution::get_completion_scheduler<Tag>(::beman::execution::get_env(sender)));
        } else {
            return completion_domain_undefined{};
        }
    };

    using type = typename completion_domain_merge<
        typename completion_domain_merge<decltype(get(::beman::execution::set_error, sender)),
                                         decltype(get(::beman::execution::set_stopped, sender))>::type,
        decltype(get(::beman::execution::set_value, sender))>::type;
    return ::std::conditional_t<::std::same_as<type, completion_domain_undefined>, Default, type>();
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_delegation_scheduler_t {
    template <typename Env>
        requires requires(Env&& env, const get_delegation_scheduler_t& g) {
            { ::std::as_const(env).query(g) } noexcept -> ::beman::execution::scheduler;
        }
    auto operator()(Env&& env) const noexcept {
        return ::std::as_const(env).query(*this);
    }
    constexpr auto query(const ::beman::execution::forwarding_query_t&) const noexcept -> bool { return true; }
};

export inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename T>
concept not_void = !::std::same_as<T, void>;

template <typename Tag>
struct get_domain_late_helper {
    template <typename Sender, typename Env>
    static constexpr auto get(const Sender& sender, const Env& env) noexcept {
        if constexpr (requires {
                          {
                              ::beman::execution::get_domain(::beman::execution::get_env(sender))
                          } -> ::beman::execution::detail::not_void;
                      })
            return ::beman::execution::get_domain(::beman::execution::get_env(sender));
        else if constexpr (requires {
                               {
                                   ::beman::execution::detail::completion_domain<void>(sender)
                               } -> ::beman::execution::detail::not_void;
                           })
            return ::beman::execution::detail::completion_domain<void>(sender);
        else if constexpr (requires {
                               { ::beman::execution::get_domain(env) } -> ::beman::execution::detail::not_void;
                           })
            return ::beman::execution::get_domain(env);
        else if constexpr (requires {
                               {
                                   ::beman::execution::get_domain(::beman::execution::get_scheduler(env))
                               } -> ::beman::execution::detail::not_void;
                           })
            return ::beman::execution::get_domain(::beman::execution::get_scheduler(env));
        else
            return ::beman::execution::default_domain();
    }
};
template <typename Sender, typename Env>
constexpr auto get_domain_late(const Sender& sender, const Env& env) noexcept {
    using tag_t = ::beman::execution::tag_of_t<Sender>;
    return ::beman::execution::detail::get_domain_late_helper<tag_t>::get(sender, env);
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender>
constexpr auto get_domain_early(const Sender& sender) noexcept {
    if constexpr (requires { ::beman::execution::get_domain(::beman::execution::get_env(sender)); })
        return decltype(::beman::execution::get_domain(::beman::execution::get_env(sender))){};
    else if constexpr (requires { ::beman::execution::detail::completion_domain(sender); })
        return decltype(::beman::execution::detail::completion_domain(sender)){};
    else
        return ::beman::execution::default_domain{};
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <::beman::execution::scheduler Scheduler>
using schedule_result_t = decltype(::beman::execution::schedule(::std::declval<Scheduler>()));
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export class run_loop {
  private:
    struct scheduler;

    struct env {
        run_loop* loop;

        template <typename Completion>
        auto query(const ::beman::execution::get_completion_scheduler_t<Completion>&) const noexcept -> scheduler {
            return {this->loop};
        }
    };

    struct opstate_base : ::beman::execution::detail::virtual_immovable {
        opstate_base* next{};
        virtual auto  execute() noexcept -> void = 0;
    };

    template <typename Receiver>
    struct opstate : opstate_base {
        using operation_state_concept = ::beman::execution::operation_state_t;

        run_loop* loop;
        Receiver  receiver;

        // NOLINTBEGIN(misc-no-recursion)
        template <typename R>
        opstate(run_loop* l, R&& rcvr) : loop(l), receiver(::std::forward<Receiver>(rcvr)) {}
        auto start() & noexcept -> void { this->loop->push_back(this); }
        // NOLINTEND(misc-no-recursion)
        auto execute() noexcept -> void override {
            using token = decltype(::beman::execution::get_stop_token(::beman::execution::get_env(this->receiver)));
            if constexpr (not ::beman::execution::unstoppable_token<token>) {
                if (::beman::execution::get_stop_token(::beman::execution::get_env(this->receiver)).stop_requested())
                    ::beman::execution::set_stopped(::std::move(this->receiver));
                else
                    ::beman::execution::set_value(::std::move(this->receiver));
            } else
                ::beman::execution::set_value(::std::move(this->receiver));
        }
    };
    struct sender {
        using sender_concept = ::beman::execution::sender_t;
        template <typename Env = ::beman::execution::env<>>
        auto get_completion_signatures(Env&& env) const noexcept {
            if constexpr (::beman::execution::unstoppable_token<decltype(::beman::execution::get_stop_token(env))>)
                return ::beman::execution::completion_signatures<::beman::execution::set_value_t()>{};
            else
                return ::beman::execution::completion_signatures<::beman::execution::set_value_t(),
                                                                 ::beman::execution::set_stopped_t()>{};
        }

        run_loop* loop;

        auto get_env() const noexcept -> env { return {this->loop}; }
        template <typename Receiver>
        auto connect(Receiver&& receiver) noexcept -> opstate<::std::decay_t<Receiver>> {
            return {this->loop, ::std::forward<Receiver>(receiver)};
        }
    };
    struct scheduler {
        using scheduler_concept = ::beman::execution::scheduler_t;

        run_loop* loop;

        auto schedule() noexcept -> sender { return {this->loop}; }
        auto operator==(const scheduler&) const -> bool = default;
    };

    enum class state : unsigned char { starting, running, finishing };

    state                     current_state{state::starting};
    ::std::mutex              mutex{};
    ::std::condition_variable condition{};
    opstate_base*             front{};
    opstate_base*             back{};

    auto push_back(opstate_base* item) noexcept -> void {
        //-dk:TODO run_loop::push_back should really be lock-free
        ::std::lock_guard guard(this->mutex);
        if (auto previous_back{::std::exchange(this->back, item)}) {
            previous_back->next = item;
        } else {
            this->front = item;
            this->condition.notify_one();
        }
    }
    auto pop_front() noexcept -> opstate_base* {
        //-dk:TODO run_loop::pop_front should really be lock-free
        ::std::unique_lock guard(this->mutex);
        this->condition.wait(guard, [this] { return this->front || this->current_state == state::finishing; });
        if (this->front == this->back)
            this->back = nullptr;
        return this->front ? ::std::exchange(this->front, this->front->next) : nullptr;
    }

  public:
    run_loop() noexcept       = default;
    run_loop(const run_loop&) = delete;
    run_loop(run_loop&&)      = delete;
    ~run_loop() {
        ::std::lock_guard guard(this->mutex);
        if (this->front != nullptr || this->current_state == state::running)
            ::std::terminate();
    }
    auto operator=(const run_loop&) -> run_loop& = delete;
    auto operator=(run_loop&&) -> run_loop&      = delete;

    auto get_scheduler() -> scheduler { return {this}; }

    auto run() -> void {
        if (::std::lock_guard guard(this->mutex);
            this->current_state != state::finishing &&
            state::running == ::std::exchange(this->current_state, state::running)) {
            ::std::terminate();
        }

        while (auto* op{this->pop_front()}) {
            op->execute();
        }
    }
    auto finish() -> void {
        {
            ::std::lock_guard guard(this->mutex);
            this->current_state = state::finishing;
        }
        this->condition.notify_one();
    }
};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export struct get_completion_signatures_t {
  private:
    template <typename Sender, typename Env>
    static auto get(Sender&& sender, Env&& env) noexcept {
        auto new_sender{[](auto&& sndr, auto&& e) -> decltype(auto) {
            auto domain{::beman::execution::detail::get_domain_late(sndr, e)};
            return ::beman::execution::transform_sender(domain, ::std::forward<Sender>(sndr), ::std::forward<Env>(e));
        }};

        using sender_type = ::std::remove_cvref_t<decltype(new_sender(sender, env))>;
        using decayed_env = ::std::remove_cvref_t<Env>;
        if constexpr (requires { new_sender(sender, env).get_completion_signatures(env); })
            return decltype(new_sender(sender, env).get_completion_signatures(env)){};
        else if constexpr (requires { typename sender_type::completion_signatures; })
            return typename sender_type::completion_signatures{};
        else if constexpr (::beman::execution::detail::
                               is_awaitable<sender_type, ::beman::execution::detail::env_promise<decayed_env>>) {
            using result_type =
                ::beman::execution::detail::await_result_type<sender_type,
                                                              ::beman::execution::detail::env_promise<decayed_env>>;
            if constexpr (::std::same_as<void, result_type>) {
                return ::beman::execution::completion_signatures<::beman::execution::set_value_t(),
                                                                 ::beman::execution::set_error_t(::std::exception_ptr),
                                                                 ::beman::execution::set_stopped_t()>{};
            } else {
                return ::beman::execution::completion_signatures<::beman::execution::set_value_t(result_type),
                                                                 ::beman::execution::set_error_t(::std::exception_ptr),
                                                                 ::beman::execution::set_stopped_t()>{};
            }
        }
    }

  public:
    template <typename Sender, typename Env>
        requires(!::std::same_as<void,
                                 decltype(get_completion_signatures_t::get(::std::declval<Sender>(),
                                                                           ::std::declval<Env>()))>)
    auto operator()(Sender&& sender, Env&& env) const noexcept {
        return this->get(::std::forward<Sender>(sender), ::std::forward<Env>(env));
    }
};
export inline constexpr get_completion_signatures_t get_completion_signatures{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief The actual implementation of the connect customization point type
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct connect_t {
  private:
    template <typename Sender, typename Receiver>
    static auto make_new_sender(Sender&& sender, Receiver&& receiver)
        //-dk:TODO this noexcept needs to get confirmed/fixed
        noexcept(true) -> decltype(auto) {
        return ::beman::execution::transform_sender(
            decltype(::beman::execution::detail::get_domain_late(::std::forward<Sender>(sender),
                                                                 ::beman::execution::get_env(receiver))){},
            ::std::forward<Sender>(sender),
            ::beman::execution::get_env(receiver));
    }
    template <typename Sender, typename Receiver>
    static constexpr auto connect_noexcept() -> bool {
        if constexpr (requires {
                          make_new_sender(::std::declval<Sender>(), ::std::declval<Receiver>())
                              .connect(::std::declval<Receiver>());
                      }) {
            return noexcept(make_new_sender(::std::declval<Sender>(), ::std::declval<Receiver>())
                                .connect(::std::declval<Receiver>()));
        } else if constexpr (requires {
                                 ::beman::execution::detail::connect_awaitable(
                                     make_new_sender(::std::declval<Sender>(), ::std::declval<Receiver>()),
                                     ::std::declval<Receiver>());
                             }) {
            return noexcept(::beman::execution::detail::connect_awaitable(
                make_new_sender(::std::declval<Sender>(), ::std::declval<Receiver>()), ::std::declval<Receiver>()));
        }
        return true;
    }

  public:
    template <typename Sender, typename Receiver>
    auto operator()(Sender&& sender, Receiver&& receiver) const noexcept(connect_noexcept<Sender, Receiver>()) {
        auto new_sender = [&sender, &receiver]() -> decltype(auto) {
            return make_new_sender(::std::forward<Sender>(sender), ::std::forward<Receiver>(receiver));
        };

        if constexpr (requires { new_sender().connect(::std::forward<Receiver>(receiver)); }) {
            using state_type = decltype(new_sender().connect(::std::forward<Receiver>(receiver)));
            static_assert(::beman::execution::operation_state<state_type>);
            return new_sender().connect(::std::forward<Receiver>(receiver));
        } else if constexpr (requires {
                                 ::beman::execution::detail::connect_awaitable(new_sender(),
                                                                               ::std::forward<Receiver>(receiver));
                             }) {
            return ::beman::execution::detail::connect_awaitable(new_sender(), ::std::forward<Receiver>(receiver));
        } else {
            enum bad_sender {};
            static_assert(::std::same_as<bad_sender, decltype(new_sender())>,
                          "result from transform_sender has no suitable connect()");
        }
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
/*!
 * \brief Type of the connect customization point object.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export using connect_t = beman::execution::detail::connect_t;
/*!
 * \brief Customization point object used to connect a sender and a receiver.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `connect(sender, receiver)` returns the result of calling `sender.connect(receiver)`.
 * The returned object `state` is an `operation_state` object.
 */
export inline constexpr connect_t connect{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Sender, typename Env = ::beman::execution::env<>>
concept sender_in =
    ::beman::execution::sender<Sender> && ::beman::execution::detail::queryable<Env> &&
    requires(Sender&& sender, Env&& env) {
        {
            ::beman::execution::get_completion_signatures(::std::forward<Sender>(sender), ::std::forward<Env>(env))
        } -> ::beman::execution::detail::valid_completion_signatures;
    };
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Type alias to determine the operation state type returned from `connect()`.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export template <typename Sender, typename Receiver>
using connect_result_t = decltype(::beman::execution::connect(::std::declval<Sender>(), ::std::declval<Receiver>()));
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
inline constexpr struct stop_when_t {
    template <::beman::execution::sender Sndr, ::beman::execution::stoppable_token Tok>
    struct sender;

    template <::beman::execution::sender Sndr, ::beman::execution::stoppable_token Tok>
    auto operator()(Sndr&& sndr, Tok&& tok) const noexcept;
} stop_when{};
} // namespace beman::execution::detail

template <::beman::execution::sender Sndr, ::beman::execution::stoppable_token Tok>
struct beman::execution::detail::stop_when_t::sender {
    using sender_concept = ::beman::execution::sender_t;

    stop_when_t               stop_when{};
    std::remove_cvref_t<Tok>  tok;
    std::remove_cvref_t<Sndr> sndr;

    template <::beman::execution::receiver Rcvr>
    struct state {
        using operation_state_concept = ::beman::execution::operation_state_t;
        using rcvr_t                  = ::std::remove_cvref_t<Rcvr>;
        using token1_t                = ::std::remove_cvref_t<Tok>;
        using token2_t =
            decltype(::beman::execution::get_stop_token(::beman::execution::get_env(::std::declval<rcvr_t>())));

        struct cb_t {
            ::beman::execution::inplace_stop_source& source;
            auto                                     operator()() const noexcept { this->source.request_stop(); }
        };
        struct base_state {
            rcvr_t                                  rcvr;
            ::beman::execution::inplace_stop_source source{};
        };
        struct env {
            base_state* st;
            auto        query(const ::beman::execution::get_stop_token_t&) const noexcept {
                return this->st->source.get_token();
            }
            template <typename Q, typename... A>
                requires requires(const Q& q, A&&... a, const rcvr_t& r) {
                    q(::beman::execution::get_env(r), ::std::forward<A>(a)...);
                }
            auto query(const Q& q, A&&... a) const noexcept {
                return q(::beman::execution::get_env(this->st->rcvr), ::std::forward<A>(a)...);
            }
        };

        struct receiver {
            using receiver_concept = ::beman::execution::receiver_t;
            base_state* st;

            auto get_env() const noexcept -> env { return env{this->st}; }
            template <typename... A>
            auto set_value(A&&... a) const noexcept -> void {
                ::beman::execution::set_value(::std::move(this->st->rcvr), ::std::forward<A>(a)...);
            }
            template <typename E>
            auto set_error(E&& e) const noexcept -> void {
                ::beman::execution::set_error(::std::move(this->st->rcvr), ::std::forward<E>(e));
            }
            auto set_stopped() const noexcept -> void { ::beman::execution::set_stopped(::std::move(this->st->rcvr)); }
        };
        using inner_state_t =
            decltype(::beman::execution::connect(::std::declval<Sndr>(), ::std::declval<receiver>()));

        token1_t                                                               tok;
        base_state                                                             base;
        std::optional<::beman::execution::stop_callback_for_t<token1_t, cb_t>> cb1;
        std::optional<::beman::execution::stop_callback_for_t<token2_t, cb_t>> cb2;
        inner_state_t                                                          inner_state;

        template <::beman::execution::sender S, ::beman::execution::stoppable_token T, ::beman::execution::receiver R>
        state(S&& s, T&& t, R&& r)
            : tok(::std::forward<T>(t)),
              base{::std::forward<R>(r)},
              inner_state(::beman::execution::connect(::std::forward<S>(s), receiver{&this->base})) {}

        auto start() & noexcept {
            this->cb1.emplace(this->tok, cb_t{this->base.source});
            this->cb2.emplace(::beman::execution::get_stop_token(::beman::execution::get_env(this->base.rcvr)),
                              cb_t{this->base.source});
            ::beman::execution::start(this->inner_state);
        }
    };

    template <typename E>
    auto get_completion_signatures(const E& e) const noexcept {
        return ::beman::execution::get_completion_signatures(this->sndr, e);
    }
    template <::beman::execution::receiver Rcvr>
    auto connect(Rcvr&& rcvr) && -> state<Rcvr> {
        return state<Rcvr>{std::move(this->sndr), ::std::move(this->tok), ::std::forward<Rcvr>(rcvr)};
    }
};

template <::beman::execution::sender Sndr, ::beman::execution::stoppable_token Tok>
inline auto beman::execution::detail::stop_when_t::operator()(Sndr&& sndr, Tok&& tok) const noexcept {
    if constexpr (::beman::execution::unstoppable_token<Tok>) {
        return ::std::forward<Sndr>(sndr);
    } else {
        return sender<Sndr, Tok>{*this, ::std::forward<Tok>(tok), ::std::forward<Sndr>(sndr)};
    }
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct token_test_env {};

struct token_test_sender {
    using sender_concept = ::beman::execution::sender_t;
    template <typename... Env>
    auto get_completion_signatures(const Env&...) const noexcept {
        return ::beman::execution::completion_signatures<>{};
    }
};
static_assert(::beman::execution::sender<::beman::execution::detail::token_test_sender>);
static_assert(::beman::execution::sender_in<::beman::execution::detail::token_test_sender,
                                            ::beman::execution::detail::token_test_env>);
} // namespace beman::execution::detail

namespace beman::execution {
export template <typename Token>
concept scope_token = ::std::copyable<Token> && requires(Token token) {
    { token.try_associate() } -> ::std::same_as<bool>;
    { token.disassociate() } noexcept;
    {
        token.wrap(::std::declval<::beman::execution::detail::token_test_sender>())
    } -> ::beman::execution::sender_in<::beman::execution::detail::token_test_env>;
};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Tag type used to determine if completion signatures were defined.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct no_completion_signatures_defined_in_sender {};

/*!
 * \brief Primary template declaration for the customization of sender completion signatures.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Env>
struct completion_signatures_for_impl {
    using type = ::beman::execution::detail::no_completion_signatures_defined_in_sender;
};

/*!
 * \brief Type alias used to access a senders completion signatures.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Env>
using completion_signatures_for = ::std::conditional_t<
    ::std::same_as<beman::execution::detail::no_completion_signatures_defined_in_sender,
                   typename ::beman::execution::detail::completion_signatures_for_impl<Sender, Env>::type>,
    typename ::beman::execution::detail::completion_signatures_for_impl<::std::remove_cvref_t<Sender>, Env>::type,
    typename ::beman::execution::detail::completion_signatures_for_impl<Sender, Env>::type>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Alias to access the completion signatures of a sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export template <typename Sender, typename Env = ::beman::execution::env<>>
    requires ::beman::execution::sender_in<Sender, Env>
using completion_signatures_of_t =
    ::beman::execution::detail::call_result_t<::beman::execution::get_completion_signatures_t, Sender, Env>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief A helper types whose call operator connects all children of a basic_sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct connect_all_t {
  private:
    template <typename Fun, typename Tuple, ::std::size_t... I>
    static auto apply_with_index_helper(::std::index_sequence<I...> seq, Fun&& fun, Tuple&& tuple) noexcept(noexcept(
        ::std::forward<Fun>(fun)(seq, ::beman::execution::detail::forward_like<Tuple>(::std::get<I>(tuple))...)))
        -> decltype(auto) {
        return ::std::forward<Fun>(fun)(seq, ::beman::execution::detail::forward_like<Tuple>(::std::get<I>(tuple))...);
    }
    template <typename Fun, typename Tuple>
    static auto apply_with_index(Fun&& fun, Tuple&& tuple) noexcept(
        noexcept(apply_with_index_helper(::std::make_index_sequence<::std::tuple_size_v<::std::decay_t<Tuple>>>{},
                                         ::std::forward<Fun>(fun),
                                         ::std::forward<Tuple>(tuple)))) -> decltype(auto) {
        return apply_with_index_helper(::std::make_index_sequence<::std::tuple_size_v<::std::decay_t<Tuple>>>{},
                                       ::std::forward<Fun>(fun),
                                       ::std::forward<Tuple>(tuple));
    }

    template <::std::size_t Start, typename Fun, typename Tuple, ::std::size_t... I>
    static auto sub_apply_with_index_helper(::std::index_sequence<I...> seq, Fun&& fun, Tuple&& tuple) noexcept(
        noexcept(::std::forward<Fun>(fun)(
            seq, ::beman::execution::detail::forward_like<Tuple>(tuple.template get<I + Start>())...)))
        -> decltype(auto) {
        return ::std::forward<Fun>(fun)(
            seq, ::beman::execution::detail::forward_like<Tuple>(tuple.template get<I + Start>())...);
    }
    template <::std::size_t Start, typename Fun, typename Tuple>
        requires requires { ::std::declval<Tuple>().size(); }
    static auto sub_apply_with_index(Fun&& fun, Tuple&& tuple) noexcept(noexcept(sub_apply_with_index_helper<Start>(
        ::std::make_index_sequence<::std::tuple_size_v<::std::decay_t<Tuple>> - Start>{},
        ::std::forward<Fun>(fun),
        ::std::forward<Tuple>(tuple)))) -> decltype(auto) {
        return sub_apply_with_index_helper<Start>(
            ::std::make_index_sequence<::std::tuple_size_v<::std::decay_t<Tuple>> - Start>{},
            ::std::forward<Fun>(fun),
            ::std::forward<Tuple>(tuple));
    }
    template <::std::size_t Start, typename Fun, typename Tuple>
        requires(not requires { ::std::declval<Tuple>().size(); })
    static auto
    sub_apply_with_index(Fun&& fun,
                         Tuple&&) noexcept(noexcept(::std::forward<Fun>(fun)(::std::make_index_sequence<0u>{}))) {
        return ::std::forward<Fun>(fun)(::std::make_index_sequence<0u>{});
    }

    template <typename Sender, typename Receiver>
    struct connect_helper {
        ::beman::execution::detail::basic_state<Sender, Receiver>* op;

        template <::std::size_t... J, typename... C>
        auto operator()(::std::index_sequence<J...>, C&&... c) noexcept(
            (noexcept(::beman::execution::connect(
                 ::beman::execution::detail::forward_like<Sender>(c),
                 ::beman::execution::detail::
                     basic_receiver<Sender, Receiver, ::std::integral_constant<::std::size_t, J>>{this->op})) &&
             ... && true)) -> decltype(auto) {
            return ::beman::execution::detail::product_type{::beman::execution::connect(
                ::beman::execution::detail::forward_like<Sender>(c),
                ::beman::execution::detail::
                    basic_receiver<Sender, Receiver, ::std::integral_constant<::std::size_t, J>>{this->op})...};
        }
    };

    static auto use(auto&&...) {}

  public:
    //-dk:TODO is the S parameter deviating from the spec?
    template <typename Sender, typename S, typename Receiver, ::std::size_t... I>
        requires requires(Sender&& s) {
            s.size();
            s.template get<0>();
        }
    auto operator()(::beman::execution::detail::basic_state<Sender, Receiver>* op,
                    S&&                                                        sender,
                    ::std::index_sequence<I...>) const
        noexcept(noexcept(sub_apply_with_index<2>(connect_helper<Sender, Receiver>{op}, ::std::forward<S>(sender))))
            -> decltype(auto) {
        return sub_apply_with_index<2>(connect_helper<Sender, Receiver>{op}, ::std::forward<S>(sender));
    }
    template <typename Sender, typename S, typename Receiver, ::std::size_t... I>
    auto operator()(::beman::execution::detail::basic_state<Sender, Receiver>* op,
                    S&&                                                        sender,
                    ::std::index_sequence<I...>) const
        noexcept(noexcept(apply_with_index(
            connect_helper<Sender, Receiver>{op},
            ::beman::execution::detail::get_sender_data(::std::forward<S>(sender)).children))) -> decltype(auto) {
        return apply_with_index(connect_helper<Sender, Receiver>{op},
                                ::beman::execution::detail::get_sender_data(::std::forward<S>(sender)).children);
    }
};

/*!
 * \brief A helper object of type connect_all_t
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
inline constexpr connect_all_t connect_all{};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Type alias to get error types for a sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export template <typename Sender,
                 typename Env                         = ::beman::execution::env<>,
                 template <typename...> class Variant = ::beman::execution::detail::variant_or_empty>
    requires ::beman::execution::sender_in<Sender, Env>
using error_types_of_t =
    ::beman::execution::detail::gather_signatures<::beman::execution::set_error_t,
                                                  ::beman::execution::completion_signatures_of_t<Sender, Env>,
                                                  ::std::type_identity_t,
                                                  Variant>;
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Sender, typename Env = ::beman::execution::env<>>
    requires ::beman::execution::sender_in<Sender, Env>
inline constexpr bool sends_stopped{!::std::same_as<
    ::beman::execution::detail::type_list<>,
    ::beman::execution::detail::gather_signatures<::beman::execution::set_stopped_t,
                                                  ::beman::execution::completion_signatures_of_t<Sender, Env>,
                                                  ::beman::execution::detail::type_list,
                                                  ::beman::execution::detail::type_list>>};
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <typename Sender,
                 typename Env                         = ::beman::execution::env<>,
                 template <typename...> class Tuple   = ::beman::execution::detail::decayed_tuple,
                 template <typename...> class Variant = ::beman::execution::detail::variant_or_empty>
    requires ::beman::execution::sender_in<Sender, Env>
using value_types_of_t =
    ::beman::execution::detail::gather_signatures<::beman::execution::set_value_t,
                                                  ::beman::execution::completion_signatures_of_t<Sender, Env>,
                                                  Tuple,
                                                  Variant>;
}
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Helper type used to determine the state type when connecting all senders in a basic_sender
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Receiver>
using connect_all_result =
    ::beman::execution::detail::call_result_t<decltype(::beman::execution::detail::connect_all),
                                              ::beman::execution::detail::basic_state<Sender, Receiver>*,
                                              Sender,
                                              ::beman::execution::detail::indices_for<Sender>>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct sync_wait_env {
    ::beman::execution::run_loop* loop{};

    auto query(::beman::execution::get_scheduler_t) const noexcept { return this->loop->get_scheduler(); }
    auto query(::beman::execution::get_delegation_scheduler_t) const noexcept { return this->loop->get_scheduler(); }
};

template <::beman::execution::sender_in<::beman::execution::detail::sync_wait_env> Sender>
using sync_wait_result_type =
    ::std::optional<::beman::execution::value_types_of_t<Sender,
                                                         ::beman::execution::detail::sync_wait_env,
                                                         ::beman::execution::detail::decayed_tuple,
                                                         ::std::type_identity_t>>;

template <typename Sender>
struct sync_wait_state {
    ::beman::execution::run_loop loop{};
    ::std::exception_ptr         error{};

    ::beman::execution::detail::sync_wait_result_type<Sender> result{};
};

template <typename Sender>
struct sync_wait_receiver {
    using receiver_concept = ::beman::execution::receiver_t;

    ::beman::execution::detail::sync_wait_state<Sender>* state{};

    template <typename Error>
    auto set_error(Error&& error) && noexcept -> void {
        this->state->error = ::beman::execution::detail::as_except_ptr(::std::forward<Error>(error));
        this->state->loop.finish();
    }
    auto set_stopped() && noexcept -> void { this->state->loop.finish(); }
    template <typename... Args>
    auto set_value(Args&&... args) && noexcept -> void {
        try {
            this->state->result.emplace(::std::forward<Args>(args)...);
        } catch (...) {
            this->state->error = ::std::current_exception();
        }
        this->state->loop.finish();
    }

    auto get_env() const noexcept -> ::beman::execution::detail::sync_wait_env {
        return ::beman::execution::detail::sync_wait_env{&this->state->loop};
    }
};

struct sync_wait_t {
    template <typename Sender>
    auto apply_sender(Sender&& sender) const {
        ::beman::execution::detail::sync_wait_state<Sender> state;
        auto op{::beman::execution::connect(::std::forward<Sender>(sender),
                                            ::beman::execution::detail::sync_wait_receiver<Sender>{&state})};
        ::beman::execution::start(op);

        state.loop.run();
        if (state.error) {
            ::std::rethrow_exception(state.error);
        }
        return ::std::move(state.result);
    }

    template <::beman::execution::sender_in<::beman::execution::detail::sync_wait_env> Sender>
        requires requires(Sender&& sender, const sync_wait_t& self) {
            typename ::beman::execution::detail::sync_wait_result_type<Sender>;
            {
                ::beman::execution::apply_sender(
                    ::beman::execution::detail::get_domain_early(std::forward<Sender>(sender)),
                    self,
                    ::std::forward<Sender>(sender))
            } -> ::std::same_as<::beman::execution::detail::sync_wait_result_type<Sender>>;
        }
    auto operator()(Sender&& sender) const {
        auto domain{::beman::execution::detail::get_domain_early(sender)};
        return ::beman::execution::apply_sender(domain, *this, ::std::forward<Sender>(sender));
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
export using sync_wait_t = ::beman::execution::detail::sync_wait_t;
/*!
 * \brief <code>sync_wait(_sender_)</code> starts <code>_sender_</code> and waits for its completion.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `sync_wait` is a callable object of type `sync_wait_t`. Invoking
 * <code>sync_wait(_sender_)</code> starts <code>_sender_</code> and
 * waits for its completion. This involves a few steps:
 * 1. A <code>run_loop</code> is created to provide a scheduler.
 * 2. The <code>_sender_</code> is `connect`ed to a receiver capturing
 *     the results and providing an environment with access to the
 *     `run_loop`'s scheduler.
 * 3. The operation state returned from `connect` is `start`ed.
 * 4. The `run_loop` is run to process any work scheduled.
 *
 * Once the <code>_sender_</code> completes, the result is provided by `sync_wait`:
 * - If the <code>_sender_</code> completes with <code>set_value(_arg_...)</code>, `sync_wait` returns
 *     an <code>std::optional<std::tuple<_Arg_...>></code> containing the results
 *     <code>_arg_...</code>.
 * - If the <code>_sender_</code> completes with `set_stopped()`, `sync_wait` returns a
 *    disengaged <code>std::optional<std::tuple<_Arg_...>></code>.
 * - If the <code>_sender_</code> completes with
 *    <code>set_error(_error_)</code>, `sync_wait` throw <code>_error_</code> or rethrows the exception if
 * <code>_error_</code> is an <code>std::exception_ptr</code>.
 *
 * <h4>Usage</h4>
 * <pre>
 * sync_wait(<i>sender</i>...)
 * </pre>
 *
 * <h4>Example</h4>
 *
 * The use of <code>sync_wait(_sender_)</code> is in `main`
 * to synchronously wait for the completion of the asynchronous work
 * of the program represented by <code>_sender_</code>.
 *
 * <pre example="doc-sync_wait.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <cassert>
 *
 * int main() {
 *     auto result = ex::sync_wait(ex::just(17));
 *     assert(result);
 *     assert(*result == std::tuple(17));
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::sync_wait_t sync_wait{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Class template use to factor out common operation state needs.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Sender, typename Receiver>
    requires ::beman::execution::detail::
        //-dk:TODO why is the remove_cvref_t needed...?
    valid_specialization<::beman::execution::detail::state_type, std::remove_cvref_t<Sender>, Receiver>
struct basic_operation : ::beman::execution::detail::basic_state<Sender, Receiver> {
    // static_assert(std::same_as<Sender, std::remove_cvref_t<Sender>>);
    friend struct ::beman::execution::start_t;
    using operation_state_concept = ::beman::execution::operation_state_t;
    using tag_t                   = ::beman::execution::tag_of_t<Sender>;

    using inner_ops_t = ::beman::execution::detail::connect_all_result<Sender, Receiver>;
    inner_ops_t inner_ops;

    basic_operation(Sender&& sender, Receiver&& rcvr) noexcept(
        noexcept(::beman::execution::detail::basic_state<Sender, Receiver>(::std::forward<Sender>(sender),
                                                                           ::std::move(rcvr))) &&
        noexcept(::beman::execution::detail::connect_all(this,
                                                         ::std::forward<Sender>(sender),
                                                         ::beman::execution::detail::indices_for<Sender>())))
        : ::beman::execution::detail::basic_state<Sender, Receiver>(::std::forward<Sender>(sender), ::std::move(rcvr)),
          // NOLINTBEGIN(bugprone-use-after-move,hicpp-invalid-access-moved)
          //-dk:TODO deal with moving the sender twice
          inner_ops(::beman::execution::detail::connect_all(
              this, ::std::forward<Sender>(sender), ::beman::execution::detail::indices_for<Sender>())) {}
    // NOLINTEND(bugprone-use-after-move,hicpp-invalid-access-moved)

  private:
    auto start() & noexcept -> void {
        ::std::invoke(
            [this]<::std::size_t... I>(::std::index_sequence<I...>) {
                ::beman::execution::detail::impls_for<tag_t>::start(
                    this->state, this->receiver, this->inner_ops.template get<I>()...);
            },
            ::std::make_index_sequence<inner_ops_t::size()>{});
    }
};
template <typename Sender, typename Receiver>
basic_operation(Sender&&, Receiver&&) -> basic_operation<Sender&&, Receiver>;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Env>
struct single_sender_value_type_helper;

template <typename Sender, typename Env>
    requires requires {
        typename ::beman::execution::value_types_of_t<Sender, Env, ::std::decay_t, ::std::type_identity_t>;
    }
struct single_sender_value_type_helper<Sender, Env> {
    using type = ::beman::execution::value_types_of_t<Sender, Env, ::std::decay_t, ::std::type_identity_t>;
};

template <typename Sender, typename Env>
    requires ::std::same_as<::std::variant<::std::tuple<>>,
                            ::beman::execution::value_types_of_t<Sender, Env, ::std::tuple, ::std::variant>> ||
             ::std::same_as<::std::variant<>,
                            ::beman::execution::value_types_of_t<Sender, Env, ::std::tuple, ::std::variant>>
struct single_sender_value_type_helper<Sender, Env> {
    using type = void;
};

template <typename Sender, typename Env>
    requires(not requires {
                typename ::beman::execution::value_types_of_t<Sender, Env, ::std::decay_t, ::std::type_identity_t>;
            }) &&
            (!::std::same_as<::std::variant<::std::tuple<>>,
                             ::beman::execution::value_types_of_t<Sender, Env, ::std::tuple, ::std::variant>>) &&
            requires {
                typename ::beman::execution::
                    value_types_of_t<Sender, Env, ::beman::execution::detail::decayed_tuple, ::std::type_identity_t>;
            }
struct single_sender_value_type_helper<Sender, Env> {
    using type = ::beman::execution::
        value_types_of_t<Sender, Env, ::beman::execution::detail::decayed_tuple, ::std::type_identity_t>;
};

template <typename Sender, typename Env>
using single_sender_value_type = typename single_sender_value_type_helper<Sender, Env>::type;
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
/*!
 * \brief Class template used to factor out common sender implementation for library senders.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <typename Tag, typename Data, typename... Child>
struct basic_sender : ::beman::execution::detail::product_type<Tag, Data, Child...> {
    friend struct ::beman::execution::detail::connect_t;
    friend struct ::beman::execution::get_completion_signatures_t;
    using sender_concept = ::beman::execution::sender_t;
    using indices_for    = ::std::index_sequence_for<Child...>;

    auto get_env() const noexcept -> decltype(auto) {
        auto&& d{this->template get<1>()};
        return sub_apply<2>(
            [&d](auto&&... c) { return ::beman::execution::detail::impls_for<Tag>::get_attrs(d, c...); }, *this);
    }

    template <typename Receiver>
        requires(!::beman::execution::receiver<Receiver>)
    auto connect(Receiver receiver) = BEMAN_EXECUTION_DELETE("the passed receiver doesn't model receiver");

  private:
#if __cpp_explicit_this_parameter < 302110L //-dk:TODO need to figure out how to use explicit this with forwarding
    template <::beman::execution::receiver Receiver>
    auto connect(Receiver receiver) & noexcept(
        noexcept(::beman::execution::detail::basic_operation<basic_sender&, Receiver>{*this, ::std::move(receiver)}))
        -> ::beman::execution::detail::basic_operation<basic_sender&, Receiver> {
        return {*this, ::std::move(receiver)};
    }
    template <::beman::execution::receiver Receiver>
    auto connect(Receiver receiver) const& noexcept(noexcept(
        ::beman::execution::detail::basic_operation<const basic_sender&, Receiver>{*this, ::std::move(receiver)}))
        -> ::beman::execution::detail::basic_operation<const basic_sender&, Receiver> {
        return {*this, ::std::move(receiver)};
    }
    template <::beman::execution::receiver Receiver>
    auto connect(Receiver receiver) && noexcept(
        noexcept(::beman::execution::detail::basic_operation<basic_sender, Receiver>{::std::move(*this),
                                                                                     ::std::move(receiver)}))
        -> ::beman::execution::detail::basic_operation<basic_sender, Receiver> {
        return {::std::move(*this), ::std::move(receiver)};
    }
#else
    template <::beman::execution::detail::decays_to<basic_sender> Self, ::beman::execution::receiver Receiver>
    auto
    connect(this Self&& self,
            Receiver receiver) noexcept(noexcept(::beman::execution::detail::basic_operation<basic_sender, Receiver>{
        ::std::forward<Self>(self), ::std::move(receiver)}))
        -> ::beman::execution::detail::basic_operation<Self, Receiver> {
        return {::std::forward<Self>(self), ::std::move(receiver)};
    }
#endif
#if __cpp_explicit_this_parameter < 302110L
    template <typename Env>
    auto
    get_completion_signatures(Env&&) && -> ::beman::execution::detail::completion_signatures_for<basic_sender, Env> {
        return {};
    }
    template <typename Env>
    auto get_completion_signatures(
        Env&&) const&& -> ::beman::execution::detail::completion_signatures_for<const basic_sender, Env> {
        return {};
    }
    template <typename Env>
    auto
    get_completion_signatures(Env&&) & -> ::beman::execution::detail::completion_signatures_for<basic_sender, Env> {
        return {};
    }
    template <typename Env>
    auto get_completion_signatures(
        Env&&) const& -> ::beman::execution::detail::completion_signatures_for<const basic_sender, Env> {
        return {};
    }
#else
    template <::beman::execution::detail::decays_to<basic_sender> Self, typename Env>
    auto get_completion_signatures(this Self&&, Env&&) noexcept
        -> ::beman::execution::detail::completion_signatures_for<Self, Env> {
        return {};
    }
#endif
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Sender, typename Env>
concept single_sender = ::beman::execution::sender_in<Sender, Env> &&
                        requires { typename ::beman::execution::detail::single_sender_value_type<Sender, Env>; };
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct make_sender_empty {};

template <typename Tag, typename Data = ::beman::execution::detail::make_sender_empty, typename... Child>
    requires ::std::semiregular<Tag> && ::beman::execution::detail::movable_value<Data> &&
             (::beman::execution::sender<Child> && ...)
constexpr auto make_sender(Tag tag, Data&& data, Child&&... child) {
    return ::beman::execution::detail::basic_sender<Tag, ::std::decay_t<Data>, ::std::decay_t<Child>...>{
        tag, ::std::forward<Data>(data), ::std::forward<Child>(child)...};
}
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <class Sndr, class Promise>
concept awaitable_sender =
    ::beman::execution::detail::single_sender<Sndr, ::beman::execution::env_of_t<Promise>> && requires(Promise& prom) {
        { prom.unhandled_stopped() } -> ::std::convertible_to<::std::coroutine_handle<>>;
    };
} // namespace beman::execution::detail

namespace beman::execution::detail {
template <class Sndr, class Promise>
class sender_awaitable {
    struct unit {};
    using value_type =
        ::beman::execution::detail::single_sender_value_type<Sndr, ::beman::execution::env_of_t<Promise>>;
    using result_type  = ::std::conditional_t<::std::is_void_v<value_type>, unit, value_type>;
    using variant_type = ::std::variant<::std::monostate, result_type, ::std::exception_ptr>;
    using data_type    = ::std::tuple<variant_type, ::std::atomic<bool>, ::std::coroutine_handle<Promise>>;

    struct awaitable_receiver {
        using receiver_concept = ::beman::execution::receiver_t;

        void resume() {
            if (::std::get<1>(*result_ptr_).exchange(true, std::memory_order_acq_rel)) {
                ::std::get<2>(*result_ptr_).resume();
            }
        }

        template <class... Args>
            requires ::std::constructible_from<result_type, Args...>
        void set_value(Args&&... args) && noexcept {
            try {
                ::std::get<0>(*result_ptr_).template emplace<1>(::std::forward<Args>(args)...);
            } catch (...) {
                ::std::get<0>(*result_ptr_).template emplace<2>(::std::current_exception());
            }
            this->resume();
        }
        template <class Error>
        void set_error(Error&& error) && noexcept {
            ::std::get<0>(*result_ptr_)
                .template emplace<2>(::beman::execution::detail::as_except_ptr(::std::forward<Error>(error)));
            this->resume();
        }

        void set_stopped() && noexcept {
            if (::std::get<1>(*result_ptr_).exchange(true, ::std::memory_order_acq_rel)) {
                static_cast<::std::coroutine_handle<>>(::std::get<2>(*result_ptr_).promise().unhandled_stopped())
                    .resume();
            }
        }

        auto get_env() const noexcept {
            return ::beman::execution::detail::fwd_env{
                ::beman::execution::get_env(::std::get<2>(*result_ptr_).promise())};
        }

        data_type* result_ptr_;
    };
    using op_state_type = ::beman::execution::connect_result_t<Sndr, awaitable_receiver>;

    data_type     result{};
    op_state_type state;

  public:
    sender_awaitable(Sndr&& sndr, Promise& p)
        : result{::std::monostate{}, false, ::std::coroutine_handle<Promise>::from_promise(p)},
          state{::beman::execution::connect(::std::forward<Sndr>(sndr),
                                            sender_awaitable::awaitable_receiver{::std::addressof(result)})} {}

    static constexpr bool     await_ready() noexcept { return false; }
    ::std::coroutine_handle<> await_suspend(::std::coroutine_handle<Promise> handle) noexcept {
        ::beman::execution::start(state);
        if (::std::get<1>(this->result).exchange(true, std::memory_order_acq_rel)) {
            if (::std::holds_alternative<::std::monostate>(::std::get<0>(this->result))) {
                return ::std::get<2>(this->result).promise().unhandled_stopped();
            }
            return ::std::move(handle);
        }
        return ::std::noop_coroutine();
    }
    value_type await_resume() {
        if (::std::holds_alternative<::std::exception_ptr>(::std::get<0>(result))) {
            ::std::rethrow_exception(::std::get<::std::exception_ptr>(::std::get<0>(result)));
        }
        if constexpr (::std::is_void_v<value_type>) {
            return;
        } else {
            return ::std::get<value_type>(std::move(::std::get<0>(result)));
        }
    }
};
} // namespace beman::execution::detail

namespace beman::execution::detail {

struct bulk_t : ::beman::execution::sender_adaptor_closure<bulk_t> {

    template <class Shape, class f>
        requires(std::is_integral_v<Shape> && ::beman::execution::detail::movable_value<f>)
    auto operator()(Shape&& shape, f&& fun) const {
        return beman::execution::detail::sender_adaptor{*this, std::forward<Shape>(shape), std::forward<f>(fun)};
    }

    template <class Sender, class Shape, class f>
        requires(::beman::execution::sender<Sender> && std::is_integral_v<Shape> &&
                 ::beman::execution::detail::movable_value<f>)
    auto operator()(Sender&& sndr, Shape&& shape, f&& fun) const {

        auto domain{::beman::execution::detail::get_domain_early(sndr)};

        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this, ::beman::execution::detail::product_type<Shape, f>{shape, fun}, std::forward<Sender>(sndr)));
    }
};

template <>
struct impls_for<bulk_t> : ::beman::execution::detail::default_impls {

    static constexpr auto complete = []<class Index, class Shape, class Fun, class Rcvr, class Tag, class... Args>(
                                         Index,
                                         ::beman::execution::detail::product_type<Shape, Fun>& state,
                                         Rcvr&                                                 rcvr,
                                         Tag,
                                         Args&&... args) noexcept -> void
        requires(!::std::same_as<Tag, set_value_t> || std::is_invocable_v<Fun, Shape, Args...>)
    {
        if constexpr (std::same_as<Tag, set_value_t>) {
            auto& [shape, f] = state;

            using s_type = std::remove_cvref_t<decltype(shape)>;

            constexpr bool nothrow = noexcept(f(s_type(shape), args...));

            try {
                [&]() noexcept(nothrow) {
                    for (decltype(s_type(shape)) i = 0; i < shape; i++) {
                        f(s_type(i), args...);
                    }
                    Tag()(std::move(rcvr), std::forward<Args>(args)...);
                }();

            } catch (...) {
                if constexpr (not nothrow) {
                    ::beman::execution::set_error(std::move(rcvr), std::current_exception());
                }
            }
        } else {
            Tag()(std::move(rcvr), std::forward<Args>(args)...);
        }
    };
};

template <typename, typename, typename>
struct fixed_completions_helper;

template <typename F, typename Shape, typename... Args>
struct fixed_completions_helper<F, Shape, completion_signatures<Args...>> {

    template <typename, typename>
    struct may_throw;
    template <typename XF, typename Tag, typename... XArgs>
    struct may_throw<XF, Tag(XArgs...)> {
        static constexpr bool value =
            std::same_as<Tag, ::beman::execution::set_value_t> && !::std::is_nothrow_invocable<XF, Shape, XArgs...>();
    };
    template <typename XF, typename... Sigs>
    struct may_throw<XF, completion_signatures<Sigs...>> {
        static constexpr bool value = (false || ... || may_throw<XF, Sigs>::value);
    };

    using type = std::conditional_t<!may_throw<F, Args...>::value,
                                    completion_signatures<Args...>,
                                    completion_signatures<Args..., set_error_t(std::exception_ptr)>>;
};

template <typename F, typename Shape, typename Completions>
using fixed_completions = typename fixed_completions_helper<F, Shape, Completions>::type;

template <class Shape, class F, class Sender, class Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::
        basic_sender<::beman::execution::detail::bulk_t, ::beman::execution::detail::product_type<Shape, F>, Sender>,
    Env> {

    using completions = decltype(get_completion_signatures(std::declval<Sender>(), std::declval<Env>()));
    using type        = ::beman::execution::detail::meta::unique<
               ::beman::execution::detail::meta::combine<fixed_completions<F, Shape, completions>>>;
};

} // namespace beman::execution::detail

namespace beman::execution {

export using bulk_t = ::beman::execution::detail::bulk_t;
export inline constexpr ::beman::execution::bulk_t bulk{};

} // namespace beman::execution

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
export struct into_variant_t {
    template <::beman::execution::sender Sender>
    auto operator()(Sender&& sender) const {
        auto domain{::beman::execution::detail::get_domain_early(sender)};
        (void)domain;
        return ::beman::execution::detail::make_sender(*this, {}, ::std::forward<Sender>(sender));
        // return ::beman::execution::transform_sender(
        //     ::std::move(domain),
        //     ::beman::execution::detail::make_sender(*this, {}, ::std::forward<Sender>(sender))
        //);
    }
};

template <>
struct impls_for<::beman::execution::detail::into_variant_t> : ::beman::execution::detail::default_impls {
    static constexpr auto get_state = []<typename Sender, typename Receiver>(Sender&&, Receiver&&) noexcept
        -> ::std::type_identity<::beman::execution::value_types_of_t<::beman::execution::detail::child_type<Sender>,
                                                                     ::beman::execution::env_of_t<Receiver>>> {
        return {};
    };
    static constexpr auto complete = []<typename State, typename Tag, typename... Args>(
                                         auto, State, auto& receiver, Tag, Args&&... args) noexcept -> void {
        if constexpr (::std::same_as<Tag, ::beman::execution::set_value_t>) {
            using variant_type = typename State::type;
            using tuple_type   = ::beman::execution::detail::decayed_tuple<Args...>;
            try {
                if constexpr (sizeof...(Args) == 0u)
                    ::beman::execution::set_value(::std::move(receiver));
                else
                    ::beman::execution::set_value(::std::move(receiver),
                                                  variant_type(tuple_type{::std::forward<Args>(args)...}));
            } catch (...) {
                ::beman::execution::set_error(::std::move(receiver), ::std::current_exception());
            }

        } else {
            Tag()(::std::move(receiver), ::std::forward<Args>(args)...);
        }
    };
};

template <typename Sender, typename State, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::into_variant_t, State, Sender>,
    Env> {
    using variant_type = ::beman::execution::value_types_of_t<Sender, Env>;
    using value_types =
        ::std::conditional_t<::std::same_as<variant_type, ::beman::execution::detail::empty_variant>,
                             ::beman::execution::completion_signatures<>,
                             ::beman::execution::completion_signatures<::beman::execution::set_value_t(variant_type)>>;
    template <typename... E>
    using make_error_types = ::beman::execution::completion_signatures<::beman::execution::set_error_t(E)...>;

    using error_types = ::beman::execution::error_types_of_t<Sender, Env, make_error_types>;
    using stopped_types =
        ::std::conditional_t<::beman::execution::sends_stopped<Sender, Env>,
                             ::beman::execution::completion_signatures<::beman::execution::set_stopped_t()>,
                             ::beman::execution::completion_signatures<>>;
    using type = ::beman::execution::detail::meta::
        combine<value_types, ::beman::execution::detail::meta::combine<error_types, stopped_types>>;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using into_variant_t = ::beman::execution::detail::into_variant_t;
export inline constexpr into_variant_t into_variant{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Completion, typename... T>
concept just_size = (!::std::same_as<Completion, ::beman::execution::set_error_t> or 1u == sizeof...(T)) &&
                    (!::std::same_as<Completion, ::beman::execution::set_stopped_t> or 0u == sizeof...(T));
template <typename Completion>
struct just_t {
    template <typename... T>
        requires ::beman::execution::detail::just_size<Completion, T...> &&
                 (::beman::execution::detail::movable_value<T> && ...)
    auto operator()(T&&... arg) const {
        return ::beman::execution::detail::make_sender(
            *this, ::beman::execution::detail::product_type{::std::forward<T>(arg)...});
    }
    template <::beman::execution::sender Sender>
    static auto affine_on(Sender&& sndr, const auto&) noexcept {
        return ::std::forward<Sender>(sndr);
    }
};

template <typename Completion, typename... T, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<just_t<Completion>, ::beman::execution::detail::product_type<T...>>,
    Env> {
    using type = ::beman::execution::completion_signatures<Completion(T...)>;
};

template <typename Completion>
struct impls_for<just_t<Completion>> : ::beman::execution::detail::default_impls {
    static constexpr auto start = []<typename State>(State& state, auto& receiver) noexcept -> void {
        [&state, &receiver]<::std::size_t... I>(::std::index_sequence<I...>) {
            Completion()(::std::move(receiver), ::std::move(state.template get<I>())...);
        }(::std::make_index_sequence<State::size()>{});
    };
};
} // namespace beman::execution::detail

namespace beman::execution {
export using just_t         = ::beman::execution::detail::just_t<::beman::execution::set_value_t>;
export using just_error_t   = ::beman::execution::detail::just_t<::beman::execution::set_error_t>;
export using just_stopped_t = ::beman::execution::detail::just_t<::beman::execution::set_stopped_t>;

/*!
 * \brief <code>just(_arg_...)</code> yields a sender completing with <code>set_value_t(_Arg_...)</code>
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `just` is a callable object of type `just_t`. Invoking <code>just(_arg_...)</code> yields a sender which stores its
 * arguments and produces a value completion with these arguments when started. This sender completes synchronously
 * when started.
 *
 * <h4>Usage</h4>
 * <pre>
 * just(<i>arg</i>...)
 * </pre>
 *
 * Above <code>_Arg_...</code> is a pack of the types of <code>_arg_...</code>
 * after removing top-level `const` and reference qualifications
 * (<code>std::remove_cvref_t&lt;decltype(_arg_)&gt;...</code>).
 *
 * <h4>Completions Signatures</h4>
 * <pre>
 * completion_signatures<
 *     set_value_t(<i>Arg</i>...)
 * >;
 * </pre>
 *
 * <h4>Example</h4>
 *
 * The normal use of <code>just(_args_...)</code> is as the starting
 * point of a work graph. Various other examples will use `just` as
 * their starting. The example below create a sender yielding three
 * values and awaits the completion using <code>sync_wait(_sender_)</code>:
 * for a value completion of <code>_sender_</code> it will yield an
 * <code>std::optional&lt;std::tuple&lt;_Args_...&gt;&gt;</code> with the
 * `tuple` containing the value copied/moved from the original arguments
 * (an `optional` is returned to indicate cancellation).
 *
 * <pre example="doc-just.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <cassert>
 * #include <string>
 * using namespace std::string_literals;
 *
 * int main() {
 *     auto result = ex::sync_wait(ex::just(17, "hello"s, true));
 *     assert(result);
 *     assert(*result == std::tuple(17, "hello"s, true));
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::just_t just{};

/*!
 * \brief <code>just_error(_error_)</code> yields a sender completing with <code>set_error_t(_Error_)</code>
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `just_error` is a callable object of type `just_error_t`. Invoking <code>just_error(_error_)</code> yields a sender
 * which stores its argument and produces an error completion with this error when started. This sender completes
 * synchronously when started.
 *
 * <h4>Usage</h4>
 * <pre>
 * just_error(<i>error</i>)
 * </pre>
 *
 * The type <code>_Error_</code> used above is the type of <code>_error_</code>
 * after removing top-level `const` and reference qualifications
 * (<code>std::remove_cvref_t&lt;decltype(error)&gt;</code>).
 *
 * <h4>Completions Signatures</h4>
 * <pre>
 * completion_signatures<
 *     set_error_t(<i>Error</i>)
 * >;
 * </pre>
 *
 * <h4>Example</h4>
 *
 * The normal use of <code>just_error(_error_)</code> is to report an
 * error as the result of some work in a work graph. It would, e.g., be
 * used as the completion produced by `let_value`.
 * The example below creates a sender yielding an `std::error_code` on the error
 * channel and
 * uses that as the input for `upon_error` consuming the error and producing
 * a value completion: using <code>sync_wait(just_error(_error_))</code>
 * directly doesn't work because `sync_wait` requires exactly one value completion
 * from its argument and `set_error` only has an error completion. The function used with `upon_error` verifies that
 * the expected code was produced and also sets the flag `had_error` indicating it was called at all. This flag is
 * checked after waiting for the result in `sync_wait`.
 *
 * <pre example="doc-just_error.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <system_error>
 * #include <cassert>
 * namespace ex = beman::execution;
 *
 * int main() {
 *     bool had_error{false};
 *     auto result = ex::sync_wait(ex::just_error(std::error_code(17, std::system_category())) |
 *                                 ex::upon_error([&](std::error_code ec) {
 *                                     assert(ec.value() == 17);
 *                                     had_error = true;
 *                                 }));
 *     assert(had_error);
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::just_error_t just_error{};

/*!
 * \brief <code>just_stopped()</code> yields a sender completing with <code>set_stopped_t()</code>
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `just_stopped` is a callable object of type `just_stopped_t`. Invoking <code>just_stopped()</code> yields a sender
 * which produces a cancellation completion when started. This sender completes synchronously when started.
 *
 * <h4>Usage</h4>
 * <pre>
 * just_stopped()
 * </pre>
 *
 * <h4>Completions Signatures</h4>
 * <pre>
 * completion_signatures<
 *     set_stopped_t()
 * >;
 * </pre>
 *
 * <h4>Example</h4>
 *
 * The normal use of <code>just_stopped()</code> is to report a
 * cancellation as the result of some work in a work graph. It would, e.g., be
 * used as the completion produced by `let_value`.
 * The example below creates a sender yielding a completion on the cancellation
 * channel and
 * uses that as the input for `upon_stopped` consuming the cancellation and producing
 * a value completion: using <code>sync_wait(just_stopped())</code>
 * directly doesn't work because `sync_wait` requires exactly one value completion
 * from its argument and `set_stopped` only has a cancellation completion. The function used with `upon_stopped`
 * sets the flag `had_stopped` indicating it
 * was called at all. This flag is checked after waiting for the result
 * in `sync_wait`.
 *
 * <pre example="doc-just_error.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <system_error>
 * #include <cassert>
 * namespace ex = beman::execution;
 *
 * int main() {
 *     bool had_stopped{false};
 *     auto result = ex::sync_wait(ex::just_error(std::error_code(17, std::system_category())) |
 *                                 ex::upon_error([&](std::error_code ec) {
 *                                     assert(ec.value() == 17);
 *                                     had_stopped = true;
 *                                 }));
 *     assert(had_stopped);
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::just_stopped_t just_stopped{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Completion>
struct let_t {
    template <::beman::execution::detail::movable_value Fun>
    auto operator()(Fun&& fun) const {
        return ::beman::execution::detail::sender_adaptor{*this, ::std::forward<Fun>(fun)};
    }
    template <::beman::execution::sender Sender, ::beman::execution::detail::movable_value Fun>
    auto operator()(Sender&& sender, Fun&& fun) const {
        auto domain(::beman::execution::detail::get_domain_early(sender));
        return ::beman::execution::detail::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(*this, ::std::forward<Fun>(fun), std::forward<Sender>(sender)));
    }

    template <typename Sender>
    static auto env(Sender&& sender) {
        if constexpr (requires {
                          ::beman::execution::detail::sched_env(
                              ::beman::execution::get_completion_scheduler<Completion>(
                                  ::beman::execution::get_env(sender)));
                      })
            return ::beman::execution::detail::sched_env(
                ::beman::execution::get_completion_scheduler<Completion>(::beman::execution::get_env(sender)));
        else if constexpr (requires {
                               ::beman::execution::detail::make_env(
                                   ::beman::execution::get_domain,
                                   ::beman::execution::get_domain(::beman::execution::get_env(sender)));
                           })
            return ::beman::execution::detail::make_env(
                ::beman::execution::get_domain, ::beman::execution::get_domain(::beman::execution::get_env(sender)));
        else
            return ::beman::execution::env<>{};
    }
    template <typename Sender, typename Env>
    static auto join_env(Sender&& sender, Env&& e) -> decltype(auto) {
        return ::beman::execution::detail::join_env(env(sender), ::beman::execution::detail::fwd_env(e));
    }
};

template <typename Completion>
struct impls_for<::beman::execution::detail::let_t<Completion>> : ::beman::execution::detail::default_impls {

    template <typename Receiver, typename Env>
    struct let_receiver {
        using receiver_concept = ::beman::execution::receiver_t;

        Receiver& receiver;
        Env       env;

        auto get_env() const noexcept -> decltype(auto) {
            return ::beman::execution::detail::join_env(
                this->env, ::beman::execution::detail::fwd_env(::beman::execution::get_env(this->receiver)));
        }
        template <typename Error>
        auto set_error(Error&& error) && noexcept -> void {
            ::beman::execution::set_error(::std::move(this->receiver), ::std::forward<Error>(error));
        }
        auto set_stopped() && noexcept -> void { ::beman::execution::set_stopped(::std::move(this->receiver)); }
        template <typename... Args>
        auto set_value(Args&&... args) && noexcept -> void {
            ::beman::execution::set_value(::std::move(this->receiver), ::std::forward<Args>(args)...);
        }
    };

    template <typename>
    struct filter_pred : ::std::false_type {};
    template <typename... A>
    struct filter_pred<Completion(A...)> : ::std::true_type {};
    template <typename>
    struct to_tuple;
    template <typename C, typename... A>
    struct to_tuple<C(A...)> {
        using type = ::beman::execution::detail::decayed_tuple<A...>;
    };
    template <typename T>
    using to_tuple_t = typename to_tuple<T>::type;
    template <typename Fun, typename Receiver, typename Env>
    struct to_state {
        template <typename Tuple>
        using trans =
            decltype(::beman::execution::connect(::std::apply(::std::declval<Fun>(), ::std::declval<Tuple>()),
                                                 ::std::declval<let_receiver<Receiver, Env>>()));
    };

    static constexpr auto get_state{[]<typename Sender, typename Receiver>(Sender&& sender, Receiver&& receiver) {
        auto& fun{sender.template get<1>()};
        auto& child{sender.template get<2>()};

        using fun_t   = ::std::remove_cvref_t<decltype(fun)>;
        using child_t = ::std::remove_cvref_t<decltype(child)>;
        using env_t   = decltype(::beman::execution::detail::let_t<Completion>::env(child));
        using sigs_t = ::beman::execution::completion_signatures_of_t<child_t, ::beman::execution::env_of_t<Receiver>>;
        using comp_sigs_t = ::beman::execution::detail::meta::filter<filter_pred, sigs_t>;
        using type_list_t = ::beman::execution::detail::meta::to<::std::variant, comp_sigs_t>;
        using tuples_t    = ::beman::execution::detail::meta::transform<to_tuple_t, type_list_t>;
        using unique_t    = ::beman::execution::detail::meta::unique<tuples_t>;
        using args_t      = ::beman::execution::detail::meta::prepend<std::monostate, unique_t>;
        using ops_t       = ::beman::execution::detail::meta::prepend<
                  ::std::monostate,
                  ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::transform<
                      to_state<fun_t, ::std::remove_cvref_t<Receiver>, env_t>::template trans,
                      tuples_t>>>;

        struct state_t {
            fun_t  fun;
            env_t  env;
            args_t args;
            ops_t  ops2;
        };
        return state_t{beman::execution::detail::allocator_aware_move(
                           ::beman::execution::detail::forward_like<Sender>(fun), receiver),
                       ::beman::execution::detail::let_t<Completion>::env(child),
                       {},
                       {}};
    }};
    template <typename Receiver, typename... Args>
    static auto
    let_bind(auto& state, Receiver& receiver, Args&&... args) noexcept(noexcept(::beman::execution::connect(
        ::std::apply(::std::move(state.fun),
                     ::std::move(state.args.template emplace<::beman::execution::detail::decayed_tuple<Args...>>(
                         ::std::forward<Args>(args)...))),
        let_receiver<Receiver, decltype(state.env)>{receiver, state.env}))) {
        using args_t = ::beman::execution::detail::decayed_tuple<Args...>;
        auto mkop{[&] {
            return ::beman::execution::connect(
                ::std::apply(::std::move(state.fun),
                             ::std::move(state.args.template emplace<args_t>(::std::forward<Args>(args)...))),
                let_receiver<Receiver, decltype(state.env)>{receiver, state.env});
        }};
        ::beman::execution::start(
            state.ops2.template emplace<decltype(mkop())>(beman::execution::detail::emplace_from{mkop}));
    }
    static constexpr auto complete{
        []<class Tag, class... Args>(auto, auto& state, auto& receiver, Tag, Args&&... args) {
            if constexpr (::std::same_as<Tag, Completion>) {
                try {
                    let_bind(state, receiver, ::std::forward<Args>(args)...);
                } catch (...) {
                    if constexpr (not noexcept(let_bind(state, receiver, ::std::forward<Args>(args)...)))
                        ::beman::execution::set_error(::std::move(receiver), ::std::current_exception());
                }
            } else {
                Tag()(::std::move(receiver), ::std::forward<Args>(args)...);
            }
        }};
};

template <typename Completion, typename Fun, typename Sender, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::let_t<Completion>, Fun, Sender>,
    Env> {
    template <typename>
    struct other_completion : ::std::true_type {};
    template <typename... A>
    struct other_completion<Completion(A...)> : ::std::false_type {};
    template <typename>
    struct matching_completion : ::std::false_type {};
    template <typename... A>
    struct matching_completion<Completion(A...)> : ::std::true_type {};

    template <typename>
    struct apply_decayed;
    template <typename C, typename... A>
    struct apply_decayed<C(A...)> {
        using sender_type = ::beman::execution::detail::call_result_t<Fun, ::std::decay_t<A>...>;
    };
    template <typename>
    struct get_completions;
    template <template <typename...> class L, typename... C>
    struct get_completions<L<C...>> {
        using type = ::beman::execution::detail::meta::unique<
            ::beman::execution::detail::meta::combine<decltype(::beman::execution::get_completion_signatures(
                std::declval<typename apply_decayed<C>::sender_type>(), std::declval<Env>()))...>>;
    };

    using upstream_env = decltype(::beman::execution::detail::let_t<Completion>::join_env(::std::declval<Sender>(),
                                                                                          ::std::declval<Env>()));
    using upstream_completions = decltype(::beman::execution::get_completion_signatures(
        ::std::declval<Sender>(), ::std::declval<upstream_env>()));
    using other_completions    = ::beman::execution::detail::meta::filter<other_completion, upstream_completions>;
    using matching_completions = ::beman::execution::detail::meta::filter<matching_completion, upstream_completions>;
    using type = ::beman::execution::detail::meta::combine<typename get_completions<matching_completions>::type,
                                                           other_completions>;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using let_error_t   = ::beman::execution::detail::let_t<::beman::execution::set_error_t>;
export using let_stopped_t = ::beman::execution::detail::let_t<::beman::execution::set_stopped_t>;
export using let_value_t   = ::beman::execution::detail::let_t<::beman::execution::set_value_t>;

export inline constexpr ::beman::execution::let_error_t   let_error{};
export inline constexpr ::beman::execution::let_stopped_t let_stopped{};
export inline constexpr ::beman::execution::let_value_t   let_value{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct read_env_t {
    auto operator()(auto&& query) const { return ::beman::execution::detail::make_sender(*this, query); }
    template <::beman::execution::sender Sender>
    static auto affine_on(Sender&& sndr, const auto&) noexcept {
        return ::std::forward<Sender>(sndr);
    }
};

template <>
struct impls_for<::beman::execution::detail::read_env_t> : ::beman::execution::detail::default_impls {
    static constexpr auto start = [](auto query, auto& receiver) noexcept -> void {
        try {
            auto env{::beman::execution::get_env(receiver)};
            ::beman::execution::set_value(::std::move(receiver), query(env));
        } catch (...) {
            ::beman::execution::set_error(::std::move(receiver), ::std::current_exception());
        }
    };
};

template <typename Query, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::read_env_t, Query>,
    Env> {
    using set_value_type =
        ::beman::execution::set_value_t(decltype(::std::declval<Query>()(::std::as_const(::std::declval<Env>()))));
    using set_error_type = ::beman::execution::set_error_t(::std::exception_ptr);
    using type           = ::std::conditional_t<noexcept(::std::declval<Query>()(::std::declval<const Env&>())),
                                                ::beman::execution::completion_signatures<set_value_type>,
                                                ::beman::execution::completion_signatures<set_value_type, set_error_type>>;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using read_env_t = beman::execution::detail::read_env_t;
export inline constexpr read_env_t read_env{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct schedule_from_t {
    template <::beman::execution::scheduler Scheduler, ::beman::execution::sender Sender>
    auto operator()(Scheduler&& scheduler, Sender&& sender) const {
        auto domain{::beman::execution::detail::query_with_default(
            ::beman::execution::get_domain, scheduler, ::beman::execution::default_domain{})};
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this, ::std::forward<Scheduler>(scheduler), ::std::forward<Sender>(sender)));
    }
};

template <>
struct impls_for<::beman::execution::detail::schedule_from_t> : ::beman::execution::detail::default_impls {
    template <typename State>
    struct upstream_receiver {
        using receiver_concept = ::beman::execution::receiver_t;
        State* state;

        auto set_value() && noexcept -> void {
            try {
                ::std::visit(
                    [this]<typename Tuple>(Tuple& result) noexcept -> void {
                        if constexpr (!::std::same_as<::std::monostate, Tuple>) {
                            ::std::apply(
                                [this](auto&& tag, auto&&... args) {
                                    tag(::std::move(this->state->receiver), ::std::move(args)...);
                                },
                                result);
                        }
                    },
                    state->async_result);
            } catch (...) {
                ::beman::execution::set_error(::std::move(state->receiver), ::std::current_exception());
            }
        }

        template <typename Error>
        auto set_error(Error&& err) && noexcept -> void {
            ::beman::execution::set_error(std::move(state->receiver), std::forward<Error>(err));
        }

        auto set_stopped() && noexcept -> void { ::beman::execution::set_stopped(std::move(state->receiver)); }

        auto get_env() const noexcept -> decltype(auto) {
            return ::beman::execution::detail::fwd_env(::beman::execution::get_env(state->receiver));
        }
    };
    template <typename Receiver, typename Variant>
    struct state_base {
        Receiver receiver;
        Variant  async_result{};
    };
    template <typename Receiver, typename Scheduler, typename Variant>
    struct state_type : state_base<Receiver, Variant> {
        using receiver_t = upstream_receiver<state_base<Receiver, Variant>>;
        using operation_t =
            ::beman::execution::connect_result_t<::beman::execution::schedule_result_t<Scheduler>, receiver_t>;
        operation_t op_state;

        static constexpr bool nothrow() {
            return noexcept(::beman::execution::connect(::beman::execution::schedule(::std::declval<Scheduler>()),
                                                        receiver_t{nullptr}));
        }
        explicit state_type(Scheduler& sch, Receiver& rcvr) noexcept(nothrow())
            : state_base<Receiver, Variant>{rcvr},
              op_state(::beman::execution::connect(::beman::execution::schedule(sch), receiver_t{this})) {}
    };

    static constexpr auto get_attrs{[](const auto& data, const auto& child) noexcept -> decltype(auto) {
        return ::beman::execution::detail::join_env(
            ::beman::execution::detail::sched_attrs(data),
            ::beman::execution::detail::fwd_env(::beman::execution::get_env(child)));
    }};
    static constexpr auto get_state{
        []<typename Sender, typename Receiver>(Sender&& sender, Receiver& receiver) //-dk:TODO noexcept(see below)
            requires ::beman::execution::sender_in<::beman::execution::detail::child_type<Sender>,
                                                   ::beman::execution::env_of_t<Receiver>>
        {
            auto sch{sender.template get<1>()};

            using sched_t   = ::std::remove_cvref_t<decltype(sch)>;
            using variant_t = ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::prepend<
                ::std::monostate,
                ::beman::execution::detail::meta::transform<
                    ::beman::execution::detail::as_tuple_t,
                    ::beman::execution::detail::meta::to<::std::variant,
                                                         ::beman::execution::detail::meta::combine<
                                                             ::beman::execution::completion_signatures_of_t<
                                                                 ::beman::execution::detail::child_type<Sender>,
                                                                 ::beman::execution::env_of_t<Receiver>>,
                                                             //-dk:TODO get proper error completion signatures
                                                             ::beman::execution::completion_signatures<
                                                                 ::beman::execution::set_error_t(::std::exception_ptr),
                                                                 ::beman::execution::set_stopped_t()>>>>>>;

            return state_type<Receiver, sched_t, variant_t>(sch, receiver);
        }};
    static constexpr auto complete{
        []<typename Tag, typename... Args>(auto, auto& state, auto& receiver, Tag, Args&&... args) noexcept -> void {
            using result_t         = ::beman::execution::detail::decayed_tuple<Tag, Args...>;
            constexpr bool nothrow = ::std::is_nothrow_constructible_v<result_t, Tag, Args...>;

            try {
                [&]() noexcept(nothrow) {
                    state.async_result.template emplace<result_t>(Tag(), std::forward<Args>(args)...);
                }();
            } catch (...) {
                if constexpr (not nothrow)
                    ::beman::execution::set_error(::std::move(receiver), ::std::current_exception());
            }

            if (state.async_result.index() == 0)
                return;

            ::beman::execution::start(state.op_state);
        }};
};

template <typename Scheduler, typename Sender, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::schedule_from_t, Scheduler, Sender>,
    Env> {
    using scheduler_sender = decltype(::beman::execution::schedule(::std::declval<Scheduler>()));
    template <typename... E>
    using as_set_error = ::beman::execution::completion_signatures<::beman::execution::set_error_t(E)...>;
    using type         = ::beman::execution::detail::meta::combine<
                decltype(::beman::execution::get_completion_signatures(::std::declval<Sender>(), ::std::declval<Env>())),
                ::beman::execution::error_types_of_t<scheduler_sender, Env, as_set_error>,
                ::beman::execution::completion_signatures<::beman::execution::set_error_t(
            ::std::exception_ptr)> //-dk:TODO this one should be deduced
                >;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using schedule_from_t = beman::execution::detail::schedule_from_t;
export inline constexpr ::beman::execution::schedule_from_t schedule_from{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

struct split_impl_t {};
template <>
struct impls_for<split_impl_t> : ::beman::execution::detail::default_impls {

    template <class Sndr>
    struct shared_state;

    struct split_env {
        ::beman::execution::inplace_stop_source* stop_source;

        ::beman::execution::inplace_stop_token query(::beman::execution::get_stop_token_t) const noexcept {
            return stop_source->get_token();
        }
    };

    struct local_state_base {
        local_state_base* next{nullptr};
        virtual auto      notify() noexcept -> void = 0;

        local_state_base() noexcept                                  = default;
        local_state_base(const local_state_base&)                    = delete;
        local_state_base(local_state_base&&)                         = delete;
        auto operator=(const local_state_base&) -> local_state_base& = delete;
        auto operator=(local_state_base&&) -> local_state_base&      = delete;

      protected:
        ~local_state_base() = default;
    };

    template <class Sndr>
    struct split_receiver {
        using receiver_concept = ::beman::execution::receiver_t;

        explicit split_receiver(shared_state<Sndr>* state) noexcept : sh_state(state) {
            if (sh_state) {
                sh_state->inc_ref();
            }
        }

        ~split_receiver() noexcept {
            if (sh_state) {
                sh_state->dec_ref();
            }
        }

        split_receiver(split_receiver&& other) noexcept : sh_state(::std::exchange(other.sh_state, nullptr)) {}
        split_receiver& operator=(split_receiver&& other) noexcept {
            sh_state = ::std::exchange(other.sh_state, nullptr);
            return *this;
        }

        split_receiver(const split_receiver&)            = delete;
        split_receiver& operator=(const split_receiver&) = delete;

        template <class Tag, class... Args>
        void complete(Tag, Args&&... args) noexcept {
            using tuple_t = ::beman::execution::detail::decayed_tuple<Tag, Args...>;
            try {
                sh_state->result.template emplace<tuple_t>(Tag(), ::std::forward<Args>(args)...);
            } catch (...) {
                using tuple_err = ::std::tuple<::beman::execution::set_error_t, ::std::exception_ptr>;
                sh_state->result.template emplace<tuple_err>(::beman::execution::set_error,
                                                             ::std::current_exception());
            }
            sh_state->notify();
        }

        template <class... Args>
        void set_value(Args&&... args) && noexcept {
            complete(::beman::execution::set_value, ::std::forward<Args>(args)...);
        }

        template <class Error>
        void set_error(Error&& err) && noexcept {
            complete(::beman::execution::set_error, ::std::forward<Error>(err));
        }

        void set_stopped() && noexcept { complete(::beman::execution::set_stopped); }

        split_env get_env() const noexcept { return split_env{&sh_state->stop_src}; }

        shared_state<Sndr>* sh_state;
    };

    // [exec.split-10]
    template <class Sndr>
    struct shared_state {
        template <class... Args>
        using value_tuple = ::std::tuple<::beman::execution::set_value_t, ::std::decay_t<Args>...>;

        template <class... Args>
        using error_tuples = ::std::variant<::std::tuple<::beman::execution::set_error_t, ::std::decay_t<Args>>...>;

        using variant_type = ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::combine<
            ::std::variant<::std::monostate>,
            ::std::variant<::std::tuple<::beman::execution::set_stopped_t>>,
            ::std::variant<::std::tuple<::beman::execution::set_error_t, ::std::exception_ptr>>,
            ::beman::execution::error_types_of_t<Sndr, split_env, error_tuples>,
            ::beman::execution::value_types_of_t<Sndr, split_env, value_tuple>>>;

        using state_list_type = ::beman::execution::detail::atomic_intrusive_stack<&local_state_base::next>;

        using child_operation_state = ::beman::execution::connect_result_t<Sndr, split_receiver<Sndr>>;

        explicit shared_state(Sndr&& sndr) {
            try {
                op_state.emplace(::beman::execution::detail::emplace_from{[&] {
                    return ::beman::execution::connect(::std::forward<Sndr>(sndr), split_receiver<Sndr>{this});
                }});
            } catch (...) {
                using error_tuple_t = ::std::tuple<::beman::execution::set_error_t, ::std::exception_ptr>;
                result.template emplace<error_tuple_t>(::beman::execution::set_error, ::std::current_exception());
                [[maybe_unused]] auto queue = waiting_states.pop_all_and_shutdown();
                assert(queue.empty());
            }
        }

        // We use an intrusive list to store the listeners that are waiting for the operation to complete.
        // if the intrusive list is empty, we start the operation
        // if the intrusive list is not empty, we push the listener to the intrusive list
        // if the intrusive list is shutdown, we immediately notify the listener
        void add_listener(local_state_base* listener) noexcept {
            // try to push the listener to the intrusive list, if the intrusive list is empty and not shutdown, start
            // the operation
            if (auto maybe_ptr = waiting_states.try_push(listener); !maybe_ptr) {
                // the queue is shutdown, immediately notify the listener
                listener->notify();
            } else if (!(*maybe_ptr)) {
                // the operation was not started yet, we are first, and we start it
                assert(op_state);
                if (op_state)
                    ::beman::execution::start(*op_state);
                else
                    std::terminate();
            }
        }

        void notify() noexcept {
            // note: this is different from stdexec.
            // we discussed lifetime durations of operation at LEWG and haven't decided yet
            // whether we should keep the operation alive as long as possible
            op_state.reset();
            auto listeners = waiting_states.pop_all_and_shutdown();
            while (auto listener = listeners.pop()) {
                listener->notify();
            }
        }

        void inc_ref() noexcept { ref_count.fetch_add(1); }

        // This is the most complicated part of the split implementation.
        // On construction, the operation state increments the ref count.
        // Before the operation is started, at least one listener is added to the queue.
        // If the ref count is decreased to one and the there are no listeners in the queue
        // the operation state is the last object holding the shared state and we can safely
        // destroy it
        //
        // it is not thread safe to destroy a split-sender and copy it at the same time
        // this is similar to how a shared_ptr is not thread safe to copy and destroy at the same time
        void dec_ref() noexcept {
            std::size_t count = ref_count.load();
            if (count == 2 && waiting_states.empty_and_not_shutdown()) {
                assert(op_state);
                [[maybe_unused]] auto listeners = waiting_states.pop_all_and_shutdown();
                assert(listeners.empty());
                op_state.reset();
            }
            if (ref_count.fetch_sub(1) == 1) {
                delete this;
            }
        }

        ::beman::execution::inplace_stop_source stop_src{};
        variant_type                            result{};
        state_list_type                         waiting_states{};
        ::std::atomic<::std::size_t>            ref_count{0};
        ::std::optional<child_operation_state>  op_state{};
    };

    template <class Sndr, class Receiver>
    struct local_state final : local_state_base {
        using stop_token_type = ::beman::execution::stop_token_of_t<::beman::execution::env_of_t<Receiver>>;

        struct on_stop_type {
            shared_state<Sndr>* sh_state;
            void                operator()() noexcept { sh_state->stop_src.request_stop(); }
        };

        using on_stop_callback = ::beman::execution::stop_callback_for_t<stop_token_type, on_stop_type>;

        explicit local_state(shared_state<Sndr>* state, Receiver& rcvr) noexcept
            : sh_state(state), receiver{std::addressof(rcvr)} {
            sh_state->inc_ref();
        }

        ~local_state() noexcept { sh_state->dec_ref(); }

        local_state(const local_state&)            = delete;
        local_state& operator=(const local_state&) = delete;
        local_state(local_state&&)                 = delete;
        local_state& operator=(local_state&&)      = delete;

        auto notify() noexcept -> void override {
            on_stop.reset();
            auto stop_token = ::beman::execution::get_stop_token(::beman::execution::get_env(receiver));
            if (stop_token.stop_requested()) {
                ::beman::execution::set_stopped(std::move(*receiver));
            } else {
                assert(sh_state->result.index() > 0);
                assert(!sh_state->result.valueless_by_exception());
                try {
                    ::std::visit(
                        [&]<class Arg>(const Arg& arg) noexcept -> void {
                            if constexpr (!::std::same_as<::std::decay_t<Arg>, ::std::monostate>) {
                                ::std::apply(
                                    [&](auto tag, const auto&... args) noexcept -> void {
                                        tag(::std::move(*receiver), args...);
                                    },
                                    arg);
                            }
                        },
                        sh_state->result);
                } catch (...) {
                    // required by clang-tidy although it is not necessary here
                    // see valueless_by_exception() check above
                    std::terminate();
                }
            }
        }

        void start() noexcept {
            on_stop.emplace(::beman::execution::get_stop_token(::beman::execution::get_env(*receiver)),
                            on_stop_type{sh_state});
            sh_state->add_listener(this);
        }

        std::optional<on_stop_callback> on_stop;
        shared_state<Sndr>*             sh_state;
        Receiver*                       receiver;
    };

    static constexpr auto get_state = []<typename Sender, typename Receiver>(Sender&&  sender,
                                                                             Receiver& receiver) noexcept {
        auto&& wrapper = sender.template get<1>();
        return local_state(wrapper.sh_state, receiver);
    };

    static constexpr auto start = []<class Sndr, class Rcvr>(local_state<Sndr, Rcvr>& state, Rcvr&) noexcept {
        state.start();
    };
};

template <class Sndr>
struct shared_wrapper {
    explicit shared_wrapper(impls_for<split_impl_t>::shared_state<Sndr>* state) noexcept : sh_state(state) {
        if (sh_state) {
            sh_state->inc_ref();
        }
    }

    ~shared_wrapper() noexcept {
        if (sh_state) {
            sh_state->dec_ref();
        }
    }

    shared_wrapper(const shared_wrapper& other) noexcept : sh_state(other.sh_state) {
        if (sh_state) {
            sh_state->inc_ref();
        }
    }

    shared_wrapper(shared_wrapper&& other) noexcept : sh_state(::std::exchange(other.sh_state, nullptr)) {}

    shared_wrapper& operator=(const shared_wrapper& other) noexcept {
        // check for self-assignment was required by clang-tidy
        // although it is not necessary here
        if (this == &other) {
            return *this;
        }
        auto tmp = other;
        ::std::swap(sh_state, tmp.sh_state);
        return *this;
    }

    shared_wrapper& operator=(shared_wrapper&& other) noexcept {
        auto tmp = ::std::move(other);
        ::std::swap(sh_state, tmp.sh_state);
        return *this;
    }

    impls_for<split_impl_t>::shared_state<Sndr>* sh_state;
};

struct split_t {
    template <class Sndr>
    auto transform_sender(Sndr&& sndr) const {
        auto&& child       = ::std::forward<Sndr>(sndr).template get<2>();
        using child_type   = decltype(child);
        using shared_state = ::beman::execution::detail::impls_for<split_impl_t>::shared_state<child_type>;
        auto* sh_state     = new shared_state{::beman::execution::detail::forward_like<Sndr>(child)};
        return ::beman::execution::detail::make_sender(split_impl_t{}, shared_wrapper<child_type>{sh_state});
    }

    template <class Sender>
        requires beman::execution::sender_in<Sender, impls_for<split_impl_t>::split_env>
    auto operator()(Sender&& sender) const {
        auto domain{::beman::execution::detail::get_domain_early(sender)};
        return ::beman::execution::transform_sender(
            domain, ::beman::execution::detail::make_sender(*this, {}, ::std::forward<Sender>(sender)));
    }
};

template <class Sndr, class Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::split_impl_t,
                                             ::beman::execution::detail::shared_wrapper<Sndr>>,
    Env> {
    template <class... Args>
    using make_value_completions =
        ::beman::execution::completion_signatures<::beman::execution::set_value_t(const std::decay_t<Args>&...)>;

    template <class... Args>
    using make_error_completions =
        ::beman::execution::completion_signatures<::beman::execution::set_error_t(const std::decay_t<Args>&)...>;

    using value_completions = ::beman::execution::
        value_types_of_t<Sndr, Env, make_value_completions, ::beman::execution::detail::meta::combine>;

    using error_completions = ::beman::execution::error_types_of_t<Sndr, Env, make_error_completions>;

    using fixed_completions =
        ::beman::execution::completion_signatures<::beman::execution::set_stopped_t(),
                                                  ::beman::execution::set_error_t(std::exception_ptr)>;

    using type = ::beman::execution::detail::meta::unique<
        ::beman::execution::detail::meta::combine<fixed_completions, value_completions, error_completions>>;
};

} // namespace beman::execution::detail

namespace beman::execution {
export using split_t = ::beman::execution::detail::split_t;

export inline constexpr ::beman::execution::split_t split{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename Completion>
struct then_t : ::beman::execution::sender_adaptor_closure<then_t<Completion>> {
    template <::beman::execution::detail::movable_value Fun>
    auto operator()(Fun&& fun) const {
        return ::beman::execution::detail::sender_adaptor{*this, ::std::forward<Fun>(fun)};
    }
    template <::beman::execution::sender Sender, ::beman::execution::detail::movable_value Fun>
    auto operator()(Sender&& sender, Fun&& fun) const {
        auto domain{::beman::execution::detail::get_domain_early(sender)};
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(*this, ::std::forward<Fun>(fun), ::std::forward<Sender>(sender)));
    }
    template <::beman::execution::sender Sender, typename Env>
        requires ::beman::execution::detail::nested_sender_has_affine_on<Sender, Env>
    static auto affine_on(Sender&& sndr, const Env&) noexcept {
        return ::std::forward<Sender>(sndr);
    }
};

template <typename Completion>
struct impls_for<then_t<Completion>> : ::beman::execution::detail::default_impls {
    // NOLINTBEGIN(bugprone-exception-escape)
    static constexpr auto complete =
        []<typename Tag, typename... Args>(auto, auto& fun, auto& receiver, Tag, Args&&... args) noexcept -> void {
        if constexpr (::std::same_as<Completion, Tag>) {
            try {
                auto invoke = [&] { return ::std::invoke(::std::move(fun), ::std::forward<Args>(args)...); };
                if constexpr (::std::same_as<void, decltype(invoke())>) {
                    invoke();
                    ::beman::execution::set_value(::std::move(receiver));
                } else {
                    ::beman::execution::set_value(::std::move(receiver), invoke());
                }
            } catch (...) {
                if constexpr (not noexcept(::std::invoke(::std::move(fun), ::std::forward<Args>(args)...)

                                               )) {
                    static_assert(
                        noexcept(::beman::execution::set_error(::std::move(receiver), ::std::current_exception())));
                    ::beman::execution::set_error(::std::move(receiver), ::std::current_exception());
                }
            }
        } else {
            static_assert(noexcept(Tag()(::std::move(receiver), ::std::forward<Args>(args)...)));
            Tag()(::std::move(receiver), ::std::forward<Args>(args)...);
        }
    };
    // NOLINTEND(bugprone-exception-escape)
};

template <typename T>
struct then_set_value {
    using type = ::beman::execution::set_value_t(T);
};
template <>
struct then_set_value<void> {
    using type = ::beman::execution::set_value_t();
};

template <typename, typename, typename Completion>
struct then_transform {
    using type = Completion;
};

template <typename Fun, typename Completion, typename... T>
struct then_transform<Fun, Completion, Completion(T...)> {
    using type = typename ::beman::execution::detail::then_set_value<
        ::beman::execution::detail::call_result_t<Fun, T...>>::type;
};

template <typename Fun, typename Replace>
struct then_transform_t {
    template <typename Completion>
    using transform = typename ::beman::execution::detail::then_transform<Fun, Replace, Completion>::type;
};

template <typename, typename, typename>
struct then_exception_fun : ::std::false_type {};
template <typename Comp, typename Fun, typename... A>
struct then_exception_fun<Comp, Fun, Comp(A...)>
    : ::std::bool_constant<not noexcept(::std::declval<Fun>()(::std::declval<A>()...))> {};

template <typename, typename, typename>
struct then_exception : ::std::false_type {};
template <typename Comp, typename Fun, typename Completion, typename... Completions>
struct then_exception<Comp, Fun, ::beman::execution::completion_signatures<Completion, Completions...>> {
    static constexpr bool value{
        then_exception_fun<Comp, Fun, Completion>::value ||
        then_exception<Comp, Fun, ::beman::execution::completion_signatures<Completions...>>::value};
};

template <typename Completion, typename Fun, typename Sender, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::then_t<Completion>, Fun, Sender>,
    Env> {
    using type = ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::combine<
        ::beman::execution::detail::meta::transform<
            ::beman::execution::detail::then_transform_t<Fun, Completion>::template transform,
            ::beman::execution::completion_signatures_of_t<Sender, Env>>,
        ::std::conditional_t<
            ::beman::execution::detail::
                then_exception<Completion, Fun, ::beman::execution::completion_signatures_of_t<Sender, Env>>::value,
            ::beman::execution::completion_signatures<::beman::execution::set_error_t(::std::exception_ptr)>,
            ::beman::execution::completion_signatures<>>>>;
};
} // namespace beman::execution::detail

namespace beman::execution {
/*!
 * \brief <code>then_t</code> is the type of <code>then</code>.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export using then_t = ::beman::execution::detail::then_t<::beman::execution::set_value_t>;
/*!
 * \brief <code>upon_error_t</code> is the type of <code>upon_error</code>.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export using upon_error_t = ::beman::execution::detail::then_t<::beman::execution::set_error_t>;
/*!
 * \brief <code>upon_stopped_t</code> is the type of <code>upon_stopped</code>.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export using upon_stopped_t = ::beman::execution::detail::then_t<::beman::execution::set_stopped_t>;

/*!
 * \brief <code>then(_sender_, _fun_)</code> yields a sender transforming a <code>set_value_t(_A_...)</code> completion
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `then` is a callable object of type `then_t`. Invoking <code>then(_sender_, _fun_)</code> or
 * <code>_sender_ | then(_fun_)</code> yields a sender
 * which, when `start`ed starts <code>_sender_</code> and awaits its completion. When
 * <code>_sender_</code> completes `then` proceeds according to this completion:
 * - If the completion is <code>set_value(_a_...)</code>, <code>_fun_(_a_...)</code> is invoked:
 *     - if that invocation throws, `then` completes with <code>set_error(_r_, std::current_exception())</code>;
 * otherwise
 *     - if the invocation returns `void`, `then` completes with <code>set_value(_r_)</code>; otherwise
 *     - if the invocation returns <code>_v_</code>, `then` completes with <code>set_value(_r_, _v_)</code>.
 * - Otherwise, if the completion is <code>set_error(_e_)</code>, `then` completes with <code>set_error(_r_,
 * _e_)</code>
 * - Otherwise, if the completion is <code>set_stopped()</code>, `then` completes with <code>set_stopped(_r_)</code>.
 *
 * <h4>Usage</h4>
 * <pre>
 * then(<i>sender</i>, <i>fun</i>)
 * <i>sender</i> | then(<i>fun</i>)
 * </pre>
 *
 * <h4>Completions Signatures</h4>
 * The completion signatures depends on the completion signatures <code>_CS_</code> of <code>_sender_</code> (the
 * completion signatures will be deduplicated):
 * - For each <code>set_value_t(_A_...)</code> in <code>_CS_</code>,
 *     there is a completion signature
 *     <code>set_value_t(decltype(_fun_(std::declval<_A_>()...)))</code>.
 * - If for any of the <code>set_value_t(_A_...)</code> in
 *     <code>_CS_</code> the expression <code>noexcept(_fun_(std::declval<_A_>()...))</code>
 *     is `false` there is a completion signature <code>set_error_t(std::exception_ptr)</code>.
 * - Each <code>set_error_t(_Error_)</code> in <code>_CS_</code> is copied.
 * - If <code>set_stopped_t()</code> is in <code>_CS_</code> it is copied.
 *
 * <h4>Example</h4>
 *
 * <pre example="doc-then.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <cassert>
 * namespace ex = beman::execution;
 *
 * int main() {
 *     auto result = ex::sync_wait(ex::just(10) | ex::then([](int v) { return v == 3; }));
 *     assert(result);
 *     assert(*result == std::tuple(false));
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::then_t then{};

/*!
 * \brief <code>upon_error(_sender_, _fun_)</code> yields a sender transforming a <code>set_error_t(_E_)</code>
 * completion
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `upon_error` is a callable object of type `upon_error_t`. Invoking <code>upon_error(_sender_, _fun_)</code> or
 * <code>_sender_ | upon_error(_fun_)</code> yields a sender
 * which, when `start`ed starts <code>_sender_</code> and awaits its completion. When
 * <code>_sender_</code> completes `upon_error` proceeds according to this completion:
 * - If the completion is <code>set_error(_e_)</code>, <code>_fun_(_e_)</code> is invoked:
 *     - if that invocation throws, `upon_error` completes with <code>set_error(_r_, std::current_exception())</code>;
 * otherwise
 *     - if the invocation returns `void`, `upon_error` completes with <code>set_value(_r_)</code>; otherwise
 *     - if the invocation returns <code>_v_</code>, `upon_error` completes with <code>set_value(_r_, _v_)</code>.
 * - Otherwise, if the completion is <code>set_value(_a_...)</code>, `upon_error` completes with <code>set_value(_r_,
 * _a_...)</code>
 * - Otherwise, if the completion is <code>set_stopped()</code>, `upon_error` completes with
 * <code>set_stopped(_r_)</code>.
 *
 * <h4>Usage</h4>
 * <pre>
 * upon_error(<i>sender</i>, <i>fun</i>)
 * <i>sender</i> | upon_error(<i>fun</i>)
 * </pre>
 *
 * <h4>Completions Signatures</h4>
 * The completion signatures depend on the completion signatures <code>_CS_</code> of <code>_sender_</code> (the
 * completion signatures will be deduplicated):
 * - For each <code>set_error_t(_E_)</code> in <code>_CS_</code>,
 *     there is a completion signature
 *     <code>set_value_t(decltype(_fun_(std::declval<_E_>())))</code>.
 * - If for any of the <code>set_error_t(_E_)</code> in
 *     <code>_CS_</code> the expression <code>noexcept(_fun_(_std::declval<E>()_))</code>
 *     is `false` there is a completion signature <code>set_error_t(std::exception_ptr)</code>.
 * - Each <code>set_value_t(_A_...)</code> in <code>_CS_</code> is copied.
 * - If <code>set_stopped_t()</code> is in <code>_CS_</code> it is copied.
 *
 * <h4>Example</h4>
 *
 * <pre example="doc-upon_error.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <cassert>
 * namespace ex = beman::execution;
 *
 * int main() {
 *     auto result = ex::sync_wait(ex::just_error(10) | ex::upon_error([](int v) { return v == 3; }));
 *     assert(result);
 *     assert(*result == std::tuple(false));
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::upon_error_t upon_error{};

/*!
 * \brief <code>upon_stopped(_sender_, _fun_)</code> yields a sender transforming a <code>set_stopped_t()</code>
 * completion
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 *
 * \details
 * `upon_stopped` is a callable object of type `upon_stopped_t`. Invoking <code>upon_stopped(_sender_, _fun_)</code> or
 * <code>_sender_ | upon_stopped(_fun_)</code> yields a sender
 * which, when `start`ed starts <code>_sender_</code> and awaits its completion. When
 * <code>_sender_</code> completes `upon_stopped` proceeds according to this completion:
 * - If the completion is <code>set_stopped(_e_)</code>, <code>_fun_(_e_)</code> is invoked:
 *     - if that invocation throws, `upon_stopped` completes with <code>set_error(_r_,
 * std::current_exception())</code>; otherwise
 *     - if the invocation returns `void`, `upon_stopped` completes with <code>set_value(_r_)</code>; otherwise
 *     - if the invocation returns <code>_v_</code>, `upon_stopped` completes with <code>set_value(_r_, _v_)</code>.
 * - Otherwise, if the completion is <code>set_value(_a_...)</code>, `upon_stopped` completes with <code>set_value(_r_,
 * _a_...)</code>
 * - Otherwise, if the completion is <code>set_error(_e_)</code>, `upon_stopped` completes with <code>set_error(_r_,
 * _e_)</code>.
 *
 * <h4>Usage</h4>
 * <pre>
 * upon_stopped(<i>sender</i>, <i>fun</i>)
 * <i>sender</i> | upon_stopped(<i>fun</i>)
 * </pre>
 *
 * <h4>Completions Signatures</h4>
 * The completion signatures depend on the completion signatures <code>_CS_</code> of <code>_sender_</code> (the
 * completion signatures will be deduplicated):
 * - There is a completion signature <code>set_value_t(decltype(_fun_()))</code>.
 * - If the expression <code>noexcept(_fun_())</code> is `false` there is a completion signature
 * <code>set_error_t(std::exception_ptr)</code>.
 * - Each <code>set_value_t(_A_...)</code> in <code>_CS_</code> is copied.
 * - Each <code>set_error_t(_A_...)</code> in <code>_CS_</code> is copied.
 *
 * <h4>Example</h4>
 *
 * <pre example="doc-upon_stopped.cpp">
 * #include <beman/execution/execution.hpp>
 * #include <cassert>
 * namespace ex = beman::execution;
 *
 * int main() {
 *     auto result = ex::sync_wait(ex::just_stopped() | ex::upon_stopped([]() { return true; }));
 *     assert(result);
 *     assert(*result == std::tuple(true));
 * }
 * </pre>
 */
export inline constexpr ::beman::execution::upon_stopped_t upon_stopped{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct when_all_t {
    template <::beman::execution::sender... Sender>
        requires(0u != sizeof...(Sender)) &&
                ((::beman::execution::detail::meta::size_v<
                      ::beman::execution::value_types_of_t<Sender,
                                                           ::beman::execution::env<>,
                                                           ::std::tuple,
                                                           ::beman::execution::detail::type_list>> == 1u) &&
                 ...) &&
                requires(Sender&&... s) {
                    typename ::std::common_type_t<decltype(::beman::execution::detail::get_domain_early(s))...>;
                }
    auto operator()(Sender&&... sender) const {
        using common_t =
            typename ::std::common_type_t<decltype(::beman::execution::detail::get_domain_early(sender))...>;
        return ::beman::execution::transform_sender(
            common_t(), ::beman::execution::detail::make_sender(*this, {}, ::std::forward<Sender>(sender)...));
    }
};

template <typename>
struct when_all_value_types;
template <typename... T>
struct when_all_value_types<::beman::execution::detail::type_list<T...>> {
    using type = ::beman::execution::completion_signatures<::beman::execution::set_value_t(T...)>;
};

template <>
struct impls_for<::beman::execution::detail::when_all_t> : ::beman::execution::detail::default_impls {
    static constexpr auto get_attrs{[](auto&&, auto&&... sender) {
        using common_t =
            typename ::std::common_type_t<decltype(::beman::execution::detail::get_domain_early(sender))...>;
        if constexpr (::std::same_as<common_t, ::beman::execution::default_domain>)
            return ::beman::execution::env<>{};
        else
            return ::beman::execution::detail::make_env(::beman::execution::get_domain, common_t{});
    }};
    static constexpr auto get_env{
        []<typename State, typename Receiver>(auto&&, State& state, const Receiver& receiver) noexcept {
            return ::beman::execution::detail::join_env(
                ::beman::execution::detail::make_env(::beman::execution::get_stop_token, state.stop_src.get_token()),
                ::beman::execution::get_env(receiver));
        }};

    enum class disposition : unsigned char { started, error, stopped };

    template <typename Receiver, typename... Sender>
    struct state_type {
        struct nonesuch {};
        using env_t        = ::beman::execution::env_of_t<Receiver>;
        using values_tuple = ::std::tuple<
            ::beman::execution::
                value_types_of_t<Sender, env_t, ::beman::execution::detail::decayed_tuple, ::std::optional>...>;
        using errors_variant = ::beman::execution::detail::meta::to<
            ::std::variant,
            ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::prepend<
                nonesuch,
                ::beman::execution::detail::meta::prepend<
                    ::std::exception_ptr,
                    ::beman::execution::detail::meta::combine<::beman::execution::detail::meta::to<
                        ::beman::execution::detail::type_list,
                        ::beman::execution::detail::meta::combine<::beman::execution::error_types_of_t<
                            Sender,
                            env_t,
                            ::beman::execution::detail::decayed_type_list>...>>>>>>>;
        using stop_callback = ::beman::execution::stop_callback_for_t<
            ::beman::execution::stop_token_of_t<::beman::execution::env_of_t<Receiver>>,
            ::beman::execution::detail::on_stop_request<state_type>>;

        void arrive(Receiver& recvr) noexcept {
            if (0u == --count)
                this->complete(recvr);
        }

        void complete(Receiver& recvr) noexcept {
            switch (disposition(this->disp)) {
            case disposition::started: {
                auto tie = []<typename... T>(::std::tuple<T...>& t) noexcept {
                    return ::std::apply([](auto&... a) { return ::std::tie(a...); }, t);
                };
                auto set = [&](auto&... t) noexcept {
                    ::beman::execution::set_value(::std::move(recvr), ::std::move(t)...);
                };

                this->on_stop.reset();
                ::std::apply([&](auto&... opts) noexcept { ::std::apply(set, ::std::tuple_cat(tie(*opts)...)); },
                             this->values);
            } break;
            case disposition::error:
                this->on_stop.reset();
                try {
                    ::std::visit(
                        [&]<typename Error>(Error& error) noexcept {
                            if constexpr (!::std::same_as<Error, nonesuch>) {
                                ::beman::execution::set_error(::std::move(recvr), ::std::move(error));
                            }
                        },
                        this->errors);
                } catch (...) {
                    ::beman::execution::set_error(::std::move(recvr), ::std::current_exception());
                }
                break;
            case disposition::stopped:
                this->on_stop.reset();
                ::beman::execution::set_stopped(::std::move(recvr));
                break;
            }
        }

        auto request_stop() -> void {
            if (1u == ++this->count)
                --this->count;
            else {
                this->stop_src.request_stop();
                this->arrive(*this->receiver);
            }
        }

        Receiver*                               receiver{};
        ::std::atomic<::std::size_t>            count{sizeof...(Sender)};
        ::beman::execution::inplace_stop_source stop_src{};
        ::std::atomic<disposition>              disp{disposition::started};
        errors_variant                          errors{};
        values_tuple                            values{};
        ::std::optional<stop_callback>          on_stop{::std::nullopt};
    };

    template <typename Receiver>
    struct make_state {
        template <::beman::execution::sender_in<::beman::execution::env_of_t<Receiver>>... Sender>
        auto operator()(auto, auto, Sender&&...) const {
            return state_type<Receiver, Sender...>{};
        }
    };
    static constexpr auto get_state{[]<typename Sender, typename Receiver>(Sender&& sender, Receiver&) noexcept(
                                        noexcept(std::forward<Sender>(sender).apply(make_state<Receiver>{}))) {
        return std::forward<Sender>(sender).apply(make_state<Receiver>{});
    }};
    static constexpr auto start{[]<typename State, typename Receiver, typename... Ops>(
                                    State& state, Receiver& receiver, Ops&... ops) noexcept -> void {
        state.receiver = &receiver;
        state.on_stop.emplace(::beman::execution::get_stop_token(::beman::execution::get_env(receiver)),
                              ::beman::execution::detail::on_stop_request{state});
        if (state.stop_src.stop_requested()) {
            state.on_stop.reset();
            ::beman::execution::set_stopped(std::move(receiver));
        } else {
            (::beman::execution::start(ops), ...);
        }
    }};
    static constexpr auto complete{
        []<typename Index, typename State, typename Receiver, typename Set, typename... Args>(
            Index, State& state, Receiver& receiver, Set, Args&&... args) noexcept -> void {
            if constexpr (::std::same_as<Set, ::beman::execution::set_error_t>) {
                if (disposition::error != state.disp.exchange(disposition::error)) {
                    state.stop_src.request_stop();
                    try {
                        state.errors.template emplace<typename ::std::decay<Args...>::type>(
                            ::std::forward<Args>(args)...);
                    } catch (...) {
                        state.errors.template emplace<::std::exception_ptr>(::std::current_exception());
                    }
                }
            } else if constexpr (::std::same_as<Set, ::beman::execution::set_stopped_t>) {
                auto expected = disposition::started;
                if (state.disp.compare_exchange_strong(expected, disposition::stopped)) {
                    state.stop_src.request_stop();
                }
            } else if constexpr (!::std::same_as<decltype(State::values), ::std::tuple<>>) {
                if (state.disp == disposition::started) {
                    auto& opt = ::std::get<Index::value>(state.values);
                    try {
                        opt.emplace(::std::forward<Args>(args)...);
                    } catch (...) {
                        if (disposition::error != state.disp.exchange(disposition::error)) {
                            state.stop_src.request_stop();
                            state.errors.template emplace<::std::exception_ptr>(::std::current_exception());
                        }
                    }
                }
            }
            state.arrive(receiver);
        }};
};

template <typename Data, typename Env, typename... Sender>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::when_all_t, Data, Sender...>,
    Env> {
    template <typename... E>
    struct error_comps_t {
        using type = ::beman::execution::completion_signatures<::beman::execution::set_error_t(E)...>;
    };
    template <typename... E>
    using error_comps = typename error_comps_t<E...>::type;

    using value_types =
        typename ::beman::execution::detail::when_all_value_types<::beman::execution::detail::meta::combine<
            ::beman::execution::
                value_types_of_t<Sender, Env, ::beman::execution::detail::type_list, ::std::type_identity_t>...>>::
            type;
    using error_types = ::beman::execution::detail::meta::unique<
        ::beman::execution::detail::meta::combine<::beman::execution::error_types_of_t<Sender, Env, error_comps>...>>;
    using stopped_types =
        ::std::conditional_t<(false || ... || ::beman::execution::sends_stopped<Sender, Env>),
                             ::beman::execution::completion_signatures<::beman::execution::set_stopped_t()>,
                             ::beman::execution::completion_signatures<>>;
    using type = ::beman::execution::detail::meta::combine<value_types, error_types, stopped_types>;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using when_all_t = ::beman::execution::detail::when_all_t;
export inline constexpr ::beman::execution::when_all_t when_all{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct write_env_t {
    template <::beman::execution::sender Sender, ::beman::execution::detail::queryable Env>
    constexpr auto operator()(Sender&& sender, Env&& env) const {
        return ::beman::execution::detail::make_sender(
            *this, ::std::forward<Env>(env), ::std::forward<Sender>(sender));
    }
    static auto name() { return "write_env_t"; }
    template <::beman::execution::sender Sender, typename Env>
        requires ::beman::execution::detail::nested_sender_has_affine_on<Sender, Env>
    static auto affine_on(Sender&& sndr, const Env&) noexcept {
        return ::std::forward<Sender>(sndr);
    }
};

template <typename NewEnv, typename Child, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::write_env_t, NewEnv, Child>,
    Env> {
    using type = decltype(::beman::execution::get_completion_signatures(
        ::std::declval<Child>(),
        ::beman::execution::detail::join_env(::std::declval<NewEnv>(), ::std::declval<Env>())));
};

template <>
struct impls_for<write_env_t> : ::beman::execution::detail::default_impls {
    static constexpr auto get_env = [](auto, const auto& state, const auto& receiver) noexcept {
        return ::beman::execution::detail::join_env(state, ::beman::execution::get_env(receiver));
    };
};

inline constexpr write_env_t write_env{};
} // namespace beman::execution::detail

namespace beman::execution {
export using write_env_t = ::beman::execution::detail::write_env_t;
export inline constexpr write_env_t write_env{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <::beman::execution::scope_token Token, ::beman::execution::sender Sender>
struct associate_data {
    using wrap_sender = ::std::remove_cvref_t<decltype(::std::declval<Token&>().wrap(::std::declval<Sender>()))>;

    explicit associate_data(Token t, Sender&& s) : token(t), sender(this->token.wrap(::std::forward<Sender>(s))) {
        if (!token.try_associate()) {
            this->sender.reset();
        }
    }
    associate_data(const associate_data& other) noexcept(::std::is_nothrow_copy_constructible_v<wrap_sender> &&
                                                         noexcept(token.try_associate()))
        : token(other.token), sender() {
        if (other.sender && this->token.try_associate()) {
            try {
                this->sender.emplace(*other.sender);
            } catch (...) {
                this->token.disassociate();
            }
        }
    }
    associate_data(associate_data&& other) noexcept(::std::is_nothrow_move_constructible_v<wrap_sender>)
        : token(other.token), sender(::std::move(other.sender)) {
        other.sender.reset();
    }
    auto operator=(const associate_data&) -> associate_data& = delete;
    auto operator=(associate_data&&) -> associate_data&      = delete;
    ~associate_data() {
        if (this->sender) {
            this->sender.reset();
            this->token.disassociate();
        }
    }

    auto release() -> ::std::optional<::std::pair<Token, wrap_sender>> {
        return this->sender ? (std::unique_ptr<std::optional<wrap_sender>, decltype([](auto* opt) { opt->reset(); })>(
                                   &this->sender),
                               ::std::optional{::std::pair{::std::move(this->token), ::std::move(*this->sender)}})
                            : ::std::optional<::std::pair<Token, wrap_sender>>{};
    }

    Token                        token;
    ::std::optional<wrap_sender> sender;
};
template <::beman::execution::scope_token Token, ::beman::execution::sender Sender>
associate_data(Token, Sender&&) -> associate_data<Token, Sender>;

struct associate_t {
    template <::beman::execution::sender Sender, ::beman::execution::scope_token Token>
    auto operator()(Sender&& sender, Token&& token) const {
        auto domain(::beman::execution::detail::get_domain_early(sender));
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this,
                ::beman::execution::detail::associate_data(::std::forward<Token>(token),
                                                           ::std::forward<Sender>(sender))));
    }
};

template <>
struct impls_for<associate_t> : ::beman::execution::detail::default_impls {
    template <typename, typename>
    struct get_noexcept : ::std::false_type {};
    template <typename Tag, typename Data, typename Receiver>
    struct get_noexcept<::beman::execution::detail::basic_sender<Tag, Data>, Receiver>
        : ::std::bool_constant<
              ::std::is_nothrow_move_constructible_v<typename ::std::remove_cvref_t<Data>::wrap_sender>&& ::beman::
                  execution::detail::nothrow_callable<::beman::execution::connect_t,
                                                      typename ::std::remove_cvref_t<Data>::wrap_sender,
                                                      Receiver>> {};

    static constexpr auto get_state =
        []<typename Sender, typename Receiver>(Sender&& sender, Receiver& receiver) noexcept(
            ::std::is_nothrow_constructible_v<::std::remove_cvref_t<Sender>, Sender>&&
                get_noexcept<::std::remove_cvref_t<Sender>, Receiver>::value) {
            auto [_, data] = ::std::forward<Sender>(sender);
            auto dataParts{data.release()};

            using scope_token = decltype(dataParts->first);
            using wrap_sender = decltype(dataParts->second);
            using op_t        = decltype(::beman::execution::connect(::std::move(dataParts->second),
                                                              ::std::forward<Receiver>(receiver)));

            struct op_state {
                using sop_t        = op_t;
                using sscope_token = scope_token;
                struct assoc_t {
                    sscope_token tok;
                    sop_t        op;
                };

                bool associated{false};
                union {
                    Receiver* rcvr;
                    assoc_t   assoc;
                };
                explicit op_state(Receiver& r) noexcept : rcvr(::std::addressof(r)) {}
                explicit op_state(sscope_token tk, wrap_sender&& sndr, Receiver& r) try
                    : associated(true), assoc(tk, ::beman::execution::connect(::std::move(sndr), ::std::move(r))) {
                } catch (...) {
                    tk.disassociate();
                    throw;
                }
                op_state(op_state&&) = delete;
                ~op_state() {
                    if (this->associated) {
                        this->assoc.op.~sop_t();
                        this->assoc.tok.disassociate();
                        this->assoc.tok.~sscope_token();
                    }
                }
                auto run() noexcept -> void {
                    if (this->associated) {
                        ::beman::execution::start(this->assoc.op);
                    } else {
                        ::beman::execution::set_stopped(::std::move(*this->rcvr));
                    }
                }
            };
            return dataParts ? op_state(::std::move(dataParts->first), ::std::move(dataParts->second), receiver)
                             : op_state(receiver);
        };
    static constexpr auto start = [](auto& state, auto&&) noexcept -> void { state.run(); };
};

template <typename Data, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::associate_t, Data>,
    Env> {
    using type = ::beman::execution::completion_signatures<::beman::execution::set_value_t()>;
};
} // namespace beman::execution::detail

namespace beman::execution {
export using associate_t = ::beman::execution::detail::associate_t;
export inline constexpr associate_t associate{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution {
/*!
 * \brief Turn an entity, e.g., a sender, into an awaitable.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export struct as_awaitable_t {
    template <typename Expr, typename Promise>
    auto operator()(Expr&& expr, Promise& promise) const {
        if constexpr (requires { ::std::forward<Expr>(expr).as_awaitable(promise); }) {
            static_assert(
                ::beman::execution::detail::is_awaitable<decltype(::std::forward<Expr>(expr).as_awaitable(promise)),
                                                         Promise>,
                "as_awaitable must return an awaitable");
            return ::std::forward<Expr>(expr).as_awaitable(promise);
        } else if constexpr (::beman::execution::detail::
                                 is_awaitable<Expr, ::beman::execution::detail::unspecified_promise> ||
                             !::beman::execution::detail::awaitable_sender<Expr, Promise>) {
            return ::std::forward<Expr>(expr);
        } else {
            return ::beman::execution::detail::sender_awaitable<Expr, Promise>{::std::forward<Expr>(expr), promise};
        }
    }
};
export inline constexpr ::beman::execution::as_awaitable_t as_awaitable{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct counting_scope_join_t {
    template <::beman::execution::receiver>
    struct state;

    auto operator()(::beman::execution::detail::counting_scope_base* ptr) const {
        return ::beman::execution::detail::make_sender(*this, ptr);
    }
};
inline constexpr counting_scope_join_t counting_scope_join{};

template <typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::counting_scope_join_t,
                                             ::beman::execution::detail::counting_scope_base*>,
    Env> {
    using type = ::beman::execution::completion_signatures<::beman::execution::set_value_t()>;
};

} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

template <::beman::execution::receiver Receiver>
struct beman::execution::detail::counting_scope_join_t::state : ::beman::execution::detail::counting_scope_base::node {
    using op_t = decltype(::beman::execution::connect(::beman::execution::schedule(::beman::execution::get_scheduler(
                                                          ::beman::execution::get_env(::std::declval<Receiver&>()))),
                                                      ::std::declval<Receiver&>()));

    ::beman::execution::detail::counting_scope_base* scope;
    explicit state(::beman::execution::detail::counting_scope_base* s, Receiver& r)
        : scope(s),
          receiver(r),
          op(::beman::execution::connect(::beman::execution::schedule(::beman::execution::get_scheduler(
                                             ::beman::execution::get_env(this->receiver))),
                                         this->receiver)) {}
    virtual ~state() = default;

    auto complete() noexcept -> void override { ::beman::execution::start(this->op); }
    auto complete_inline() noexcept -> void override { ::beman::execution::set_value(::std::move(this->receiver)); }

    auto start() noexcept -> void { this->scope->start_node(this); }

    ::std::remove_cvref_t<Receiver>& receiver;
    op_t                             op;
};

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <>
struct impls_for<::beman::execution::detail::counting_scope_join_t> : ::beman::execution::detail::default_impls {
    static constexpr auto get_state = []<typename Receiver>(auto&& sender, Receiver& receiver) noexcept(false) {
        auto [_, self] = sender;
        return ::beman::execution::detail::counting_scope_join_t::state<Receiver>(self, receiver);
    };
    static constexpr auto start = [](auto& s, auto&) noexcept { s.start(); };
};
} // namespace beman::execution::detail

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {

/**
 * @brief The affine_on_t struct is a sender adaptor closure that transforms a sender
 *        to complete on the scheduler obtained from the receiver's environment.
 *
 * This adaptor implements scheduler affinity to adapt a sender to complete on the
 * scheduler obtained the receiver's environment. The get_scheduler query is used
 * to obtain the scheduler on which the sender gets started.
 */
struct affine_on_t : ::beman::execution::sender_adaptor_closure<affine_on_t> {
    /**
     * @brief Adapt a sender with affine_on.
     *
     * @tparam Sender The deduced type of the sender to be transformed.
     * @param sender The sender to be transformed.
     * @return An adapted sender to complete on the scheduler it was started on.
     */
    template <::beman::execution::sender Sender>
    auto operator()(Sender&& sender) const {
        return ::beman::execution::detail::transform_sender(
            ::beman::execution::detail::get_domain_early(sender),
            ::beman::execution::detail::make_sender(
                *this, ::beman::execution::env<>{}, ::std::forward<Sender>(sender)));
    }

    /**
     * @brief Overload for creating a sender adaptor from affine_on.
     *
     * @return A sender adaptor for the affine_on_t.
     */
    auto operator()() const { return ::beman::execution::detail::sender_adaptor{*this}; }

    template <typename Ev>
    struct ao_env {
        Ev   ev_;
        auto query(const ::beman::execution::get_stop_token_t&) const noexcept
            -> ::beman::execution::never_stop_token {
            return ::beman::execution::never_stop_token();
        }
        template <typename Q>
        auto query(const Q& q) const noexcept -> decltype(q(this->ev_)) {
            return q(this->ev_);
        }
    };
    template <typename Ev>
    ao_env(const Ev&) -> ao_env<Ev>;

    /**
     * @brief affine_on is implemented by transforming it into a use of schedule_from.
     *
     * The constraints ensure that the environment provides a scheduler which is
     * infallible and, thus, can be used to guarantee completion on the correct
     * scheduler.
     *
     * The implementation first tries to see if the child sender's tag has a custom
     * affine_on implementation. If it does, that is used. Otherwise, the default
     * implementation gets a scheduler from the environment and uses schedule_from
     * to adapt the sender to complete on that scheduler.
     *
     * @tparam Sender The type of the sender to be transformed.
     * @tparam Env The type of the environment providing the scheduler.
     * @param sender The sender to be transformed.
     * @param env The environment providing the scheduler.
     * @return A transformed sender that is affined to the scheduler.
     */
    template <::beman::execution::sender Sender, typename Env>
        requires ::beman::execution::detail::sender_for<Sender, affine_on_t> && requires(const Env& env) {
            { ::beman::execution::get_scheduler(env) } -> ::beman::execution::scheduler;
            { ::beman::execution::schedule(::beman::execution::get_scheduler(env)) } -> ::beman::execution::sender;
            {
                ::beman::execution::get_completion_signatures(
                    ::beman::execution::schedule(::beman::execution::get_scheduler(env)),
                    ::beman::execution::detail::join_env(
                        ::beman::execution::env{::beman::execution::prop{
                            ::beman::execution::get_stop_token, ::beman::execution::never_stop_token{}, {}}},
                        env))
            } -> ::std::same_as<::beman::execution::completion_signatures<::beman::execution::set_value_t()>>;
        }
    static auto transform_sender(Sender&& sender, const Env& ev) {
        [[maybe_unused]] auto& [tag, data, child] = sender;
        using child_tag_t = ::beman::execution::tag_of_t<::std::remove_cvref_t<decltype(child)>>;

        if constexpr (::beman::execution::detail::nested_sender_has_affine_on<Sender, Env>) {
            constexpr child_tag_t t{};
            return t.affine_on(::beman::execution::detail::forward_like<Sender>(child), ev);
        } else {
            return ::beman::execution::write_env(
                ::beman::execution::schedule_from(
                    ::beman::execution::get_scheduler(ev),
                    ::beman::execution::write_env(::beman::execution::detail::forward_like<Sender>(child), ev)),
                ao_env(ev));
        }
    }
};

} // namespace beman::execution::detail

namespace beman::execution {
/**
 * @brief affine_on is a CPO, used to adapt a sender to complete on the scheduler
 *      it got started on which is derived from get_scheduler on the receiver's environment.
 */
export using affine_on_t = beman::execution::detail::affine_on_t;
export inline constexpr affine_on_t affine_on{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
// specialize default_domain appropriately
/*!
 * \brief The actual implementation of the continues_on customization point object
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
struct continues_on_t {
    template <::beman::execution::detail::sender_for<continues_on_t> Sender, typename... Env>
    static auto transform_sender(Sender&& sender, Env&&...) {
        auto&& data{sender.template get<1>()};
        auto&& child{sender.template get<2>()};
        return ::beman::execution::schedule_from(std::move(data), std::move(child));
    }
    template <::beman::execution::scheduler Scheduler>
    auto operator()(Scheduler&& scheduler) const {
        return ::beman::execution::detail::sender_adaptor{*this, ::std::forward<Scheduler>(scheduler)};
    }
    template <::beman::execution::sender Sender, ::beman::execution::scheduler Scheduler>
    auto operator()(Sender&& sender, Scheduler&& scheduler) const {
        auto domain(::beman::execution::detail::get_domain_early(sender));
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this, std::forward<Scheduler>(scheduler), ::std::forward<Sender>(sender)));
    }
};

/*!
 * \brief Specialization of impls_for to implement the continues_on functionality
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <>
struct impls_for<::beman::execution::detail::continues_on_t> : ::beman::execution::detail::default_impls {
    static constexpr auto get_attrs{[](const auto& data, const auto& child) noexcept -> decltype(auto) {
        return ::beman::execution::detail::join_env(
            ::beman::execution::detail::sched_attrs(data),
            ::beman::execution::detail::fwd_env(::beman::execution::get_env(child)));
    }};
};

/*!
 * \brief Get the sender's domain when the sender is continue_on
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 * \internal
 */
template <::beman::execution::detail::sender_for<::beman::execution::detail::continues_on_t> Sender, typename Env>
auto get_domain_late(Sender&& sender, Env&&) {
    auto scheduler{sender.template get<1>()};
    return ::beman::execution::detail::query_with_default(
        ::beman::execution::get_domain, scheduler, ::beman::execution::default_domain{});
}
} // namespace beman::execution::detail

namespace beman::execution {
export using continues_on_t = ::beman::execution::detail::continues_on_t;
/*!
 * \brief Customization point object to create a `continues_on` sender.
 * \headerfile beman/execution/execution.hpp <beman/execution/execution.hpp>
 */
export inline constexpr continues_on_t continues_on{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct starts_on_t {
    template <::beman::execution::detail::sender_for<::beman::execution::detail::starts_on_t> Sender, typename Env>
    auto transform_env(Sender&& sender, Env&& env) const noexcept {
        auto&& scheduler{sender.template get<1>()};
        return ::beman::execution::detail::join_env(::beman::execution::detail::sched_env(scheduler),
                                                    ::beman::execution::detail::fwd_env(env));
    }
    template <::beman::execution::detail::sender_for<::beman::execution::detail::starts_on_t> Sender, typename... Env>
    auto transform_sender(Sender&& sender, Env&&...) const noexcept {
        auto&& scheduler{sender.template get<1>()};
        auto&& new_sender{sender.template get<2>()};
        return ::beman::execution::let_value(
            ::beman::execution::schedule(scheduler),
            [new_sender = ::beman::execution::detail::forward_like<Sender>(new_sender)]() mutable noexcept(
                ::std::is_nothrow_constructible_v<::std::decay_t<Sender>>) { return ::std::move(new_sender); });
    }

    template <::beman::execution::scheduler Scheduler, ::beman::execution::sender Sender>
    auto operator()(Scheduler&& scheduler, Sender&& sender) const {
        auto domain{::beman::execution::detail::query_with_default(
            ::beman::execution::get_domain, scheduler, ::beman::execution::default_domain{})};
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this, ::std::forward<Scheduler>(scheduler), ::std::forward<Sender>(sender)));
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
export using starts_on_t = ::beman::execution::detail::starts_on_t;
export inline constexpr ::beman::execution::detail::starts_on_t starts_on{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct when_all_with_variant_t {
    // template <::beman::execution::detail::sender_for<when_all_with_variant_t> Sender>
    template <::beman::execution::sender Sender>
    auto transform_sender(Sender&& sender, auto&&...) const noexcept {
        return ::std::forward<Sender>(sender).apply([](auto&&, auto&&, auto&&... child) {
            return ::beman::execution::when_all(
                ::beman::execution::into_variant(::beman::execution::detail::forward_like<Sender>(child))...);
        });
    }

    template <::beman::execution::sender... Sender>
    auto operator()(Sender&&... sender) const {
        using domain_t =
            typename ::std::common_type_t<decltype(::beman::execution::detail::get_domain_early(sender))...>;
        return ::beman::execution::transform_sender(
            domain_t{}, ::beman::execution::detail::make_sender(*this, {}, ::std::forward<Sender>(sender)...));
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
export using when_all_with_variant_t = ::beman::execution::detail::when_all_with_variant_t;
export inline constexpr ::beman::execution::when_all_with_variant_t when_all_with_variant{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

namespace beman::execution {
export template <::beman::execution::detail::class_type Promise>
struct with_awaitable_senders {
    template <class OtherPromise>
        requires(!::std::same_as<OtherPromise, void>)
    void set_continuation(::std::coroutine_handle<OtherPromise> h) noexcept {
        contination_ = h;
        if constexpr (requires(OtherPromise& other) { other.unhandled_stopped(); }) {
            stopped_handler_ = [](void* p) noexcept -> ::std::coroutine_handle<> {
                return ::std::coroutine_handle<OtherPromise>::from_address(p).promise().unhandled_stopped();
            };
        } else {
            stopped_handler_ = &default_unhandled_stopped;
        }
    }

    ::std::coroutine_handle<> continuation() const noexcept { return contination_; }

    ::std::coroutine_handle<> unhandled_stopped() noexcept { return stopped_handler_(contination_.address()); }

    template <class Value>
    auto await_transform(Value&& value)
        -> ::beman::execution::detail::call_result_t<::beman::execution::as_awaitable_t, Value, Promise&> {
        return ::beman::execution::as_awaitable(::std::forward<Value>(value), static_cast<Promise&>(*this));
    }

  private:
    friend Promise;
    with_awaitable_senders() = default;

    [[noreturn]] static auto default_unhandled_stopped(void*) noexcept -> ::std::coroutine_handle<> {
        ::std::terminate();
    }

    ::std::coroutine_handle<> contination_{};
    ::std::coroutine_handle<> (*stopped_handler_)(void*) noexcept = &default_unhandled_stopped;
};

} // namespace beman::execution

// ----------------------------------------------------------------------------

namespace beman::execution {
export class counting_scope;
}

// ----------------------------------------------------------------------------

class beman::execution::counting_scope : public ::beman::execution::detail::counting_scope_base {
  public:
    class token;

    auto join() noexcept -> ::beman::execution::sender auto {
        return ::beman::execution::detail::counting_scope_join(this);
    }
    auto get_token() noexcept -> token;
    auto request_stop() noexcept -> void { this->stop_source.request_stop(); }

  private:
    ::beman::execution::inplace_stop_source stop_source{};
};

// ----------------------------------------------------------------------------

class beman::execution::counting_scope::token : public ::beman::execution::detail::counting_scope_base::token {
  public:
    template <::beman::execution::sender Sender>
    auto wrap(Sender&& sender) const noexcept -> ::beman::execution::sender auto {
        return ::beman::execution::detail::stop_when(
            ::std::forward<Sender>(sender),
            static_cast<::beman::execution::counting_scope*>(this->scope)->stop_source.get_token());
    }

  private:
    friend class beman::execution::counting_scope;
    explicit token(::beman::execution::counting_scope* s)
        : ::beman::execution::detail::counting_scope_base::token(s) {}
};
static_assert(::beman::execution::scope_token<::beman::execution::counting_scope::token>);

// ----------------------------------------------------------------------------

inline auto beman::execution::counting_scope::get_token() noexcept -> beman::execution::counting_scope::token {
    return beman::execution::counting_scope::token(this);
}

// ----------------------------------------------------------------------------

namespace beman::execution {
export class simple_counting_scope;
}

// ----------------------------------------------------------------------------

class beman::execution::simple_counting_scope : public ::beman::execution::detail::counting_scope_base {
  public:
    class token;

    auto get_token() noexcept -> token;
    auto join() noexcept -> ::beman::execution::sender auto {
        return ::beman::execution::detail::counting_scope_join(this);
    }
};

// ----------------------------------------------------------------------------

class beman::execution::simple_counting_scope::token : public ::beman::execution::detail::counting_scope_base::token {
  public:
    template <::beman::execution::sender Sender>
    auto wrap(Sender&& sender) const noexcept -> Sender&& {
        return ::std::forward<Sender>(sender);
    }

  private:
    friend class beman::execution::simple_counting_scope;
    explicit token(::beman::execution::detail::counting_scope_base* s)
        : ::beman::execution::detail::counting_scope_base::token(s) {}
};

// ----------------------------------------------------------------------------

inline auto beman::execution::simple_counting_scope::get_token() noexcept
    -> beman::execution::simple_counting_scope::token {
    return beman::execution::simple_counting_scope::token(this);
}

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
template <typename>
struct non_throwing_args_copy;
template <typename Rc, typename... A>
struct non_throwing_args_copy<Rc(A...)> {
    static constexpr bool value = (true && ... && ::std::is_nothrow_constructible_v<::std::decay_t<A>, A>);
};
template <typename S>
inline constexpr bool non_throwing_args_copy_v{non_throwing_args_copy<S>::value};

template <typename Completions>
struct spawn_future_state_base;
template <typename... Sigs>
struct spawn_future_state_base<::beman::execution::completion_signatures<Sigs...>> {
    static constexpr bool has_non_throwing_args_copy = (true && ... && non_throwing_args_copy_v<Sigs>);
    using result_t                                   = ::beman::execution::detail::meta::unique<
                                          ::std::conditional_t<has_non_throwing_args_copy,
                                                               ::std::variant<::std::monostate, ::beman::execution::detail::as_tuple_t<Sigs>...>,
                                                               ::std::variant<::std::monostate,
                                                                              ::std::tuple<::beman::execution::set_error_t, ::std::exception_ptr>,
                                                                              ::beman::execution::detail::as_tuple_t<Sigs>...>>>;

    result_t result{};
    virtual ~spawn_future_state_base()       = default;
    virtual auto complete() noexcept -> void = 0;
};

template <typename Completions>
struct spawn_future_receiver {
    using receiver_concept = ::beman::execution::receiver_t;
    using state_t          = ::beman::execution::detail::spawn_future_state_base<Completions>;

    state_t* state{};

    template <typename... A>
    auto set_value(A&&... a) && noexcept -> void {
        this->set_complete<::beman::execution::set_value_t>(::std::forward<A>(a)...);
    }
    template <typename E>
    auto set_error(E&& e) && noexcept -> void {
        this->set_complete<::beman::execution::set_error_t>(::std::forward<E>(e));
    }
    auto set_stopped() && noexcept -> void { this->set_complete<::beman::execution::set_stopped_t>(); }

    template <typename Tag, typename... T>
    auto set_complete(T&&... t) noexcept {
        try {
            this->state->result.template emplace<::beman::execution::detail::decayed_tuple<Tag, T...>>(
                Tag(), ::std::forward<T>(t)...);
        } catch (...) {
            if constexpr (!state_t::has_non_throwing_args_copy) {
                this->state->result
                    .template emplace<::std::tuple<::beman::execution::set_error_t, ::std::exception_ptr>>(
                        ::beman::execution::set_error_t{}, ::std::current_exception());
            }
        }
        this->state->complete();
    }
};

template <::beman::execution::sender Sndr, typename Env>
using future_spawned_sender = decltype(::beman::execution::write_env(
    ::beman::execution::detail::stop_when(::std::declval<Sndr>(),
                                          ::std::declval<::beman::execution::inplace_stop_token>()),
    ::std::declval<Env>()));

template <::beman::execution::sender Sndr, typename Env>
using spawn_future_sigs = ::beman::execution::detail::meta::unique<::beman::execution::detail::meta::prepend<
    ::beman::execution::set_stopped_t(),
    ::beman::execution::completion_signatures_of_t<::beman::execution::detail::future_spawned_sender<Sndr, Env>>>>;

template <typename Allocator, ::beman::execution::scope_token Token, ::beman::execution::sender Sndr, typename Env>
struct spawn_future_state
    : ::beman::execution::detail::spawn_future_state_base<::beman::execution::detail::spawn_future_sigs<Sndr, Env>> {
    using alloc_t          = typename ::std::allocator_traits<Allocator>::template rebind_alloc<spawn_future_state>;
    using traits_t         = ::std::allocator_traits<alloc_t>;
    using spawned_sender_t = ::beman::execution::detail::future_spawned_sender<Sndr, Env>;
    using sigs_t           = ::beman::execution::detail::spawn_future_sigs<Sndr, Env>;
    using receiver_t       = ::beman::execution::detail::spawn_future_receiver<sigs_t>;
    static_assert(::beman::execution::sender<spawned_sender_t>);
    static_assert(::beman::execution::receiver<receiver_t>);
    using op_t = ::beman::execution::connect_result_t<spawned_sender_t, receiver_t>;

    template <::beman::execution::sender S>
    spawn_future_state(auto a, S&& s, Token tok, Env env)
        : alloc(::std::move(a)),
          op(::beman::execution::write_env(
                 ::beman::execution::detail::stop_when(::std::forward<S>(s), source.get_token()), env),
             receiver_t{this}),
          token(::std::move(tok)),
          associated(token.try_associate()) {
        if (this->associated) {
            ::beman::execution::start(this->op);
        } else {
            ::beman::execution::set_stopped(receiver_t{this});
        }
    }
    auto complete() noexcept -> void override {
        {
            ::std::lock_guard cerberos(this->gate);
            if (this->fun == nullptr) {
                this->receiver = this;
                return;
            }
        }
        this->fun(this->receiver, *this);
    }
    auto abandon() noexcept -> void {
        bool ready{[&] {
            ::std::lock_guard cerberos(this->gate);
            if (this->receiver == nullptr) {
                this->receiver = this;
                this->fun      = [](void*, spawn_future_state& state) noexcept { state.destroy(); };
                return false;
            }
            return true;
        }()};
        if (ready) {
            this->destroy();
        } else {
            this->source.request_stop();
        }
    }
    template <::beman::execution::receiver Rcvr>
    static auto complete_receiver(Rcvr& rcvr, typename spawn_future_state::result_t& res) noexcept {
        std::visit(
            [&rcvr]<typename Tuplish>(Tuplish&& tuplish) noexcept {
                if constexpr (!::std::same_as<::std::remove_cvref_t<decltype(tuplish)>, ::std::monostate>) {
                    ::std::apply(
                        [&rcvr]<typename... Args>(auto cpo, Args&&... args) {
                            cpo(::std::move(rcvr), ::std::forward<Args>(args)...);
                        },
                        ::std::forward<Tuplish>(tuplish));
                }
            },
            ::std::move(res));
    }
    template <::beman::execution::receiver Rcvr>
    auto consume(Rcvr& rcvr) noexcept -> void {
        {
            ::std::lock_guard cerberos(this->gate);
            if (this->receiver == nullptr) {
                this->receiver = &rcvr;
                this->fun      = [](void* ptr, spawn_future_state& state) noexcept {
                    spawn_future_state::complete_receiver(*static_cast<Rcvr*>(ptr), state.result);
                };
                return;
            }
        }
        spawn_future_state::complete_receiver(rcvr, this->result);
    }
    auto destroy() noexcept -> void {
        Token tok{this->token};
        bool  assoc{this->associated};
        {
            alloc_t a{this->alloc};
            traits_t::destroy(a, this);
            traits_t::deallocate(a, this, 1u);
        }
        if (assoc) {
            tok.disassociate();
        }
    }

    ::std::mutex                            gate{};
    alloc_t                                 alloc;
    ::beman::execution::inplace_stop_source source{};
    op_t                                    op;
    Token                                   token;
    bool                                    associated{false};
    void*                                   receiver{};
    auto (*fun)(void*, spawn_future_state&) noexcept -> void = nullptr;
};

class spawn_future_t {
  public:
    template <::beman::execution::sender Sndr, ::beman::execution::scope_token Tok, typename Ev>
        requires ::beman::execution::detail::queryable<::std::remove_cvref_t<Ev>>
    auto operator()(Sndr&& sndr, Tok&& tok, Ev&& ev) const {
        auto make{[&]() -> decltype(auto) { //-dk:TODO why decltype(auto) instead of auto?
            return tok.wrap(::std::forward<Sndr>(sndr));
        }};
        using sndr_t = decltype(make());
        static_assert(::beman::execution::sender<Sndr>);

        auto [alloc, senv] = spawn_get_allocator(sndr, ev);
        using state_t = ::beman::execution::detail::spawn_future_state<decltype(alloc), Tok, sndr_t, decltype(senv)>;
        using state_alloc_t  = typename ::std::allocator_traits<decltype(alloc)>::template rebind_alloc<state_t>;
        using state_traits_t = ::std::allocator_traits<state_alloc_t>;
        state_alloc_t state_alloc(alloc);
        state_t*      op{state_traits_t::allocate(state_alloc, 1u)};
        try {
            state_traits_t::construct(state_alloc, op, alloc, make(), tok, senv);
        } catch (...) {
            state_traits_t::deallocate(state_alloc, op, 1u);
            throw;
        }

        using deleter = decltype([](state_t* p) noexcept { p->abandon(); });
        return ::beman::execution::detail::make_sender(*this, ::std::unique_ptr<state_t, deleter>{op});
    }
    template <::beman::execution::sender Sndr, ::beman::execution::scope_token Tok>
    auto operator()(Sndr&& sndr, Tok&& tok) const {
        return (*this)(::std::forward<Sndr>(sndr), ::std::forward<Tok>(tok), ::beman::execution::env<>{});
    }
};

template <typename State, typename Deleter, typename Env>
struct completion_signatures_for_impl<
    ::beman::execution::detail::basic_sender<::beman::execution::detail::spawn_future_t,
                                             ::std::unique_ptr<State, Deleter>>,
    Env> {
    using type = typename State::sigs_t;
};

template <>
struct impls_for<spawn_future_t> : ::beman::execution::detail::default_impls {
    static constexpr auto start{[](auto& state, auto& rcvr) noexcept -> void { state->consume(rcvr); }};
};
} // namespace beman::execution::detail

namespace beman::execution {
export using spawn_future_t = ::beman::execution::detail::spawn_future_t;
export inline constexpr spawn_future_t spawn_future{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct spawn_t {
    struct state_base {
        virtual ~state_base()                    = default;
        virtual auto complete() noexcept -> void = 0;
    };

    struct receiver {
        using receiver_concept = ::beman::execution::receiver_t;
        state_base* state{};

        auto set_value() && noexcept -> void { this->state->complete(); }
        auto set_stopped() && noexcept -> void { this->state->complete(); }
    };

    template <typename Alloc, ::beman::execution::scope_token Tok, ::beman::execution::sender Sndr>
    struct state : state_base {
        using op_t     = ::beman::execution::connect_result_t<Sndr, receiver>;
        using alloc_t  = typename ::std::allocator_traits<Alloc>::template rebind_alloc<state>;
        using traits_t = ::std::allocator_traits<alloc_t>;

        state(Alloc a, Sndr&& sndr, Tok tok)
            : alloc(a), op(::beman::execution::connect(::std::forward<Sndr>(sndr), receiver{this})), token(tok) {
            if (this->token.try_associate()) {
                ::beman::execution::start(this->op);
            } else {
                this->destroy();
            }
        }
        auto complete() noexcept -> void override {
            Tok tok(this->token);
            this->destroy();
            tok.disassociate();
        }
        auto destroy() noexcept -> void {
            alloc_t all(this->alloc);
            traits_t::destroy(all, this);
            traits_t::deallocate(all, this, 1);
        }

        alloc_t alloc;
        op_t    op;
        Tok     token;
    };

    template <::beman::execution::sender Sender, ::beman::execution::scope_token Token, typename Env>
    auto operator()(Sender&& sender, Token&& tok, Env&& env) const {
        auto new_sender{tok.wrap(::std::forward<Sender>(sender))};
        auto [all, senv] = ::beman::execution::detail::spawn_get_allocator(new_sender, env);

        using sender_t = decltype(::beman::execution::write_env(::std::move(new_sender), senv));
        using state_t  = state<decltype(all), Token, sender_t>;
        using alloc_t  = typename ::std::allocator_traits<decltype(all)>::template rebind_alloc<state_t>;
        using traits_t = ::std::allocator_traits<alloc_t>;
        alloc_t  alloc(all);
        state_t* op{traits_t::allocate(alloc, 1u)};
        traits_t::construct(alloc, op, all, ::beman::execution::write_env(::std::move(new_sender), senv), tok);
    }
    template <::beman::execution::sender Sender, ::beman::execution::scope_token Token>
    auto operator()(Sender&& sender, Token&& token) const {
        return (*this)(::std::forward<Sender>(sender), ::std::forward<Token>(token), ::beman::execution::env<>{});
    }
};
} // namespace beman::execution::detail

namespace beman::execution {
export using spawn_t = ::beman::execution::detail::spawn_t;
export inline constexpr spawn_t spawn{};
} // namespace beman::execution

// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------

namespace beman::execution::detail {
struct on_t : ::beman::execution::sender_adaptor_closure<on_t> {
    template <::beman::execution::detail::sender_for<on_t> OutSndr, typename Env>
    auto transform_env(OutSndr&& out_sndr, Env&& env) const -> decltype(auto) {
        auto&& data{out_sndr.template get<1>()};

        if constexpr (::beman::execution::scheduler<decltype(data)>)
            return ::beman::execution::detail::join_env(
                ::beman::execution::detail::sched_env(::beman::execution::detail::forward_like<OutSndr>(data)

                                                          ),
                ::beman::execution::detail::fwd_env(::std::forward<Env>(env)));
        else
            return std::forward<Env>(env);
    }

    template <typename>
    struct env_needs_get_scheduler {
        using sender_concept = ::beman::execution::sender_t;
        template <typename Env>
        auto get_completion_signatures(Env&&) const {
            return env_needs_get_scheduler<Env>{};
        }
    };

    template <::beman::execution::detail::sender_for<on_t> OutSndr, typename Env>
    auto transform_sender(OutSndr&& out_sndr, Env&& env) const -> decltype(auto) {
        struct not_a_scheduler {};
        auto&& [_, data, child] = out_sndr;

        if constexpr (::beman::execution::scheduler<decltype(data)>) {
            auto sch{::beman::execution::detail::query_with_default(
                ::beman::execution::get_scheduler, env, not_a_scheduler{})};
            if constexpr (::std::same_as<not_a_scheduler, decltype(sch)>) {
                return env_needs_get_scheduler<Env>{};
            } else {
                return ::beman::execution::continues_on(
                    ::beman::execution::starts_on(::beman::execution::detail::forward_like<OutSndr>(data),
                                                  ::beman::execution::detail::forward_like<OutSndr>(child)),
                    ::std::move(sch));
            }
        } else {
            auto& [sch, closure] = data;
            auto orig_sch{::beman::execution::detail::query_with_default(
                ::beman::execution::get_completion_scheduler<::beman::execution::set_value_t>,
                ::beman::execution::get_env(child),
                ::beman::execution::detail::query_with_default(
                    ::beman::execution::get_scheduler, env, not_a_scheduler{}))};

            if constexpr (::std::same_as<not_a_scheduler, decltype(orig_sch)>) {
                return env_needs_get_scheduler<Env>{};
            } else {
                return ::beman::execution::detail::write_env(
                    ::beman::execution::continues_on(
                        ::beman::execution::detail::forward_like<OutSndr>(closure)(::beman::execution::continues_on(
                            ::beman::execution::detail::write_env(
                                ::beman::execution::detail::forward_like<OutSndr>(child),
                                ::beman::execution::detail::sched_env(orig_sch)),
                            sch)),
                        orig_sch),
                    ::beman::execution::detail::sched_env(env));
            }
        }
    }

    template <::beman::execution::scheduler Sch, ::beman::execution::sender Sndr>
        requires ::beman::execution::detail::is_sender_adaptor_closure<Sndr>
    auto operator()(Sch&&, Sndr&&) const -> void =
        BEMAN_EXECUTION_DELETE("on(sch, sndr) requires that sndr isn't both a sender and sender adaptor closure");

    template <::beman::execution::scheduler                         Sch,
              ::beman::execution::sender                            Sndr,
              ::beman::execution::detail::is_sender_adaptor_closure Closure>
        requires ::beman::execution::detail::is_sender_adaptor_closure<Sndr>
    auto operator()(Sndr&&, Sch&&, Closure&&) const -> void =
        BEMAN_EXECUTION_DELETE("on(sch, sndr) requires that sndr isn't both a sender and sender adaptor closure");

    template <::beman::execution::scheduler Sch, ::beman::execution::sender Sndr>
    auto operator()(Sch&& sch, Sndr&& sndr) const {
        auto domain{::beman::execution::detail::query_with_default(
            ::beman::execution::get_domain, sch, ::beman::execution::default_domain{})};
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(*this, ::std::forward<Sch>(sch), ::std::forward<Sndr>(sndr)));
    }
    template <::beman::execution::scheduler                         Sch,
              ::beman::execution::sender                            Sndr,
              ::beman::execution::detail::is_sender_adaptor_closure Closure>
    auto operator()(Sndr&& sndr, Sch&& sch, Closure&& closure) const {
        auto domain{::beman::execution::detail::get_domain_early(sndr)};
        return ::beman::execution::transform_sender(
            domain,
            ::beman::execution::detail::make_sender(
                *this,
                ::beman::execution::detail::product_type{::std::forward<Sch>(sch), ::std::forward<Closure>(closure)},
                ::std::forward<Sndr>(sndr)));
    }
    template <::beman::execution::scheduler Sch, ::beman::execution::detail::is_sender_adaptor_closure Closure>
    auto operator()(Sch&& sch, Closure&& closure) const {
        return ::beman::execution::detail::sender_adaptor{
            *this, ::std::forward<Sch>(sch), ::std::forward<Closure>(closure)};
    }
};

} // namespace beman::execution::detail

namespace beman::execution {
export using on_t = ::beman::execution::detail::on_t;
export inline constexpr ::beman::execution::on_t on{};
} // namespace beman::execution

// ----------------------------------------------------------------------------
